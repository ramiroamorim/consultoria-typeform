import {
  __commonJS,
  __privateAdd,
  __privateMethod,
  __publicField
} from "./chunk-S3XCI6LX.js";

// node_modules/formsmd/src/phone-numbers.js
var require_phone_numbers = __commonJS({
  "node_modules/formsmd/src/phone-numbers.js"(exports) {
    "use strict";
    var placeholdersAndCallingCodes = {
      AC: { placeholder: "40123", callingCode: "+247" },
      AD: { placeholder: "312 345", callingCode: "+376" },
      AE: { placeholder: "050 123 4567", callingCode: "+971" },
      AF: { placeholder: "070 123 4567", callingCode: "+93" },
      AG: { placeholder: "(268) 464-1234", callingCode: "+1268" },
      AI: { placeholder: "(264) 235-1234", callingCode: "+1264" },
      AL: { placeholder: "067 212 3456", callingCode: "+355" },
      AM: { placeholder: "077 123456", callingCode: "+374" },
      AN: { placeholder: "", callingCode: "+599" },
      AO: { placeholder: "923 123 456", callingCode: "+244" },
      AQ: { placeholder: "", callingCode: "+672" },
      AR: { placeholder: "011 15-2345-6789", callingCode: "+54" },
      AS: { placeholder: "(684) 733-1234", callingCode: "+1684" },
      AT: { placeholder: "0664 123456", callingCode: "+43" },
      AU: { placeholder: "0412 345 678", callingCode: "+61" },
      AW: { placeholder: "560 1234", callingCode: "+297" },
      AX: { placeholder: "041 2345678", callingCode: "+358" },
      AZ: { placeholder: "040 123 45 67", callingCode: "+994" },
      BA: { placeholder: "061 123 456", callingCode: "+387" },
      BB: { placeholder: "(246) 250-1234", callingCode: "+1246" },
      BD: { placeholder: "01812-345678", callingCode: "+880" },
      BE: { placeholder: "0470 12 34 56", callingCode: "+32" },
      BF: { placeholder: "70 12 34 56", callingCode: "+226" },
      BG: { placeholder: "043 012 345", callingCode: "+359" },
      BH: { placeholder: "3600 1234", callingCode: "+973" },
      BI: { placeholder: "79 56 12 34", callingCode: "+257" },
      BJ: { placeholder: "90 01 12 34", callingCode: "+229" },
      BL: { placeholder: "0690 00 12 34", callingCode: "+590" },
      BM: { placeholder: "(441) 370-1234", callingCode: "+1441" },
      BN: { placeholder: "712 3456", callingCode: "+673" },
      BO: { placeholder: "71234567", callingCode: "+591" },
      BQ: { placeholder: "318 1234", callingCode: "+599" },
      BR: { placeholder: "(11) 96123-4567", callingCode: "+55" },
      BS: { placeholder: "(242) 359-1234", callingCode: "+1242" },
      BT: { placeholder: "17 12 34 56", callingCode: "+975" },
      BW: { placeholder: "71 123 456", callingCode: "+267" },
      BY: { placeholder: "8 029 491-19-11", callingCode: "+375" },
      BZ: { placeholder: "622-1234", callingCode: "+501" },
      CA: { placeholder: "(506) 234-5678", callingCode: "+1" },
      CC: { placeholder: "0412 345 678", callingCode: "+61" },
      CD: { placeholder: "0991 234 567", callingCode: "+243" },
      CF: { placeholder: "70 01 23 45", callingCode: "+236" },
      CG: { placeholder: "06 123 4567", callingCode: "+242" },
      CH: { placeholder: "078 123 45 67", callingCode: "+41" },
      CI: { placeholder: "01 23 45 6789", callingCode: "+225" },
      CK: { placeholder: "71 234", callingCode: "+682" },
      CL: { placeholder: "(2) 2123 4567", callingCode: "+56" },
      CM: { placeholder: "6 71 23 45 67", callingCode: "+237" },
      CN: { placeholder: "131 2345 6789", callingCode: "+86" },
      CO: { placeholder: "321 1234567", callingCode: "+57" },
      CR: { placeholder: "8312 3456", callingCode: "+506" },
      CU: { placeholder: "05 1234567", callingCode: "+53" },
      CV: { placeholder: "991 12 34", callingCode: "+238" },
      CW: { placeholder: "9 518 1234", callingCode: "+599" },
      CX: { placeholder: "0412 345 678", callingCode: "+61" },
      CY: { placeholder: "96 123456", callingCode: "+357" },
      CZ: { placeholder: "601 123 456", callingCode: "+420" },
      DE: { placeholder: "01512 3456789", callingCode: "+49" },
      DJ: { placeholder: "77 83 10 01", callingCode: "+253" },
      DK: { placeholder: "34 41 23 45", callingCode: "+45" },
      DM: { placeholder: "(767) 225-1234", callingCode: "+1767" },
      DO: { placeholder: "(809) 234-5678", callingCode: "+1849" },
      DZ: { placeholder: "0551 23 45 67", callingCode: "+213" },
      EC: { placeholder: "099 123 4567", callingCode: "+593" },
      EE: { placeholder: "5123 4567", callingCode: "+372" },
      EG: { placeholder: "010 01234567", callingCode: "+20" },
      EH: { placeholder: "0650-123456", callingCode: "+212" },
      ER: { placeholder: "07 123 456", callingCode: "+291" },
      ES: { placeholder: "612 34 56 78", callingCode: "+34" },
      ET: { placeholder: "091 123 4567", callingCode: "+251" },
      FI: { placeholder: "041 2345678", callingCode: "+358" },
      FJ: { placeholder: "701 2345", callingCode: "+679" },
      FK: { placeholder: "51234", callingCode: "+500" },
      FM: { placeholder: "350 1234", callingCode: "+691" },
      FO: { placeholder: "211234", callingCode: "+298" },
      FR: { placeholder: "06 12 34 56 78", callingCode: "+33" },
      GA: { placeholder: "06 03 12 34", callingCode: "+241" },
      GB: { placeholder: "07400 123456", callingCode: "+44" },
      GD: { placeholder: "(473) 403-1234", callingCode: "+1473" },
      GE: { placeholder: "555 12 34 56", callingCode: "+995" },
      GF: { placeholder: "0694 20 12 34", callingCode: "+594" },
      GG: { placeholder: "07781 123456", callingCode: "+44" },
      GH: { placeholder: "023 123 4567", callingCode: "+233" },
      GI: { placeholder: "57123456", callingCode: "+350" },
      GL: { placeholder: "22 12 34", callingCode: "+299" },
      GM: { placeholder: "301 2345", callingCode: "+220" },
      GN: { placeholder: "601 12 34 56", callingCode: "+224" },
      GP: { placeholder: "0690 00 12 34", callingCode: "+590" },
      GQ: { placeholder: "222 123 456", callingCode: "+240" },
      GR: { placeholder: "691 234 5678", callingCode: "+30" },
      GS: { placeholder: "", callingCode: "+500" },
      GT: { placeholder: "5123 4567", callingCode: "+502" },
      GU: { placeholder: "(671) 300-1234", callingCode: "+1671" },
      GW: { placeholder: "955 012 345", callingCode: "+245" },
      GY: { placeholder: "609 1234", callingCode: "+595" },
      HK: { placeholder: "5123 4567", callingCode: "+852" },
      HM: { placeholder: "", callingCode: "+672" },
      HN: { placeholder: "9123-4567", callingCode: "+504" },
      HR: { placeholder: "092 123 4567", callingCode: "+385" },
      HT: { placeholder: "34 10 1234", callingCode: "+509" },
      HU: { placeholder: "06 20 123 4567", callingCode: "+36" },
      ID: { placeholder: "0812-345-678", callingCode: "+62" },
      IE: { placeholder: "085 012 3456", callingCode: "+353" },
      IL: { placeholder: "050-234-5678", callingCode: "+972" },
      IM: { placeholder: "07924 123456", callingCode: "+44" },
      IN: { placeholder: "081234 56789", callingCode: "+91" },
      IO: { placeholder: "380 1234", callingCode: "+246" },
      IQ: { placeholder: "0791 234 5678", callingCode: "+964" },
      IR: { placeholder: "0912 345 6789", callingCode: "+98" },
      IS: { placeholder: "611 1234", callingCode: "+354" },
      IT: { placeholder: "312 345 6789", callingCode: "+39" },
      JE: { placeholder: "07797 712345", callingCode: "+44" },
      JM: { placeholder: "(876) 210-1234", callingCode: "+1876" },
      JO: { placeholder: "07 9012 3456", callingCode: "+962" },
      JP: { placeholder: "090-1234-5678", callingCode: "+81" },
      KE: { placeholder: "0712 123456", callingCode: "+254" },
      KG: { placeholder: "0700 123 456", callingCode: "+996" },
      KH: { placeholder: "091 234 567", callingCode: "+855" },
      KI: { placeholder: "72001234", callingCode: "+686" },
      KM: { placeholder: "321 23 45", callingCode: "+269" },
      KN: { placeholder: "(869) 765-2917", callingCode: "+1869" },
      KP: { placeholder: "0192 123 4567", callingCode: "+850" },
      KR: { placeholder: "010-2000-0000", callingCode: "+82" },
      KW: { placeholder: "500 12345", callingCode: "+965" },
      KY: { placeholder: "(345) 323-1234", callingCode: "+ 345" },
      KZ: { placeholder: "8 (771) 000 9998", callingCode: "+77" },
      LA: { placeholder: "020 23 123 456", callingCode: "+856" },
      LB: { placeholder: "71 123 456", callingCode: "+961" },
      LC: { placeholder: "(758) 284-5678", callingCode: "+1758" },
      LI: { placeholder: "660 234 567", callingCode: "+423" },
      LK: { placeholder: "071 234 5678", callingCode: "+94" },
      LR: { placeholder: "077 012 3456", callingCode: "+231" },
      LS: { placeholder: "5012 3456", callingCode: "+266" },
      LT: { placeholder: "(0-612) 34567", callingCode: "+370" },
      LU: { placeholder: "628 123 456", callingCode: "+352" },
      LV: { placeholder: "21 234 567", callingCode: "+371" },
      LY: { placeholder: "091-2345678", callingCode: "+218" },
      MA: { placeholder: "0650-123456", callingCode: "+212" },
      MC: { placeholder: "06 12 34 56 78", callingCode: "+377" },
      MD: { placeholder: "0621 12 345", callingCode: "+373" },
      ME: { placeholder: "067 622 901", callingCode: "+382" },
      MF: { placeholder: "0690 00 12 34", callingCode: "+590" },
      MG: { placeholder: "032 12 345 67", callingCode: "+261" },
      MH: { placeholder: "235-1234", callingCode: "+692" },
      MK: { placeholder: "072 345 678", callingCode: "+389" },
      ML: { placeholder: "65 01 23 45", callingCode: "+223" },
      MM: { placeholder: "09 212 3456", callingCode: "+95" },
      MN: { placeholder: "8812 3456", callingCode: "+976" },
      MO: { placeholder: "6612 3456", callingCode: "+853" },
      MP: { placeholder: "(670) 234-5678", callingCode: "+1670" },
      MQ: { placeholder: "0696 20 12 34", callingCode: "+596" },
      MR: { placeholder: "22 12 34 56", callingCode: "+222" },
      MS: { placeholder: "(664) 492-3456", callingCode: "+1664" },
      MT: { placeholder: "9696 1234", callingCode: "+356" },
      MU: { placeholder: "5251 2345", callingCode: "+230" },
      MV: { placeholder: "771-2345", callingCode: "+960" },
      MW: { placeholder: "0991 23 45 67", callingCode: "+265" },
      MX: { placeholder: "222 123 4567", callingCode: "+52" },
      MY: { placeholder: "012-345 6789", callingCode: "+60" },
      MZ: { placeholder: "82 123 4567", callingCode: "+258" },
      NA: { placeholder: "081 123 4567", callingCode: "+264" },
      NC: { placeholder: "75.12.34", callingCode: "+687" },
      NE: { placeholder: "93 12 34 56", callingCode: "+227" },
      NF: { placeholder: "3 81234", callingCode: "+672" },
      NG: { placeholder: "0802 123 4567", callingCode: "+234" },
      NI: { placeholder: "8123 4567", callingCode: "+505" },
      NL: { placeholder: "06 12345678", callingCode: "+31" },
      NO: { placeholder: "40 61 23 45", callingCode: "+47" },
      NP: { placeholder: "984-1234567", callingCode: "+977" },
      NR: { placeholder: "555 1234", callingCode: "+674" },
      NU: { placeholder: "888 4012", callingCode: "+683" },
      NZ: { placeholder: "021 123 4567", callingCode: "+64" },
      OM: { placeholder: "9212 3456", callingCode: "+968" },
      PA: { placeholder: "6123-4567", callingCode: "+507" },
      PE: { placeholder: "912 345 678", callingCode: "+51" },
      PF: { placeholder: "87 12 34 56", callingCode: "+689" },
      PG: { placeholder: "7012 3456", callingCode: "+675" },
      PH: { placeholder: "0905 123 4567", callingCode: "+63" },
      PK: { placeholder: "0301 2345678", callingCode: "+92" },
      PL: { placeholder: "512 345 678", callingCode: "+48" },
      PM: { placeholder: "055 12 34", callingCode: "+508" },
      PN: { placeholder: "", callingCode: "+872" },
      PR: { placeholder: "(787) 234-5678", callingCode: "+1939" },
      PS: { placeholder: "0599 123 456", callingCode: "+970" },
      PT: { placeholder: "912 345 678", callingCode: "+351" },
      PW: { placeholder: "620 1234", callingCode: "+680" },
      PY: { placeholder: "0961 456789", callingCode: "+595" },
      QA: { placeholder: "3312 3456", callingCode: "+974" },
      RE: { placeholder: "0692 12 34 56", callingCode: "+262" },
      RO: { placeholder: "0712 034 567", callingCode: "+40" },
      RS: { placeholder: "060 1234567", callingCode: "+381" },
      RU: { placeholder: "8 (912) 345-67-89", callingCode: "+7" },
      RW: { placeholder: "0720 123 456", callingCode: "+250" },
      SA: { placeholder: "051 234 5678", callingCode: "+966" },
      SB: { placeholder: "74 21234", callingCode: "+677" },
      SC: { placeholder: "2 510 123", callingCode: "+248" },
      SD: { placeholder: "091 123 1234", callingCode: "+249" },
      SE: { placeholder: "070-123 45 67", callingCode: "+46" },
      SG: { placeholder: "8123 4567", callingCode: "+65" },
      SH: { placeholder: "51234", callingCode: "+290" },
      SI: { placeholder: "031 234 567", callingCode: "+386" },
      SJ: { placeholder: "41 23 45 67", callingCode: "+47" },
      SK: { placeholder: "0912 123 456", callingCode: "+421" },
      SL: { placeholder: "(025) 123456", callingCode: "+232" },
      SM: { placeholder: "66 66 12 12", callingCode: "+378" },
      SN: { placeholder: "70 123 45 67", callingCode: "+221" },
      SO: { placeholder: "7 1123456", callingCode: "+252" },
      SR: { placeholder: "741-2345", callingCode: "+597" },
      SS: { placeholder: "0977 123 456", callingCode: "+211" },
      ST: { placeholder: "981 2345", callingCode: "+239" },
      SV: { placeholder: "7012 3456", callingCode: "+503" },
      SX: { placeholder: "(721) 520-5678", callingCode: "+1" },
      SY: { placeholder: "0944 567 890", callingCode: "+963" },
      SZ: { placeholder: "7612 3456", callingCode: "+268" },
      TA: { placeholder: "8999", callingCode: "+290" },
      TC: { placeholder: "(649) 231-1234", callingCode: "+1649" },
      TD: { placeholder: "63 01 23 45", callingCode: "+235" },
      TF: { placeholder: "", callingCode: "+262" },
      TG: { placeholder: "90 11 23 45", callingCode: "+228" },
      TH: { placeholder: "081 234 5678", callingCode: "+66" },
      TJ: { placeholder: "91 712 3456", callingCode: "+992" },
      TK: { placeholder: "7290", callingCode: "+690" },
      TL: { placeholder: "7721 2345", callingCode: "+670" },
      TM: { placeholder: "8 66 123456", callingCode: "+993" },
      TN: { placeholder: "20 123 456", callingCode: "+216" },
      TO: { placeholder: "771 5123", callingCode: "+676" },
      TR: { placeholder: "0501 234 56 78", callingCode: "+90" },
      TT: { placeholder: "(868) 291-1234", callingCode: "+1868" },
      TV: { placeholder: "90 1234", callingCode: "+688" },
      TW: { placeholder: "0912 345 678", callingCode: "+886" },
      TZ: { placeholder: "0621 234 567", callingCode: "+255" },
      UA: { placeholder: "050 123 4567", callingCode: "+380" },
      UG: { placeholder: "0712 345678", callingCode: "+256" },
      US: { placeholder: "(201) 555-0123", callingCode: "+1" },
      UY: { placeholder: "094 231 234", callingCode: "+598" },
      UZ: { placeholder: "91 234 56 78", callingCode: "+998" },
      VA: { placeholder: "312 345 6789", callingCode: "+379" },
      VC: { placeholder: "(784) 430-1234", callingCode: "+1784" },
      VE: { placeholder: "0412-1234567", callingCode: "+58" },
      VG: { placeholder: "(284) 300-1234", callingCode: "+1284" },
      VI: { placeholder: "(340) 642-1234", callingCode: "+1340" },
      VN: { placeholder: "0912 345 678", callingCode: "+84" },
      VU: { placeholder: "591 2345", callingCode: "+678" },
      WF: { placeholder: "82 12 34", callingCode: "+681" },
      WS: { placeholder: "72 12345", callingCode: "+685" },
      XK: { placeholder: "043 201 234", callingCode: "+383" },
      YE: { placeholder: "0712 345 678", callingCode: "+967" },
      YT: { placeholder: "0639 01 23 45", callingCode: "+262" },
      ZA: { placeholder: "071 123 4567", callingCode: "+27" },
      ZM: { placeholder: "095 5123456", callingCode: "+260" },
      ZW: { placeholder: "071 234 5678", callingCode: "+263" }
    };
    function getPhoneNumberPlaceholder(countryCode) {
      countryCode = countryCode.toUpperCase();
      if (placeholdersAndCallingCodes[countryCode] === void 0) {
        countryCode = "US";
      }
      return placeholdersAndCallingCodes[countryCode].placeholder || "";
    }
    function createCountryCallingCodeOptions(selectedCountryCode, availableCountryCodes) {
      selectedCountryCode = selectedCountryCode.toUpperCase();
      if (placeholdersAndCallingCodes[selectedCountryCode] === void 0) {
        selectedCountryCode = "US";
      }
      const available = [];
      if (availableCountryCodes.length === 0) {
        for (const key of Object.keys(placeholdersAndCallingCodes)) {
          available.push(key);
        }
      } else {
        for (const key of availableCountryCodes) {
          available.push(key.toUpperCase().trim());
        }
      }
      if (!available.includes(selectedCountryCode)) {
        available.unshift(selectedCountryCode);
      }
      const options = [];
      for (const country of available) {
        if (placeholdersAndCallingCodes[country] !== void 0) {
          const callingCode = placeholdersAndCallingCodes[country].callingCode;
          const placeholder = placeholdersAndCallingCodes[country].placeholder;
          const selected = country === selectedCountryCode ? " selected" : "";
          options.push(
            `<option value="${country} ${callingCode}"${selected} data-fmd-placeholder="${placeholder}">${country}</option>`
          );
        }
      }
      return options.join("\n");
    }
    exports.placeholdersAndCallingCodes = placeholdersAndCallingCodes;
    exports.getPhoneNumberPlaceholder = getPhoneNumberPlaceholder;
    exports.createCountryCallingCodeOptions = createCountryCallingCodeOptions;
  }
});

// node_modules/formsmd/src/helpers.js
var require_helpers = __commonJS({
  "node_modules/formsmd/src/helpers.js"(exports) {
    "use strict";
    function isNumeric(str) {
      if (typeof str != "string") {
        return false;
      }
      return !isNaN(str) && // Use type coercion to parse the entirety of the string (`parseFloat` alone does not do this)
      !isNaN(parseFloat(str));
    }
    exports.isNumeric = isNumeric;
    var escapeTest = /[&<>"']/;
    var escapeReplace = new RegExp(escapeTest.source, "g");
    var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
    var escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape$1(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html;
    }
    function cleanUrl(href) {
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e) {
        return null;
      }
      return href;
    }
    exports.escape$1 = escape$1;
    exports.cleanUrl = cleanUrl;
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#(0+)?39);/g;
    var reHasEscapedHtml = RegExp(reEscapedHtml.source);
    function unescape(string) {
      return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, (entity) => htmlUnescapes[entity] || "'") : string || "";
    }
    exports.unescape = unescape;
  }
});

// node_modules/formsmd/src/settings-parse.js
var require_settings_parse = __commonJS({
  "node_modules/formsmd/src/settings-parse.js"(exports) {
    "use strict";
    var { unescape } = require_helpers();
    function parseColor(colorString) {
      let ok = false;
      let r, g, b;
      if (colorString.charAt(0) == "#") {
        colorString = colorString.substr(1, 6);
      }
      colorString = colorString.replace(/ /g, "");
      colorString = colorString.toLowerCase();
      const simpleColors = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
      };
      for (let key in simpleColors) {
        if (colorString == key) {
          colorString = simpleColors[key];
        }
      }
      const colorDefs = [
        {
          re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
          example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
          process: function(bits) {
            return [parseInt(bits[1]), parseInt(bits[2]), parseInt(bits[3])];
          }
        },
        {
          re: /^(\w{2})(\w{2})(\w{2})$/,
          example: ["#00ff00", "336699"],
          process: function(bits) {
            return [
              parseInt(bits[1], 16),
              parseInt(bits[2], 16),
              parseInt(bits[3], 16)
            ];
          }
        },
        {
          re: /^(\w{1})(\w{1})(\w{1})$/,
          example: ["#fb0", "f0f"],
          process: function(bits) {
            return [
              parseInt(bits[1] + bits[1], 16),
              parseInt(bits[2] + bits[2], 16),
              parseInt(bits[3] + bits[3], 16)
            ];
          }
        }
      ];
      for (let i = 0; i < colorDefs.length; i++) {
        const re = colorDefs[i].re;
        const processor = colorDefs[i].process;
        const bits = re.exec(colorString);
        if (bits) {
          const channels = processor(bits);
          r = channels[0];
          g = channels[1];
          b = channels[2];
          ok = true;
        }
      }
      if (ok) {
        r = r < 0 || isNaN(r) ? 0 : r > 255 ? 255 : r;
        g = g < 0 || isNaN(g) ? 0 : g > 255 ? 255 : g;
        b = b < 0 || isNaN(b) ? 0 : b > 255 ? 255 : b;
        return `${r}, ${g}, ${b}`;
      } else {
        throw "Not a valid color (name, hex code, or RGB)";
      }
    }
    function getDefaultSettings() {
      return {
        "color-scheme": "light",
        "color-scheme-scope": "domain-wide",
        "css-prefix": "fmd-",
        "dir": "ltr",
        "form-delimiter": "|",
        "get-format": "json",
        "get-objects-name": "objects",
        "id": "",
        "localization": "en",
        "page": "form-slides",
        "slide-delimiter": "---"
      };
    }
    function parseSettings(template) {
      const settingsRef = {
        "accent": {
          accepted: "valid color (name, hex code, or RGB)"
        },
        "accent-alt-scheme": {
          accepted: "valid color (name, hex code, or RGB)"
        },
        "accent-foreground": {
          accepted: "valid color (name, hex code, or RGB)"
        },
        "accent-foreground-alt-scheme": {
          accepted: "valid color (name, hex code, or RGB)"
        },
        "autofocus": {
          pattern: /^all-slides$/,
          accepted: "all-slides"
        },
        "backdrop-opacity": {
          pattern: /^[0-9.]+%?$/,
          accepted: "valid positive number or percentage"
        },
        "backdrop-opacity-alt-scheme": {
          pattern: /^[0-9.]+%?$/,
          accepted: "valid positive number or percentage"
        },
        "background-color": {
          accepted: "valid color (name, hex code, or RGB)"
        },
        "background-color-alt-scheme": {
          accepted: "valid color (name, hex code, or RGB)"
        },
        "background-image": {
          pattern: /^.*$/,
          accepted: "valid CSS for background-image"
        },
        "background-image-alt-scheme": {
          pattern: /^.*$/,
          accepted: "valid CSS for background-image"
        },
        "brand": {
          pattern: /^!\[.*\]\(.*\)$/s,
          accepted: "Markdown image, example: ![Example logo](https://example.com/logo.png)"
        },
        "brand-alt-scheme": {
          pattern: /^!\[.*\]\(.*\)$/s,
          accepted: "Markdown image, example: ![Example logo](https://example.com/logo.png)"
        },
        "button-alignment": {
          pattern: /^(center|end|stretch)$/,
          accepted: "center || end || stretch"
        },
        "color": {
          accepted: "valid color (name, hex code, or RGB)"
        },
        "color-alt-scheme": {
          accepted: "valid color (name, hex code, or RGB)"
        },
        "color-scheme": {
          pattern: /^(light|dark)$/,
          accepted: "light (default) || dark"
        },
        "color-scheme-scope": {
          pattern: /^(domain-wide|isolate)$/,
          accepted: "domain-wide (default) || isolate"
        },
        "color-scheme-toggle": {
          pattern: /^show$/,
          accepted: "show"
        },
        "css-prefix": {
          pattern: /^.*$/,
          accepted: "valid string"
        },
        "cta": {
          pattern: /^\[.*\]\(.*\)$/s,
          accepted: "Markdown link, example: [Sign Up](https://example.com/sign-up/)"
        },
        "dir": {
          pattern: /^(ltr|rtl)$/,
          accepted: "ltr (default) || rtl"
        },
        "favicon": {
          pattern: /^.*$/,
          accepted: "valid path to favicon"
        },
        "field-size": {
          pattern: /^sm$/,
          accepted: "sm"
        },
        "font-family": {
          pattern: /^.*$/,
          accepted: "valid font family"
        },
        "font-import-url": {
          pattern: /^.*$/,
          accepted: "valid URL to font"
        },
        "font-size": {
          pattern: /^(sm|lg)$/,
          accepted: "sm || lg"
        },
        "footer": {
          pattern: /^(hide|show)$/,
          accepted: "hide || show"
        },
        "form-delimiter": {
          pattern: /^.*$/,
          accepted: "valid string"
        },
        "formsmd-branding": {
          pattern: /^(hide|show)$/,
          accepted: "hide || show"
        },
        "form-style": {
          pattern: /^classic$/,
          accepted: "classic"
        },
        "get-format": {
          pattern: /^(json|csv|tsv)$/,
          accepted: "json (default) || csv || tsv"
        },
        "get-objects-name": {
          pattern: /^.*$/,
          accepted: "valid string"
        },
        "get-url": {
          pattern: /^.*$/,
          accepted: "valid URL"
        },
        "header": {
          pattern: /^(align|hide|show)$/,
          accepted: "align || hide || show"
        },
        "headings": {
          pattern: /^anchored$/,
          accepted: "anchored"
        },
        "id": {
          pattern: /^[a-zA-Z][\w:.-]*$/,
          accepted: "valid HTML id"
        },
        "label-style": {
          pattern: /^classic$/,
          accepted: "classic"
        },
        "localization": {
          pattern: /^.*$/,
          accepted: "valid string"
        },
        "meta-author": {
          pattern: /^.*$/,
          accepted: "valid string"
        },
        "meta-description": {
          pattern: /^.*$/,
          accepted: "valid string"
        },
        "meta-image": {
          pattern: /^.*$/,
          accepted: "valid URL to image"
        },
        "meta-keywords": {
          pattern: /^.*$/,
          accepted: "comma-separated values"
        },
        "meta-type": {
          pattern: /^.*$/,
          accepted: "valid string"
        },
        "meta-url": {
          pattern: /^.*$/,
          accepted: "valid URL"
        },
        "page": {
          pattern: /^(form-slides|slides|single)$/,
          accepted: "form-slides (default) || slides || single"
        },
        "page-progress": {
          pattern: /^(hide|show|decorative)$/,
          accepted: "hide || show || decorative"
        },
        "placeholders": {
          pattern: /^(hide|show)$/,
          accepted: "hide || show"
        },
        "post-sheet-name": {
          pattern: /^.*$/,
          accepted: "valid string"
        },
        "post-url": {
          pattern: /^.*$/,
          accepted: "valid URL"
        },
        "restart-button": {
          pattern: /^show$/,
          accepted: "show"
        },
        "rounded": {
          pattern: /^(none|pill)$/,
          accepted: "none || pill"
        },
        "slide-controls": {
          pattern: /^(hide|show)$/,
          accepted: "hide || show"
        },
        "slide-delimiter": {
          pattern: /^.*$/,
          accepted: "valid string"
        },
        "submit-button-text": {
          pattern: /^.*$/,
          accepted: "valid string"
        },
        "title": {
          pattern: /^.*$/,
          accepted: "valid string"
        },
        "vertical-alignment": {
          pattern: /^start$/,
          accepted: "start"
        }
      };
      const lines = template.split("\n");
      const userSettings = {};
      const restLines = [];
      for (let line of lines) {
        if (line.trim().startsWith("#!")) {
          line = line.trim();
          line = line.slice(2);
          let equalIndex = line.indexOf("=");
          if (equalIndex !== -1) {
            let key = line.slice(0, equalIndex).trim();
            let value = line.slice(equalIndex + 1).trim();
            if (!key.endsWith("-alt-scheme")) {
              let valueSplit = value.split("||");
              userSettings[key] = valueSplit[0].trim();
              if (valueSplit.length > 1) {
                userSettings[`${key}-alt-scheme`] = valueSplit[1].trim();
              }
            }
          }
        } else {
          restLines.push(line);
        }
      }
      const settings = {};
      for (let [key, value] of Object.entries(userSettings)) {
        if (value === "") {
          continue;
        }
        if (!(key in settingsRef)) {
          if (!key.endsWith("-alt-scheme")) {
            console.warn(`[SETTINGS] "${key}" is not a valid setting`);
          }
          continue;
        }
        let valueInvalid = false;
        if (key === "accent" || key === "accent-alt-scheme" || key === "accent-foreground" || key === "accent-foreground-alt-scheme" || key === "background-color" || key === "background-color-alt-scheme" || key === "color" || key === "color-alt-scheme") {
          try {
            settings[key] = parseColor(value);
          } catch {
            valueInvalid = true;
          }
        } else if (key === "css-prefix") {
          if (value.match(settingsRef[key].pattern)) {
            settings[key] = value === "none" ? "" : unescape(value.replace(/\\n/g, "\n"));
          } else {
            valueInvalid = true;
          }
        } else {
          if (value.match(settingsRef[key].pattern)) {
            settings[key] = unescape(value.replace(/\\n/g, "\n"));
          } else {
            valueInvalid = true;
          }
        }
        if (valueInvalid) {
          let keyForUser = key;
          if (key.endsWith("-alt-scheme")) {
            keyForUser = key.substring(0, key.length - "-alt-scheme".length);
          }
          console.warn(
            `[SETTINGS] "${keyForUser}" value "${value}" is not valid, accepted: ${settingsRef[key].accepted}`
          );
        }
      }
      return {
        template: restLines.join("\n"),
        settings
      };
    }
    exports.parseColor = parseColor;
    exports.getDefaultSettings = getDefaultSettings;
    exports.parseSettings = parseSettings;
  }
});

// node_modules/formsmd/src/translations.js
var require_translations = __commonJS({
  "node_modules/formsmd/src/translations.js"(exports) {
    "use strict";
    var translations = {
      en: {
        "choice-field-required": "Please select an item in the list.",
        "choose-many-text": "Choose as many as you like",
        "copy-btn": "Copy",
        "copy-btn-success": "Copied",
        "country-calling-code-label": "Country calling code",
        "date-input-error": "Please use the YYYY-MM-DD format.",
        "datetime-input-error": "Please use the YYYY-MM-DDTHH:mm format.",
        "end-slide-title": "Thank you",
        "end-slide-subtitle": "You've reached the end.",
        "file-input-change": "Change",
        "file-input-choose": '<strong class="fmd-text-accent">choose file</strong><span class="fmd-xs:d-none"> or drag here</span>',
        "file-input-clear-check": 'Clear<span class="fmd-visually-hidden"> current file</span>',
        "file-input-currently": "Currently",
        "file-input-reset-btn": "Remove chosen file",
        "file-input-size-error": "File exceeds the size limit.",
        "file-input-size-limit": "Size limit",
        "form-submit-btn": "OK",
        "form-submitted-title": "Thank you",
        "form-submitted-subtitle": "Your response has been recorded.",
        "list-check": "Not checked",
        "list-checked": "Checked",
        "loading": "Loading",
        "made-in-btn": 'Made in <strong class="fmd-antialiased">Forms.md</strong>',
        "made-in-loader": '<div class="fmd-specific-fs-14">Made in</div><div class="fmd-specific-fs-20 fmd-text-emphasis"><strong>Forms.md</strong></div>',
        "next-btn": "Next",
        "nps-label-end": "Extremely likely",
        "nps-label-start": "Not likely at all",
        "number-choice-field-required": "Please make a selection.",
        "number-input-placeholder": "Type a number here...",
        "page-progress": "Page progress (%)",
        "phone-number-label": "Phone number",
        "previous-btn": "Previous",
        "required": "required",
        "restart-btn": "Restart",
        "select-box-placeholder": "Select an option",
        "slide-error": "Error!",
        "star-plural": "stars",
        "star-singular": "star",
        "start-btn": "Start",
        "text-input-placeholder": "Type your answer here...",
        "textarea-new-line-text": "to add new line",
        "time-input-error": "Please use the HH:mm format.",
        "toggle-color-scheme-btn": "Toggle color scheme",
        "try-again-btn": "Try again"
      },
      ar: {
        "choice-field-required": "الرجاء اختيار عنصر من القائمة.",
        "choose-many-text": "اختر ما تريد",
        "copy-btn": "نسخ",
        "copy-btn-success": "تم النسخ",
        "country-calling-code-label": "رمز الاتصال الدولي",
        "date-input-error": "الرجاء استخدام التنسيق YYYY-MM-DD.",
        "datetime-input-error": "الرجاء استخدام التنسيق YYYY-MM-DDTHH:mm.",
        "end-slide-title": "شكراً",
        "end-slide-subtitle": "لقد وصلت إلى النهاية.",
        "file-input-change": "تغيير",
        "file-input-choose": '<strong class="fmd-text-accent">اختر ملفاً</strong><span class="fmd-xs:d-none"> أو اسحب إلى هنا</span>',
        "file-input-clear-check": 'مسح<span class="fmd-visually-hidden"> الملف الحالي</span>',
        "file-input-currently": "حالياً",
        "file-input-reset-btn": "إزالة الملف المختار",
        "file-input-size-error": "الملف يتجاوز الحد المسموح به للحجم.",
        "file-input-size-limit": "حد الحجم",
        "form-submit-btn": "موافق",
        "form-submitted-title": "شكراً",
        "form-submitted-subtitle": "تم تسجيل إجابتك.",
        "list-check": "غير محدد",
        "list-checked": "محدد",
        "loading": "جاري التحميل",
        "made-in-btn": 'صنع في <strong class="fmd-antialiased">Forms.md</strong>',
        "made-in-loader": '<div class="fmd-specific-fs-14">صنع في</div><div class="fmd-specific-fs-20 fmd-text-emphasis"><strong>Forms.md</strong></div>',
        "next-btn": "التالي",
        "nps-label-end": "محتمل جداً",
        "nps-label-start": "غير محتمل إطلاقاً",
        "number-choice-field-required": "الرجاء الاختيار.",
        "number-input-placeholder": "123",
        "page-progress": "تقدم الصفحة (%)",
        "phone-number-label": "رقم الهاتف",
        "previous-btn": "السابق",
        "required": "مطلوب",
        "restart-btn": "إعادة البدء",
        "select-box-placeholder": "اختر خياراً",
        "slide-error": "خطأ!",
        "star-plural": "نجوم",
        "star-singular": "نجمة",
        "start-btn": "ابدأ",
        "text-input-placeholder": "اكتب إجابتك هنا...",
        "textarea-new-line-text": "لإضافة سطر جديد",
        "time-input-error": "الرجاء استخدام التنسيق HH:mm.",
        "toggle-color-scheme-btn": "تبديل نظام الألوان",
        "try-again-btn": "حاول مرة أخرى"
      },
      bn: {
        "choice-field-required": "অনুগ্রহ করে একটি আইটেম নির্বাচন করুন।",
        "choose-many-text": "এক বা একাধিক নির্বাচন করুন",
        "copy-btn": "কপি",
        "copy-btn-success": "সম্পন্ন",
        "country-calling-code-label": "দেশের কলিং কোড",
        "date-input-error": "অনুগ্রহ করে YYYY-MM-DD ফর্ম্যাট ব্যবহার করুন।",
        "datetime-input-error": "অনুগ্রহ করে YYYY-MM-DDTHH:mm ফর্ম্যাট ব্যবহার করুন।",
        "end-slide-title": "ধন্যবাদ",
        "end-slide-subtitle": "আপনি শেষ পর্যন্ত পৌঁছেছেন।",
        "file-input-change": "পালটান",
        "file-input-choose": '<strong class="fmd-text-accent">ফাইল বেছে নিন</strong><span class="fmd-xs:d-none"> বা এখানে টেনে আনুন</span>',
        "file-input-clear-check": 'সাফ<span class="fmd-visually-hidden"> করুন বর্তমান ফাইল</span>',
        "file-input-currently": "বর্তমানে",
        "file-input-reset-btn": "নির্বাচিত ফাইল সরান",
        "file-input-size-error": "ফাইলের সাইজ সীমা ছাড়িয়ে গেছে।",
        "file-input-size-limit": "সাইজ লিমিট",
        "form-submit-btn": "ওকে",
        "form-submitted-title": "ধন্যবাদ",
        "form-submitted-subtitle": "আপনার জবাব রেকর্ড করা হয়েছে।",
        "list-check": "চিহ্নিত না",
        "list-checked": "চিহ্নিত",
        "loading": "লোড হচ্ছে",
        "made-in-btn": '<strong class="fmd-antialiased">Forms.md</strong> তে তৈরি',
        "made-in-loader": '<div class="fmd-specific-fs-20 fmd-text-emphasis"><strong>Forms.md</strong></div><div class="fmd-specific-fs-14">তে তৈরি</div>',
        "next-btn": "পরবর্তী",
        "nps-label-end": "অত্যন্ত সম্ভাবনাময়",
        "nps-label-start": "কোনো সম্ভাবনা নেই",
        "number-choice-field-required": "একটি নির্বাচন করুন।",
        "number-input-placeholder": "এখানে একটি সংখ্যা টাইপ করুন...",
        "page-progress": "পৃষ্ঠার অগ্রগতি (%)",
        "phone-number-label": "ফোন নম্বর",
        "previous-btn": "পূর্ববর্তী",
        "required": "প্রয়োজন",
        "restart-btn": "আবার শুরু",
        "select-box-placeholder": "যেকোনো একটি নির্বাচন করুন",
        "slide-error": "ভুল হয়েছে!",
        "star-plural": "স্টার",
        "star-singular": "স্টার",
        "start-btn": "শুরু",
        "text-input-placeholder": "এখানে আপনার উত্তর টাইপ করুন...",
        "textarea-new-line-text": "নতুন লাইন যোগ করতে",
        "time-input-error": "অনুগ্রহ করে HH:mm ফর্ম্যাট ব্যবহার করুন।",
        "toggle-color-scheme-btn": "রঙের স্কিম টগল করুন",
        "try-again-btn": "আবার চেষ্টা করুন"
      },
      de: {
        "choice-field-required": "Bitte wählen Sie einen Eintrag aus der Liste.",
        "choose-many-text": "Wählen Sie so viele wie Sie möchten",
        "copy-btn": "Kopieren",
        "copy-btn-success": "Kopiert",
        "country-calling-code-label": "Ländervorwahl",
        "date-input-error": "Bitte verwenden Sie das Format YYYY-MM-DD.",
        "datetime-input-error": "Bitte verwenden Sie das Format YYYY-MM-DDTHH:mm.",
        "end-slide-title": "Vielen Dank",
        "end-slide-subtitle": "Sie haben das Ende erreicht.",
        "file-input-change": "Ändern",
        "file-input-choose": '<strong class="fmd-text-accent">Datei auswählen</strong><span class="fmd-xs:d-none"> oder hierher ziehen</span>',
        "file-input-clear-check": 'Löschen<span class="fmd-visually-hidden"> aktuelle Datei</span>',
        "file-input-currently": "Aktuell",
        "file-input-reset-btn": "Ausgewählte Datei entfernen",
        "file-input-size-error": "Datei überschreitet das Größenlimit.",
        "file-input-size-limit": "Größenlimit",
        "form-submit-btn": "OK",
        "form-submitted-title": "Vielen Dank",
        "form-submitted-subtitle": "Ihre Antwort wurde gespeichert.",
        "list-check": "Nicht markiert",
        "list-checked": "Markiert",
        "loading": "Lädt",
        "made-in-btn": 'Erstellt mit <strong class="fmd-antialiased">Forms.md</strong>',
        "made-in-loader": '<div class="fmd-specific-fs-14">Erstellt mit</div><div class="fmd-specific-fs-20 fmd-text-emphasis"><strong>Forms.md</strong></div>',
        "next-btn": "Weiter",
        "nps-label-end": "Äußerst wahrscheinlich",
        "nps-label-start": "Überhaupt nicht wahrscheinlich",
        "number-choice-field-required": "Bitte treffen Sie eine Auswahl.",
        "number-input-placeholder": "Geben Sie hier eine Zahl ein...",
        "page-progress": "Seitenfortschritt (%)",
        "phone-number-label": "Telefonnummer",
        "previous-btn": "Zurück",
        "required": "erforderlich",
        "restart-btn": "Neustart",
        "select-box-placeholder": "Option auswählen",
        "slide-error": "Fehler!",
        "star-plural": "Sterne",
        "star-singular": "Stern",
        "start-btn": "Start",
        "text-input-placeholder": "Geben Sie hier Ihre Antwort ein...",
        "textarea-new-line-text": "um neue Zeile hinzuzufügen",
        "time-input-error": "Bitte verwenden Sie das Format HH:mm.",
        "toggle-color-scheme-btn": "Farbschema umschalten",
        "try-again-btn": "Erneut versuchen"
      },
      es: {
        "choice-field-required": "Por favor seleccione un artículo en la lista.",
        "choose-many-text": "Elige tantos como quieras",
        "copy-btn": "Copiar",
        "copy-btn-success": "Copiado",
        "country-calling-code-label": "Código de llamada del país",
        "date-input-error": "Utilice el formato YYYY-MM-DD.",
        "datetime-input-error": "Utilice el formato YYYY-MM-DDTHH:mm.",
        "end-slide-title": "Gracias",
        "end-slide-subtitle": "Has llegado al final.",
        "file-input-change": "Cambiar",
        "file-input-choose": '<strong class="fmd-text-accent">elige el archivo</strong><span class="fmd-xs:d-none"> o arrastra aquí</span>',
        "file-input-clear-check": 'Borrar<span class="fmd-visually-hidden"> el archivo actual</span>',
        "file-input-currently": "Actualmente",
        "file-input-reset-btn": "Eliminar el archivo elegido",
        "file-input-size-error": "El archivo excede el límite de tamaño.",
        "file-input-size-limit": "Límite de tamaño",
        "form-submit-btn": "OK",
        "form-submitted-title": "Gracias",
        "form-submitted-subtitle": "Su respuesta ha quedado registrada.",
        "list-check": "No comprobado",
        "list-checked": "Comprobado",
        "loading": "Cargando",
        "made-in-btn": 'Fabricado en <strong class="fmd-antialiased">Forms.md</strong>',
        "made-in-loader": '<div class="fmd-specific-fs-14">Fabricado en</div><div class="fmd-specific-fs-20 fmd-text-emphasis"><strong>Forms.md</strong></div>',
        "next-btn": "Siguiente",
        "nps-label-end": "Extremadamente probable",
        "nps-label-start": "Nada probable",
        "number-choice-field-required": "Por favor, haga una selección.",
        "number-input-placeholder": "Escriba un número aquí...",
        "page-progress": "Progreso de la página (%)",
        "phone-number-label": "Número de teléfono",
        "previous-btn": "Anterior",
        "required": "obligatorio",
        "restart-btn": "Reinicie",
        "select-box-placeholder": "Seleccione una opción",
        "slide-error": "¡Error!",
        "star-plural": "estrellas",
        "star-singular": "estrella",
        "start-btn": "Comenzar",
        "text-input-placeholder": "Escribe tu respuesta aquí...",
        "textarea-new-line-text": "para añadir una nueva línea",
        "time-input-error": "Utilice el formato HH:mm.",
        "toggle-color-scheme-btn": "Alternar esquema de colores",
        "try-again-btn": "Inténtalo de nuevo"
      },
      fr: {
        "choice-field-required": "Veuillez sélectionner un élément dans la liste.",
        "choose-many-text": "Choisissez autant que vous le souhaitez",
        "copy-btn": "Copier",
        "copy-btn-success": "Copié",
        "country-calling-code-label": "Indicatif téléphonique du pays",
        "date-input-error": "Veuillez utiliser le format YYYY-MM-DD.",
        "datetime-input-error": "Veuillez utiliser le format YYYY-MM-DDTHH:mm.",
        "end-slide-title": "Merci",
        "end-slide-subtitle": "Vous êtes arrivé à la fin.",
        "file-input-change": "Modifier",
        "file-input-choose": '<strong class="fmd-text-accent">choisir un fichier</strong><span class="fmd-xs:d-none"> ou déposer ici</span>',
        "file-input-clear-check": 'Effacer<span class="fmd-visually-hidden"> le fichier actuel</span>',
        "file-input-currently": "Actuellement",
        "file-input-reset-btn": "Supprimer le fichier choisi",
        "file-input-size-error": "Le fichier dépasse la limite de taille.",
        "file-input-size-limit": "Limite de taille",
        "form-submit-btn": "OK",
        "form-submitted-title": "Merci",
        "form-submitted-subtitle": "Votre réponse a été enregistrée.",
        "list-check": "Non coché",
        "list-checked": "Coché",
        "loading": "Chargement",
        "made-in-btn": 'Créé avec <strong class="fmd-antialiased">Forms.md</strong>',
        "made-in-loader": '<div class="fmd-specific-fs-14">Créé avec</div><div class="fmd-specific-fs-20 fmd-text-emphasis"><strong>Forms.md</strong></div>',
        "next-btn": "Suivant",
        "nps-label-end": "Extrêmement probable",
        "nps-label-start": "Pas du tout probable",
        "number-choice-field-required": "Veuillez faire une sélection.",
        "number-input-placeholder": "Tapez un nombre ici...",
        "page-progress": "Progression de la page (%)",
        "phone-number-label": "Numéro de téléphone",
        "previous-btn": "Précédent",
        "required": "requis",
        "restart-btn": "Recommencer",
        "select-box-placeholder": "Sélectionnez une option",
        "slide-error": "Erreur !",
        "star-plural": "étoiles",
        "star-singular": "étoile",
        "start-btn": "Commencer",
        "text-input-placeholder": "Tapez votre réponse ici...",
        "textarea-new-line-text": "pour ajouter une nouvelle ligne",
        "time-input-error": "Veuillez utiliser le format HH:mm.",
        "toggle-color-scheme-btn": "Changer le thème de couleurs",
        "try-again-btn": "Réessayer"
      },
      ja: {
        "choice-field-required": "リストからアイテムを選択してください。",
        "choose-many-text": "好きなだけ選択してください",
        "copy-btn": "コピー",
        "copy-btn-success": "コピーしました",
        "country-calling-code-label": "国番号",
        "date-input-error": "YYYY-MM-DD形式で入力してください。",
        "datetime-input-error": "YYYY-MM-DDTHH:mm形式で入力してください。",
        "end-slide-title": "ありがとうございます",
        "end-slide-subtitle": "最後まで読んでいただきました。",
        "file-input-change": "変更",
        "file-input-choose": '<strong class="fmd-text-accent">ファイルを選択</strong><span class="fmd-xs:d-none"> またはここにドラッグ</span>',
        "file-input-clear-check": 'クリア<span class="fmd-visually-hidden"> 現在のファイル</span>',
        "file-input-currently": "現在",
        "file-input-reset-btn": "選択したファイルを削除",
        "file-input-size-error": "ファイルサイズが制限を超えています。",
        "file-input-size-limit": "サイズ制限",
        "form-submit-btn": "オッケー",
        "form-submitted-title": "ありがとうございます",
        "form-submitted-subtitle": "回答を記録しました。",
        "list-check": "未チェック",
        "list-checked": "チェック済み",
        "loading": "読み込み中",
        "made-in-btn": '<strong class="fmd-antialiased">Forms.md</strong> で作成',
        "made-in-loader": '<div class="fmd-specific-fs-14">作成：</div><div class="fmd-specific-fs-20 fmd-text-emphasis"><strong>Forms.md</strong></div>',
        "next-btn": "次へ",
        "nps-label-end": "非常にそう思う",
        "nps-label-start": "全くそう思わない",
        "number-choice-field-required": "選択してください。",
        "number-input-placeholder": "ここに数字を入力してください...",
        "page-progress": "ページの進行状況 (%)",
        "phone-number-label": "電話番号",
        "previous-btn": "前へ",
        "required": "必須",
        "restart-btn": "最初から",
        "select-box-placeholder": "オプションを選択",
        "slide-error": "エラー！",
        "star-plural": "星",
        "star-singular": "星",
        "start-btn": "開始",
        "text-input-placeholder": "ここに回答を入力してください...",
        "textarea-new-line-text": "改行するには",
        "time-input-error": "HH:mm形式で入力してください。",
        "toggle-color-scheme-btn": "カラーテーマを切り替え",
        "try-again-btn": "やり直す"
      },
      pt: {
        "choice-field-required": "Por favor selecione um item na lista.",
        "choose-many-text": "Escolha quantos quiser",
        "copy-btn": "Copiar",
        "copy-btn-success": "Copiado",
        "country-calling-code-label": "Código de chamada do país",
        "date-input-error": "Por favor use o formato YYYY-MM-DD.",
        "datetime-input-error": "Por favor use o formato YYYY-MM-DDTHH:mm.",
        "end-slide-title": "Obrigado",
        "end-slide-subtitle": "Você chegou ao fim.",
        "file-input-change": "Alterar",
        "file-input-choose": '<strong class="fmd-text-accent">escolher arquivo</strong><span class="fmd-xs:d-none"> ou arraste aqui</span>',
        "file-input-clear-check": 'Limpar<span class="fmd-visually-hidden"> arquivo atual</span>',
        "file-input-currently": "Atualmente",
        "file-input-reset-btn": "Remover arquivo escolhido",
        "file-input-size-error": "O arquivo excede o limite de tamanho.",
        "file-input-size-limit": "Limite de tamanho",
        "form-submit-btn": "OK",
        "form-submitted-title": "Obrigado",
        "form-submitted-subtitle": "Sua resposta foi registrada.",
        "list-check": "Não marcado",
        "list-checked": "Marcado",
        "loading": "Carregando",
        "made-in-btn": 'Feito em <strong class="fmd-antialiased">Forms.md</strong>',
        "made-in-loader": '<div class="fmd-specific-fs-14">Feito em</div><div class="fmd-specific-fs-20 fmd-text-emphasis"><strong>Forms.md</strong></div>',
        "next-btn": "Próximo",
        "nps-label-end": "Extremamente provável",
        "nps-label-start": "Nada provável",
        "number-choice-field-required": "Por favor faça uma seleção.",
        "number-input-placeholder": "Digite um número aqui...",
        "page-progress": "Progresso da página (%)",
        "phone-number-label": "Número de telefone",
        "previous-btn": "Anterior",
        "required": "obrigatório",
        "restart-btn": "Reiniciar",
        "select-box-placeholder": "Selecione uma opção",
        "slide-error": "Erro!",
        "star-plural": "estrelas",
        "star-singular": "estrela",
        "start-btn": "Começar",
        "text-input-placeholder": "Digite sua resposta aqui...",
        "textarea-new-line-text": "para adicionar nova linha",
        "time-input-error": "Por favor use o formato HH:mm.",
        "toggle-color-scheme-btn": "Alternar esquema de cores",
        "try-again-btn": "Tentar novamente"
      },
      zh: {
        "choice-field-required": "请从列表中选择一项。",
        "choose-many-text": "可以选择多项",
        "copy-btn": "复制",
        "copy-btn-success": "已复制",
        "country-calling-code-label": "国家区号",
        "date-input-error": "请使用 YYYY-MM-DD 格式。",
        "datetime-input-error": "请使用 YYYY-MM-DDTHH:mm 格式。",
        "end-slide-title": "感谢",
        "end-slide-subtitle": "您已到达末尾。",
        "file-input-change": "更改",
        "file-input-choose": '<strong class="fmd-text-accent">选择文件</strong><span class="fmd-xs:d-none"> 或拖放至此</span>',
        "file-input-clear-check": '清除<span class="fmd-visually-hidden"> 当前文件</span>',
        "file-input-currently": "当前",
        "file-input-reset-btn": "移除所选文件",
        "file-input-size-error": "文件超出大小限制。",
        "file-input-size-limit": "大小限制",
        "form-submit-btn": "确定",
        "form-submitted-title": "感谢",
        "form-submitted-subtitle": "您的回复已记录。",
        "list-check": "未选中",
        "list-checked": "已选中",
        "loading": "加载中",
        "made-in-btn": '由 <strong class="fmd-antialiased">Forms.md</strong> 制作',
        "made-in-loader": '<div class="fmd-specific-fs-14">由</div><div class="fmd-specific-fs-20 fmd-text-emphasis"><strong>Forms.md</strong></div>',
        "next-btn": "下一步",
        "nps-label-end": "非常可能",
        "nps-label-start": "完全不可能",
        "number-choice-field-required": "请做出选择。",
        "number-input-placeholder": "在此输入数字...",
        "page-progress": "页面进度 (%)",
        "phone-number-label": "电话号码",
        "previous-btn": "上一步",
        "required": "必填",
        "restart-btn": "重新开始",
        "select-box-placeholder": "选择一个选项",
        "slide-error": "错误！",
        "star-plural": "星",
        "star-singular": "星",
        "start-btn": "开始",
        "text-input-placeholder": "在此输入您的答案...",
        "textarea-new-line-text": "添加新行",
        "time-input-error": "请使用 HH:mm 格式。",
        "toggle-color-scheme-btn": "切换配色方案",
        "try-again-btn": "重试"
      }
    };
    function getTranslation(localization, key) {
      if (translations[localization] === void 0) {
        localization = "en";
      }
      return translations[localization][key] || "";
    }
    exports.translations = translations;
    exports.getTranslation = getTranslation;
  }
});

// node_modules/formsmd/src/composer.js
var require_composer = __commonJS({
  "node_modules/formsmd/src/composer.js"(exports) {
    "use strict";
    var { placeholdersAndCallingCodes } = require_phone_numbers();
    var { getDefaultSettings } = require_settings_parse();
    var { translations } = require_translations();
    function composeSharedFieldParams(params, formDelimiter) {
      const sharedParams = [];
      sharedParams.push(`	${formDelimiter}question = ${params.question}`);
      if (params.description !== void 0) {
        sharedParams.push(`	${formDelimiter}description = ${params.description}`);
      }
      if (params.fieldSize === "sm") {
        sharedParams.push(`	${formDelimiter}fieldSize = ${params.fieldSize}`);
      }
      if (params.labelStyle === "classic") {
        sharedParams.push(`	${formDelimiter}labelStyle = ${params.labelStyle}`);
      }
      if (params.subfield !== void 0) {
        sharedParams.push(`	${formDelimiter}subfield`);
      }
      if (params.disabled !== void 0) {
        sharedParams.push(`	${formDelimiter}disabled`);
      }
      if (params.autofocus !== void 0) {
        sharedParams.push(`	${formDelimiter}autofocus`);
      }
      return sharedParams;
    }
    function composeAttrs(params) {
      const attrs = [];
      if (params.id !== void 0) {
        attrs.push(`#${params.id}`);
      }
      if (params.classNames !== void 0) {
        for (const className of params.classNames) {
          attrs.push(`.${className}`);
        }
      }
      if (params.attrs !== void 0) {
        for (const attr of params.attrs) {
          attrs.push(`${attr.name}="${attr.value}"`);
        }
      }
      return attrs;
    }
    function translate(localization, translations2) {
      if (translations2[localization] !== void 0) {
        return translations2[localization];
      } else {
        return Object.values(translations2)[0];
      }
    }
    var Composer = class {
      /**
       * The page or form settings.
       *
       * @typedef {Object} SettingsType
       * @property {"all-slides"} [autofocus] If set to `"all-slides"`, when a new slide becomes active (including the first slide on page load), the very first form field will be auto-focused.
       * @property {string} [accent] The primary color (must be HTML name, hex code, or RGB) used on buttons, form fields, etc. [Supports up to two values](https://formsmd.gitbook.io/docs/settings#different-values-for-light-mode-and-dark-mode).
       * @property {string} [accentForeground] The text color (must be HTML name, hex code, or RGB) used on `accent` background, for example, the text on buttons. [Supports up to two values](https://formsmd.gitbook.io/docs/settings#different-values-for-light-mode-and-dark-mode).
       * @property {string} [backdropOpacity] Sets an overlay of the `background-color` on top of the background image. [Supports up to two values](https://formsmd.gitbook.io/docs/settings#different-values-for-light-mode-and-dark-mode).
       * @property {string} [backgroundColor] The `background-color` of the page (must be HTML name, hex code, or RGB). [Supports up to two values](https://formsmd.gitbook.io/docs/settings#different-values-for-light-mode-and-dark-mode).
       * @property {string} [backgroundImage] The `background-image` of the page. [Supports up to two values](https://formsmd.gitbook.io/docs/settings#different-values-for-light-mode-and-dark-mode).
       * @property {string} [brand] An image of your logo added to the header of the page in the top-left corner (must be valid Markdown image). [Supports up to two values](https://formsmd.gitbook.io/docs/settings#different-values-for-light-mode-and-dark-mode).
       * @property {"center"|"end"|"stretch"} [buttonAlignment] Set the alignment of the slide CTA buttons.
       * @property {string} [color] The `color` of the text on the page (must be HTML name, hex code, or RGB). [Supports up to two values](https://formsmd.gitbook.io/docs/settings#different-values-for-light-mode-and-dark-mode).
       * @property {"light"|"dark"} [colorScheme] The default or initial color scheme of the page. Default is `"light"`.
       * @property {"domain-wide"|"isolate"} [colorSchemeScope] Determines how color scheme preference is saved and applied. Default is `"domain-wide"`.
       * @property {"show"} [colorSchemeToggle] If set to `"show"`, a toggle button will be available in the footer.
       * @property {string} [cssPrefix] Prefix added to all CSS classes. Default is `"fmd-"`.
       * @property {string} [cta] Adds a call to action link styled as a button on the header (must be valid Markdown link).
       * @property {"ltr"|"rtl"} [dir] The direction of the page's text. Default is `"ltr"`.
       * @property {string} [favicon] The favicon of the page.
       * @property {"sm"} [fieldSize] If set to `"sm"`, the size of form fields will be made smaller.
       * @property {string} [fontFamily] The `font-family` used on the page.
       * @property {string} [fontImportUrl] URL to import custom fonts (must be valid CSS for the `@import` property).
       * @property {"sm"|"lg"} [fontSize] Makes the `font-size` of everything on the page smaller or larger.
       * @property {string} [formDelimiter] Used to separate parameters when creating form fields. Default is `"|"`.
       * @property {"hide"|"show"} [formsmdBranding] Controls visibility of the Forms.md branding.
       * @property {"classic"} [formStyle] If set to `"classic"`, the form fields will have a classic appearance.
       * @property {"hide"|"show"} [footer] Controls visibility of the footer.
       * @property {"json"|"csv"|"tsv"} [getFormat] The format for reading data. Default is `"json"`. [Read docs](https://formsmd.gitbook.io/docs/set-and-read-data).
       * @property {string} [getObjectsName] Name used for objects when reading data. Default is `"objects"`. [Read docs](https://formsmd.gitbook.io/docs/set-and-read-data).
       * @property {string} [getUrl] URL for reading data. [Read docs](https://formsmd.gitbook.io/docs/set-and-read-data).
       * @property {"hide"|"show"|"align"} [header] Controls header visibility and alignment.
       * @property {"anchored"} [headings] If set to `"anchored"`, all headings will contain an anchor link.
       * @property {string} [id] Identifier for the page or form.
       * @property {"classic"} [labelStyle] If set to `"classic"`, the question and description of form fields will be made smaller.
       * @property {keyof typeof translations} [localization] Sets the language for automatic translation. Default is `"en"`.
       * @property {string} [metaAuthor] Sets the author metadata.
       * @property {string} [metaDescription] Sets the description metadata.
       * @property {string} [metaImage] Sets the Open Graph image.
       * @property {string} [metaKeywords] Sets the keywords metadata.
       * @property {string} [metaType] Sets the Open Graph type.
       * @property {string} [metaUrl] Sets the Open Graph URL.
       * @property {"form-slides"|"slides"|"single"} [page] Determines the layout of the page. Default is `"form-slides"`.
       * @property {"hide"|"show"|"decorative"} [pageProgress] Controls visibility and function of the page progress.
       * @property {"hide"|"show"} [placeholders] Controls visibility of input placeholders.
       * @property {string} [postSheetName] When sending responses directly to Google Sheets, this specifies which sheet to save responses to.
       * @property {string} [postUrl] URL to send form responses to using POST request.
       * @property {"show"} [restartButton] If set to `"show"`, the restart button will be visible.
       * @property {"none"|"pill"} [rounded] Controls rounding of buttons and UI elements.
       * @property {"hide"|"show"} [slideControls] Controls visibility of next and previous buttons.
       * @property {string} [slideDelimiter] Specifies where new slides are created. Default is `"---"`.
       * @property {string} [submitButtonText] Custom text for submit buttons.
       * @property {string} [title] The title of the page.
       * @property {"start"} [verticalAlignment] If set to `"start"`, content is aligned to the top of the page vertically.
       */
      /**
       * Create an instance of the class.
       *
       * @param {SettingsType} settings
       */
      constructor(settings) {
        __publicField(this, "template", "");
        __publicField(this, "settings", {});
        __publicField(this, "passedSettings", {});
        /**
         * HTML attribute.
         *
         * @typedef {Object} HTMLAttributeType
         * @property {string} name The name of the attribute.
         * @property {string} value The value of the attribute.
         */
        /**
         * Display condition.
         *
         * @typedef {Object} DisplayConditionType
         * @property {Array.<string>} dependencies The names of the form fields or data to use in the condition.
         * @property {string} condition The actual condition.
         */
        /**
         * Params shared between all form fields.
         *
         * @typedef {Object} FormFieldSharedParamsType
         * @property {string} question The main question of the form field.
         * @property {true} [required] When set, the field becomes required.
         * @property {string} [description] Any extra information that the user may need to fill out the form.
         * @property {"sm"} [fieldSize] When set to `"sm"`, the font sizes of the question, description, and answer are made smaller.
         * @property {"classic"} [labelStyle] When set to `"classic"`, the question and description of the form field are made smaller.
         * @property {true} [subfield] When set, the question and description of the form field are made smaller.
         * @property {true} [disabled] When set, the input is disabled.
         * @property {true} [autofocus] When set, the input will be automatically focused when the parent slide becomes active, or immediately after page load.
         * @property {string} [id] The id attribute of the form field.
         * @property {Array.<string>} [classNames] The CSS class names of the form field.
         * @property {Array.<HTMLAttributeType>} [attrs] Other HTML attributes of the form field.
         * @property {DisplayConditionType} [displayCondition] Display condition for the form field.
         */
        /**
         * Text input params.
         *
         * @typedef {Object} TextInputParamsType
         * @property {string} [placeholder] Sets the `placeholder` attribute of the input.
         * @property {true} [multiline] When set, the input accepts values with one or more lines because the `<textarea>` element is used.
         * @property {number} [maxlength] If set, this becomes the maximum number of allowed characters in the input.
         * @property {string} [pattern] If set, the input value must match the given pattern.
         * @property {string} [value] If set, this becomes the default value of the input.
         */
        /**
         * Create a text input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & TextInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "textInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = TextInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.placeholder !== void 0) {
            templateChunks.push(
              `	${formDelimiter}placeholder = ${params.placeholder}`
            );
          }
          if (params.multiline !== void 0) {
            templateChunks.push(`	${formDelimiter}multiline`);
          }
          if (params.maxlength !== void 0) {
            templateChunks.push(`	${formDelimiter}maxlength = ${params.maxlength}`);
          }
          if (params.pattern !== void 0) {
            templateChunks.push(`	${formDelimiter}pattern = ${params.pattern}`);
          }
          if (params.value !== void 0) {
            templateChunks.push(`	${formDelimiter}value = ${params.value}`);
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Email input params.
         *
         * @typedef {Object} EmailInputParamsType
         * @property {string} [placeholder] Sets the `placeholder` attribute of the input.
         * @property {number} [maxlength] If set, this becomes the maximum number of allowed characters in the input.
         * @property {string} [pattern] If set, the input value must match the given pattern.
         * @property {string} [value] If set, this becomes the default value of the input.
         */
        /**
         * Create an email input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & EmailInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "emailInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = EmailInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.placeholder !== void 0) {
            templateChunks.push(
              `	${formDelimiter}placeholder = ${params.placeholder}`
            );
          }
          if (params.maxlength !== void 0) {
            templateChunks.push(`	${formDelimiter}maxlength = ${params.maxlength}`);
          }
          if (params.pattern !== void 0) {
            templateChunks.push(`	${formDelimiter}pattern = ${params.pattern}`);
          }
          if (params.value !== void 0) {
            templateChunks.push(`	${formDelimiter}value = ${params.value}`);
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * URL input params.
         *
         * @typedef {Object} URLInputParamsType
         * @property {string} [placeholder] Sets the `placeholder` attribute of the input.
         * @property {number} [maxlength] If set, this becomes the maximum number of allowed characters in the input.
         * @property {string} [pattern] If set, the input value must match the given pattern.
         * @property {string} [value] If set, this becomes the default value of the input.
         */
        /**
         * Create a URL input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & URLInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "urlInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = URLInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.placeholder !== void 0) {
            templateChunks.push(
              `	${formDelimiter}placeholder = ${params.placeholder}`
            );
          }
          if (params.maxlength !== void 0) {
            templateChunks.push(`	${formDelimiter}maxlength = ${params.maxlength}`);
          }
          if (params.pattern !== void 0) {
            templateChunks.push(`	${formDelimiter}pattern = ${params.pattern}`);
          }
          if (params.value !== void 0) {
            templateChunks.push(`	${formDelimiter}value = ${params.value}`);
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Country code.
         *
         * @typedef {keyof typeof placeholdersAndCallingCodes} CountryCodeType
         */
        /**
         * Telephone input params.
         *
         * @typedef {Object} TelInputParamsType
         * @property {string} [placeholder] Sets the `placeholder` attribute of the input.
         * @property {number} [maxlength] If set, this becomes the maximum number of allowed characters in the input.
         * @property {string} [pattern] If set, the input value must match the given pattern.
         * @property {string} [value] If set, this becomes the default value of the input.
         * @property {CountryCodeType} [country] The default country code (e.g., `"US"`). Defaults to `"US"` if not specified.
         * @property {Array.<CountryCodeType>} [availableCountries] Array of available country codes (e.g., `["US", "CA", "GB"]`).
         */
        /**
         * Create a telephone input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & TelInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "telInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = TelInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.placeholder !== void 0) {
            templateChunks.push(
              `	${formDelimiter}placeholder = ${params.placeholder}`
            );
          }
          if (params.maxlength !== void 0) {
            templateChunks.push(`	${formDelimiter}maxlength = ${params.maxlength}`);
          }
          if (params.pattern !== void 0) {
            templateChunks.push(`	${formDelimiter}pattern = ${params.pattern}`);
          }
          if (params.value !== void 0) {
            templateChunks.push(`	${formDelimiter}value = ${params.value}`);
          }
          if (params.country !== void 0) {
            templateChunks.push(`	${formDelimiter}country = ${params.country}`);
          }
          if (params.availableCountries !== void 0) {
            templateChunks.push(
              `	${formDelimiter}availableCountries = ${params.availableCountries.join(", ")}`
            );
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Password input params.
         *
         * @typedef {Object} PasswordInputParamsType
         * @property {string} [placeholder] Sets the `placeholder` attribute of the input.
         * @property {number} [maxlength] If set, this becomes the maximum number of allowed characters in the input.
         * @property {string} [pattern] If set, the input value must match the given pattern.
         * @property {string} [value] If set, this becomes the default value of the input.
         */
        /**
         * Create a password input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & PasswordInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "passwordInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = PasswordInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.placeholder !== void 0) {
            templateChunks.push(
              `	${formDelimiter}placeholder = ${params.placeholder}`
            );
          }
          if (params.maxlength !== void 0) {
            templateChunks.push(`	${formDelimiter}maxlength = ${params.maxlength}`);
          }
          if (params.pattern !== void 0) {
            templateChunks.push(`	${formDelimiter}pattern = ${params.pattern}`);
          }
          if (params.value !== void 0) {
            templateChunks.push(`	${formDelimiter}value = ${params.value}`);
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Number input params.
         *
         * @typedef {Object} NumberInputParamsType
         * @property {string} [placeholder] Sets the `placeholder` attribute of the input.
         * @property {number} [min] Sets the minimum allowed value.
         * @property {number} [max] Sets the maximum allowed value.
         * @property {number} [step] Sets the stepping interval.
         * @property {string} [unit] Text to display before the input as a unit (e.g., `"$"`, `"€"`).
         * @property {string} [unitEnd] Text to display after the input as a unit (e.g., `"kg"`, `"%"`).
         * @property {number} [value] If set, this becomes the default value of the input.
         */
        /**
         * Create a number input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & NumberInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "numberInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = NumberInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.placeholder !== void 0) {
            templateChunks.push(
              `	${formDelimiter}placeholder = ${params.placeholder}`
            );
          }
          if (params.min !== void 0) {
            templateChunks.push(`	${formDelimiter}min = ${params.min}`);
          }
          if (params.max !== void 0) {
            templateChunks.push(`	${formDelimiter}max = ${params.max}`);
          }
          if (params.step !== void 0) {
            templateChunks.push(`	${formDelimiter}step = ${params.step}`);
          }
          if (params.unit !== void 0) {
            templateChunks.push(`	${formDelimiter}unit = ${params.unit}`);
          }
          if (params.unitEnd !== void 0) {
            templateChunks.push(`	${formDelimiter}unitend = ${params.unitEnd}`);
          }
          if (params.value !== void 0) {
            templateChunks.push(`	${formDelimiter}value = ${params.value}`);
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Select option.
         *
         * @typedef {Object} SelectOptionType
         * @property {string} label The display text for the option.
         * @property {string} [value] The value for the option. If not provided, label is used as value.
         */
        /**
         * Select box params.
         *
         * @typedef {Object} SelectBoxParamsType
         * @property {string} [placeholder] Sets the placeholder option of the select.
         * @property {Array<string|SelectOptionType>} options Array of options as strings or SelectOptionType objects.
         * @property {string} [selected] Pre-selected option value.
         */
        /**
         * Create a select box field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & SelectBoxParamsType} params
         * @returns {string}
         */
        __publicField(this, "selectBox", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = SelectBox(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.placeholder !== void 0) {
            templateChunks.push(
              `	${formDelimiter}placeholder = ${params.placeholder}`
            );
          }
          const optionsString = params.options.map((option) => {
            if (typeof option === "string") {
              return option;
            }
            if (option.value !== void 0) {
              return `"${option.value}" ${option.label}`;
            }
            return option.label;
          }).join(", ");
          templateChunks.push(`	${formDelimiter}options = ${optionsString}`);
          if (params.selected !== void 0) {
            templateChunks.push(`	${formDelimiter}selected = ${params.selected}`);
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Choice option.
         *
         * @typedef {Object} ChoiceOptionType
         * @property {string} label The display text for the choice.
         * @property {string} [value] The value for the choice. If not provided, label is used as value.
         */
        /**
         * Choice input params.
         *
         * @typedef {Object} ChoiceInputParamsType
         * @property {Array<string|ChoiceOptionType>} choices Array of choices as strings or ChoiceOptionType objects.
         * @property {true} [multiple] Allow multiple selections.
         * @property {true} [horizontal] Display choices horizontally.
         * @property {true} [hideFormText] Hide the form text.
         * @property {Array<string>} [checked] Array of pre-checked choice values.
         */
        /**
         * Create a choice input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & ChoiceInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "choiceInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = ChoiceInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          const choicesString = params.choices.map((choice) => {
            if (typeof choice === "string") {
              return choice;
            }
            if (choice.value !== void 0) {
              return `"${choice.value}" ${choice.label}`;
            }
            return choice.label;
          }).join(", ");
          templateChunks.push(`	${formDelimiter}choices = ${choicesString}`);
          if (params.multiple !== void 0) {
            templateChunks.push(`	${formDelimiter}multiple`);
          }
          if (params.horizontal !== void 0) {
            templateChunks.push(`	${formDelimiter}horizontal`);
          }
          if (params.hideFormText !== void 0) {
            templateChunks.push(`	${formDelimiter}hideformtext`);
          }
          if (params.checked !== void 0) {
            templateChunks.push(
              `	${formDelimiter}checked = ${params.checked.join(", ")}`
            );
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Picture choice option.
         *
         * @typedef {Object} PictureChoiceOptionType
         * @property {string} label The display text for the choice.
         * @property {string} [value] The value for the choice. If not provided, label is used as value.
         * @property {string} image The URL of the image.
         */
        /**
         * Picture choice params.
         *
         * @typedef {Object} PictureChoiceParamsType
         * @property {Array<PictureChoiceOptionType>} choices Array of picture choices.
         * @property {true} [multiple] Allow multiple selections.
         * @property {true} [supersize] Make the pictures larger.
         * @property {true} [hideLabels] Hide the text labels.
         * @property {true} [hideFormText] Hide the form text.
         * @property {Array<string>} [checked] Array of pre-checked choice values.
         */
        /**
         * Create a picture choice field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & PictureChoiceParamsType} params
         * @returns {string}
         */
        __publicField(this, "pictureChoice", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = PictureChoice(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          const choicesString = params.choices.map((choice) => {
            const baseChoice = choice.value !== void 0 ? `"${choice.value}" ${choice.label}` : choice.label;
            return `${baseChoice} && ${choice.image}`;
          }).join(", ");
          templateChunks.push(`	${formDelimiter}choices = ${choicesString}`);
          if (params.multiple !== void 0) {
            templateChunks.push(`	${formDelimiter}multiple`);
          }
          if (params.supersize !== void 0) {
            templateChunks.push(`	${formDelimiter}supersize`);
          }
          if (params.hideLabels !== void 0) {
            templateChunks.push(`	${formDelimiter}hidelabels`);
          }
          if (params.hideFormText !== void 0) {
            templateChunks.push(`	${formDelimiter}hideformtext`);
          }
          if (params.checked !== void 0) {
            templateChunks.push(
              `	${formDelimiter}checked = ${params.checked.join(", ")}`
            );
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Rating input params.
         *
         * @typedef {Object} RatingInputParamsType
         * @property {number} [outOf] Number of rating options (1-10). Defaults to `5`.
         * @property {"star"|"heart"|"hearts"} [icon] Icon to use for rating. Defaults to `"star"`.
         * @property {number} [value] Pre-selected rating value.
         * @property {true} [hideLabels] Whether to hide the numeric labels.
         */
        /**
         * Create a rating input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & RatingInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "ratingInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = RatingInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.outOf !== void 0) {
            templateChunks.push(`	${formDelimiter}outof = ${params.outOf}`);
          }
          if (params.icon !== void 0) {
            templateChunks.push(`	${formDelimiter}icon = ${params.icon}`);
          }
          if (params.value !== void 0) {
            templateChunks.push(`	${formDelimiter}value = ${params.value}`);
          }
          if (params.hideLabels !== void 0) {
            templateChunks.push(`	${formDelimiter}hidelabels`);
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Opinion scale input params.
         *
         * @typedef {Object} OpinionScaleParamsType
         * @property {number} [startAt] Starting number (`0` or `1`). Defaults to `0`.
         * @property {number} [outOf] Maximum scale value (5-10). Defaults to `10`.
         * @property {string} [labelStart] Label for the start of the scale.
         * @property {string} [labelEnd] Label for the end of the scale.
         * @property {true} [hideLabelStart] Whether to hide the start label.
         * @property {true} [hideLabelEnd] Whether to hide the end label.
         * @property {number} [value] Pre-selected value.
         */
        /**
         * Create an opinion scale field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & OpinionScaleParamsType} params
         * @returns {string}
         */
        __publicField(this, "opinionScale", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = OpinionScale(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.startAt !== void 0) {
            templateChunks.push(`	${formDelimiter}startat = ${params.startAt}`);
          }
          if (params.outOf !== void 0) {
            templateChunks.push(`	${formDelimiter}outof = ${params.outOf}`);
          }
          if (params.labelStart !== void 0) {
            templateChunks.push(
              `	${formDelimiter}labelstart = ${params.labelStart}`
            );
          }
          if (params.labelEnd !== void 0) {
            templateChunks.push(`	${formDelimiter}labelend = ${params.labelEnd}`);
          }
          if (params.hideLabelStart !== void 0) {
            templateChunks.push(`	${formDelimiter}hidelabelstart`);
          }
          if (params.hideLabelEnd !== void 0) {
            templateChunks.push(`	${formDelimiter}hidelabelend`);
          }
          if (params.value !== void 0) {
            templateChunks.push(`	${formDelimiter}value = ${params.value}`);
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Datetime input params.
         *
         * @typedef {Object} DatetimeInputParamsType
         * @property {string} [placeholder] Sets the `placeholder` attribute of the input.
         * @property {string} [min] Sets the minimum allowed datetime value (`"YYYY-MM-DDTHH:mm"`).
         * @property {string} [max] Sets the maximum allowed datetime value (`"YYYY-MM-DDTHH:mm"`).
         * @property {string} [step] Sets the stepping interval.
         * @property {string} [value] Pre-selected datetime value (`"YYYY-MM-DDTHH:mm"`).
         */
        /**
         * Create a datetime input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & DatetimeInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "datetimeInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = DatetimeInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.placeholder !== void 0) {
            templateChunks.push(
              `	${formDelimiter}placeholder = ${params.placeholder}`
            );
          }
          if (params.min !== void 0) {
            templateChunks.push(`	${formDelimiter}min = ${params.min}`);
          }
          if (params.max !== void 0) {
            templateChunks.push(`	${formDelimiter}max = ${params.max}`);
          }
          if (params.step !== void 0) {
            templateChunks.push(`	${formDelimiter}step = ${params.step}`);
          }
          if (params.value !== void 0) {
            templateChunks.push(`	${formDelimiter}value = ${params.value}`);
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Date input params.
         *
         * @typedef {Object} DateInputParamsType
         * @property {string} [placeholder] Sets the `placeholder` attribute of the input.
         * @property {string} [min] Sets the minimum allowed date value (`"YYYY-MM-DD"`).
         * @property {string} [max] Sets the maximum allowed date value (`"YYYY-MM-DD"`).
         * @property {string} [step] Sets the stepping interval.
         * @property {string} [value] Pre-selected date value (`"YYYY-MM-DD"`).
         */
        /**
         * Create a date input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & DateInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "dateInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = DateInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.placeholder !== void 0) {
            templateChunks.push(
              `	${formDelimiter}placeholder = ${params.placeholder}`
            );
          }
          if (params.min !== void 0) {
            templateChunks.push(`	${formDelimiter}min = ${params.min}`);
          }
          if (params.max !== void 0) {
            templateChunks.push(`	${formDelimiter}max = ${params.max}`);
          }
          if (params.step !== void 0) {
            templateChunks.push(`	${formDelimiter}step = ${params.step}`);
          }
          if (params.value !== void 0) {
            templateChunks.push(`	${formDelimiter}value = ${params.value}`);
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Time input params.
         *
         * @typedef {Object} TimeInputParamsType
         * @property {string} [placeholder] Sets the `placeholder` attribute of the input.
         * @property {string} [min] Sets the minimum allowed time value (`"HH:mm"`).
         * @property {string} [max] Sets the maximum allowed time value (`"HH:mm"`).
         * @property {string} [step] Sets the stepping interval.
         * @property {string} [value] Pre-selected time value (`"HH:mm"`).
         */
        /**
         * Create a time input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & TimeInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "timeInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = TimeInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.placeholder !== void 0) {
            templateChunks.push(
              `	${formDelimiter}placeholder = ${params.placeholder}`
            );
          }
          if (params.min !== void 0) {
            templateChunks.push(`	${formDelimiter}min = ${params.min}`);
          }
          if (params.max !== void 0) {
            templateChunks.push(`	${formDelimiter}max = ${params.max}`);
          }
          if (params.step !== void 0) {
            templateChunks.push(`	${formDelimiter}step = ${params.step}`);
          }
          if (params.value !== void 0) {
            templateChunks.push(`	${formDelimiter}value = ${params.value}`);
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * File input params.
         *
         * @typedef {Object} FileInputParamsType
         * @property {number} [sizeLimit] Maximum file size in MB. Defaults to `10`.
         * @property {true} [imageOnly] When set, only image files are accepted.
         * @property {string} [currentFile] The current file that exists in the database. Use a URL for best results, for example, https://example.s3.com/image.png.
         */
        /**
         * Create a file input field.
         *
         * @param {string} name
         * @param {FormFieldSharedParamsType & FileInputParamsType} params
         * @returns {string}
         */
        __publicField(this, "fileInput", (name, params) => {
          const instance = this;
          const formDelimiter = instance.settings.formDelimiter !== "\n" ? `${instance.settings.formDelimiter} ` : "";
          const templateChunks = [
            `${name}${params.required ? "*" : ""} = FileInput(`
          ].concat(composeSharedFieldParams(params, formDelimiter));
          if (params.sizeLimit !== void 0) {
            templateChunks.push(`	${formDelimiter}sizelimit = ${params.sizeLimit}`);
          }
          if (params.imageOnly !== void 0) {
            templateChunks.push(`	${formDelimiter}imageonly`);
          }
          if (params.currentFile !== void 0) {
            templateChunks.push(
              `	${formDelimiter}currentfile = ${params.currentFile}`
            );
          }
          templateChunks.push(")");
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.unshift(`[${attrs.join(" ")}]`);
          }
          if (params.displayCondition !== void 0) {
            templateChunks.unshift(`{% if ${params.displayCondition.condition} %}`);
            templateChunks.unshift(
              `::: [{$ ${params.displayCondition.dependencies.join(" ")} $}]`
            );
            templateChunks.push("{% endif %}");
            templateChunks.push(":::");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Slide params.
         *
         * @typedef {Object} SlideParamsType
         * @property {string} [jumpCondition] Logic jump condition that must be `true` for slide to be shown.
         * @property {string} [pageProgress] Progress indicator shown on top (e.g. `"50%"` or `"1/2"`).
         * @property {"start"|"center"|"end"|"stretch"} [buttonAlignment] Set the alignment of this slide's CTA button.
         * @property {true} [post] If set, posts form data up to this slide when going to the next one.
         * @property {true} [disablePrevious] If set, disables the previous button.
         */
        /**
         * Create a slide.
         *
         * @param {SlideParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "slide", (params) => {
          var instance = this;
          if (!params) {
            params = {};
          }
          var templateChunks = [];
          if (instance.template.split("\n").filter((line) => !line.trim().startsWith("#!")).join("\n").trim() !== "") {
            templateChunks.push(instance.settings.slideDelimiter);
          }
          if (params.jumpCondition !== void 0) {
            templateChunks.push(`-> ${params.jumpCondition}`);
          }
          if (params.pageProgress !== void 0) {
            templateChunks.push(`|> ${params.pageProgress}`);
          }
          if (params.buttonAlignment !== void 0) {
            templateChunks.push(`=| ${params.buttonAlignment}`);
          }
          if (params.post !== void 0) {
            templateChunks.push(">> post");
          }
          if (params.disablePrevious !== void 0) {
            templateChunks.push("<< disable");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Start slide params.
         *
         * @typedef {Object} StartSlideParamsType
         * @property {string} [buttonText] Custom text for the start button.
         * @property {"start"|"center"|"end"|"stretch"} [buttonAlignment] Set the alignment of this slide's CTA button.
         */
        /**
         * Create a start slide.
         *
         * @param {StartSlideParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "startSlide", (params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const templateChunks = [];
          if (instance.template.split("\n").filter((line) => !line.trim().startsWith("#!")).join("\n").trim() !== "") {
            templateChunks.push(instance.settings.slideDelimiter);
          }
          if (params.buttonText !== void 0) {
            templateChunks.push(`-> start -> ${params.buttonText}`);
          } else {
            templateChunks.push("-> start");
          }
          if (params.buttonAlignment !== void 0) {
            templateChunks.push(`=| ${params.buttonAlignment}`);
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * End slide params.
         *
         * @typedef {Object} EndSlideParamsType
         * @property {string} [redirectUrl] URL to redirect to from the end slide.
         */
        /**
         * Create an end slide.
         *
         * @param {EndSlideParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "endSlide", (params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const templateChunks = [];
          if (instance.template.split("\n").filter((line) => !line.trim().startsWith("#!")).join("\n").trim() !== "") {
            templateChunks.push(instance.settings.slideDelimiter);
          }
          if (params.redirectUrl !== void 0) {
            templateChunks.push(`-> end -> ${params.redirectUrl}`);
          } else {
            templateChunks.push("-> end");
          }
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Create a data-block.
         *
         * @param {Object} data
         * @returns {string}
         */
        __publicField(this, "dataBlock", (data) => {
          const instance = this;
          const result = `
\`\`\`data
${JSON.stringify(data, null, 2)}
\`\`\`
`;
          instance.template += result;
          return result;
        });
        /**
         * Create free-form content.
         *
         * @param {string} content
         * @returns {string}
         */
        __publicField(this, "free", (content) => {
          const instance = this;
          const result = `
${content}
`;
          instance.template += result;
          return result;
        });
        /**
         * Block-level element params.
         *
         * @typedef {Object} BlockElemParamsType
         * @property {string} [id] The id attribute of the element.
         * @property {Array.<string>} [classNames] The CSS class names of the element.
         * @property {Array.<HTMLAttributeType>} [attrs] Other HTML attributes of the element.
         */
        /**
         * Create a paragraph.
         *
         * @param {string} content
         * @param {BlockElemParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "p", (content, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const attrs = composeAttrs(params);
          let result = "";
          if (attrs.length > 0) {
            result = `
[${attrs.join(" ")}]
${content}
`;
          } else {
            result = `
${content}
`;
          }
          instance.template += result;
          return result;
        });
        /**
         * Create a heading 1.
         *
         * @param {string} content
         * @param {BlockElemParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "h1", (content, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const attrs = composeAttrs(params);
          let result = "";
          if (attrs.length > 0) {
            result = `
# [${attrs.join(" ")}] ${content}
`;
          } else {
            result = `
# ${content}
`;
          }
          instance.template += result;
          return result;
        });
        /**
         * Create a heading 2.
         *
         * @param {string} content
         * @param {BlockElemParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "h2", (content, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const attrs = composeAttrs(params);
          let result = "";
          if (attrs.length > 0) {
            result = `
## [${attrs.join(" ")}] ${content}
`;
          } else {
            result = `
## ${content}
`;
          }
          instance.template += result;
          return result;
        });
        /**
         * Create a heading 3.
         *
         * @param {string} content
         * @param {BlockElemParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "h3", (content, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const attrs = composeAttrs(params);
          let result = "";
          if (attrs.length > 0) {
            result = `
### [${attrs.join(" ")}] ${content}
`;
          } else {
            result = `
### ${content}
`;
          }
          instance.template += result;
          return result;
        });
        /**
         * Create a heading 4.
         *
         * @param {string} content
         * @param {BlockElemParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "h4", (content, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const attrs = composeAttrs(params);
          let result = "";
          if (attrs.length > 0) {
            result = `
#### [${attrs.join(" ")}] ${content}
`;
          } else {
            result = `
#### ${content}
`;
          }
          instance.template += result;
          return result;
        });
        /**
         * Create a heading 5.
         *
         * @param {string} content
         * @param {BlockElemParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "h5", (content, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const attrs = composeAttrs(params);
          let result = "";
          if (attrs.length > 0) {
            result = `
##### [${attrs.join(" ")}] ${content}
`;
          } else {
            result = `
##### ${content}
`;
          }
          instance.template += result;
          return result;
        });
        /**
         * Create a heading 6.
         *
         * @param {string} content
         * @param {BlockElemParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "h6", (content, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const attrs = composeAttrs(params);
          let result = "";
          if (attrs.length > 0) {
            result = `
###### [${attrs.join(" ")}] ${content}
`;
          } else {
            result = `
###### ${content}
`;
          }
          instance.template += result;
          return result;
        });
        /**
         * Create an unordered list.
         *
         * @param {Array.<string>} items
         * @param {BlockElemParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "ul", (items, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const templateChunks = [];
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.push(`- [${attrs.join(" ")}]`);
          }
          items.forEach((item) => {
            templateChunks.push(`- ${item}`);
          });
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Create an ordered list.
         *
         * @param {Array.<string>} items
         * @param {BlockElemParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "ol", (items, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const templateChunks = [];
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.push(`0. [${attrs.join(" ")}]`);
          }
          items.forEach((item, index) => {
            templateChunks.push(`${index + 1}. ${item}`);
          });
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Create a blockquote.
         *
         * @param {string} content
         * @param {BlockElemParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "blockquote", (content, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const templateChunks = [];
          const attrs = composeAttrs(params);
          if (attrs.length > 0) {
            templateChunks.push(`> [${attrs.join(" ")}]`);
          }
          const lines = content.split("\n");
          lines.forEach((line) => {
            templateChunks.push(`> ${line}`);
          });
          const result = `
${templateChunks.join("\n")}
`;
          instance.template += result;
          return result;
        });
        /**
         * Code params.
         *
         * @typedef {Object} CodeParamsType
         * @property {string} [language] The language of the code.
         */
        /**
         * Create a block-level code element.
         *
         * @param {string} content
         * @param {BlockElemParamsType & CodeParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "code", (content, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          const attrs = composeAttrs(params);
          let result = "";
          if (attrs.length > 0) {
            const language = params.language || "";
            result = `
\`\`\`${language} [${attrs.join(" ")}]
${content}
\`\`\`
`;
          } else {
            const language = params.language || "";
            result = `
\`\`\`${language}
${content}
\`\`\`
`;
          }
          instance.template += result;
          return result;
        });
        /**
         * Create a horizontal rule.
         *
         * @returns {string}
         */
        __publicField(this, "hr", () => {
          const instance = this;
          let result = "";
          if (instance.settings.slideDelimiter === "---") {
            result = "\n***\n";
          } else {
            result = "\n---\n";
          }
          instance.template += result;
          return result;
        });
        /**
         * Division params.
         *
         * @typedef {Object} DivParamsType
         * @property {Array.<string>} [bind] The data to bind to the division, e.g., `["name", "email", "birthday"]`.
         */
        /**
         * Create a division start tag.
         *
         * @param {BlockElemParamsType & DivParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "divStart", (params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          if (!params.bind) {
            params.bind = [];
          }
          const attrs = composeAttrs(params);
          let result = "";
          if (attrs.length > 0 || params.bind.length > 0) {
            const attrPart = attrs.length > 0 ? attrs.join(" ") : "";
            const bindPart = params.bind.length > 0 ? `{$ ${params.bind.join(" ")} $}` : "";
            if (attrPart && bindPart) {
              result = `
::: [${attrPart} ${bindPart}]
`;
            } else if (attrPart) {
              result = `
::: [${attrPart}]
`;
            } else if (bindPart) {
              result = `
::: [${bindPart}]
`;
            }
          } else {
            result = "\n:::\n";
          }
          instance.template += result;
          return result;
        });
        /**
         * Create a division end tag.
         *
         * @returns {string}
         */
        __publicField(this, "divEnd", () => {
          const instance = this;
          const result = "\n:::\n";
          instance.template += result;
          return result;
        });
        /**
         * Create a division.
         *
         * @param {string} content
         * @param {BlockElemParamsType & DivParamsType} [params]
         * @returns {string}
         */
        __publicField(this, "div", (content, params) => {
          const instance = this;
          if (!params) {
            params = {};
          }
          if (!params.bind) {
            params.bind = [];
          }
          const attrs = composeAttrs(params);
          let result = "";
          if (attrs.length > 0 || params.bind.length > 0) {
            const attrPart = attrs.length > 0 ? attrs.join(" ") : "";
            const bindPart = params.bind.length > 0 ? `{$ ${params.bind.join(" ")} $}` : "";
            if (attrPart && bindPart) {
              result = `
::: [${attrPart} ${bindPart}]
`;
            } else if (attrPart) {
              result = `
::: [${attrPart}]
`;
            } else if (bindPart) {
              result = `
::: [${bindPart}]
`;
            }
          } else {
            result = "\n:::\n";
          }
          result += content;
          result += "\n:::\n";
          instance.template += result;
          return result;
        });
        const defaultSettings = getDefaultSettings();
        for (const [name, value] of Object.entries(defaultSettings)) {
          this.settings[name.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase())] = value;
        }
        this.settings = {
          ...this.settings,
          ...settings
        };
        this.passedSettings = {
          ...settings
        };
        const templateChunks = [];
        for (const [name, value] of Object.entries(this.passedSettings)) {
          templateChunks.push(
            `#! ${name.replace(/([A-Z])/g, "-$1").toLowerCase()} = ${value}`
          );
        }
        const result = `
${templateChunks.join("\n")}
`;
        this.template += result;
        return result;
      }
    };
    exports.composeSharedFieldParams = composeSharedFieldParams;
    exports.composeAttrs = composeAttrs;
    exports.translate = translate;
    exports.Composer = Composer;
  }
});

// node_modules/formsmd/src/data-blocks-parse.js
var require_data_blocks_parse = __commonJS({
  "node_modules/formsmd/src/data-blocks-parse.js"(exports) {
    "use strict";
    function parseDataBlocks(template) {
      const data = [];
      let dataBlockCount = 1;
      function parseDataBlock(match, content) {
        content = content.trim();
        try {
          data.push(JSON.parse(content));
        } catch {
          console.warn(
            `[DATA] Data-block #${dataBlockCount.toString()} ignored because of invalid JSON`
          );
        }
        dataBlockCount += 1;
        return "";
      }
      template = template.replace(/```\s*data\s*(.*?)\s*```/gis, parseDataBlock);
      template = template.replace(/~~~\s*data\s*(.*?)\s*~~~/gis, parseDataBlock);
      return {
        template,
        data: data.reduce((acc, obj) => Object.assign(acc, obj), {})
        // Combine
      };
    }
    exports.parseDataBlocks = parseDataBlocks;
  }
});

// node_modules/formsmd/src/attrs-parse.js
var require_attrs_parse = __commonJS({
  "node_modules/formsmd/src/attrs-parse.js"(exports) {
    "use strict";
    var { unescape } = require_helpers();
    function parseElemAttrs(attrs, cssPrefix) {
      attrs = unescape(attrs.replace(/\s\s+/g, " "));
      let splitAttrs = [];
      let insideSingleQuotes = false;
      let insideDoubleQuotes = false;
      let currentWord = "";
      for (let i = 0; i < attrs.length; i++) {
        const char = attrs[i];
        if (char === "'" && !insideDoubleQuotes) {
          insideSingleQuotes = !insideSingleQuotes;
          currentWord += char;
        } else if (char === '"' && !insideSingleQuotes) {
          insideDoubleQuotes = !insideDoubleQuotes;
          currentWord += char;
        } else if (char === " " && !insideSingleQuotes && !insideDoubleQuotes) {
          if (currentWord !== "") {
            splitAttrs.push(currentWord);
            currentWord = "";
          }
        } else {
          currentWord += char;
        }
      }
      if (currentWord !== "") {
        splitAttrs.push(currentWord);
      }
      let id = "";
      const classNames = [];
      const otherAttrs = [];
      const parsedAttrs = [];
      for (let attr of splitAttrs) {
        attr = attr.trim();
        if (attr.startsWith("#")) {
          id = attr.substring(1);
        } else if (attr.startsWith(".")) {
          classNames.push(`${cssPrefix}${attr.substring(1)}`);
        } else {
          otherAttrs.push(attr.replace(/'/g, '"'));
        }
      }
      if (id) {
        parsedAttrs.push(`id="${id}"`);
      }
      if (classNames.length > 0) {
        parsedAttrs.push(`class="${classNames.join(" ")}"`);
      }
      if (otherAttrs.length > 0) {
        parsedAttrs.push(otherAttrs.join(" "));
      }
      return parsedAttrs.join(" ");
    }
    function addReservedClass(tag, name) {
      name = name.trim();
      if (!name) {
        return tag;
      }
      const classRegex = /class="([^"]*)"/;
      const containsClass = tag.match(classRegex);
      if (containsClass) {
        const classes = containsClass[1].split(" ");
        if (!classes.includes(name)) {
          classes.push(name);
        }
        return tag.replace(classRegex, `class="${classes.join(" ")}"`);
      } else {
        return tag.replace(/<([^\s>]+)/, `<$1 class="${name}"`);
      }
    }
    exports.parseElemAttrs = parseElemAttrs;
    exports.addReservedClass = addReservedClass;
  }
});

// node_modules/nunjucks/browser/nunjucks.js
var require_nunjucks = __commonJS({
  "node_modules/nunjucks/browser/nunjucks.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["nunjucks"] = factory();
      else
        root["nunjucks"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 11);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var ArrayProto = Array.prototype;
            var ObjProto = Object.prototype;
            var escapeMap = {
              "&": "&amp;",
              '"': "&quot;",
              "'": "&#39;",
              "<": "&lt;",
              ">": "&gt;",
              "\\": "&#92;"
            };
            var escapeRegex = /[&"'<>\\]/g;
            var exports2 = module2.exports = {};
            function hasOwnProp(obj, k) {
              return ObjProto.hasOwnProperty.call(obj, k);
            }
            exports2.hasOwnProp = hasOwnProp;
            function lookupEscape(ch) {
              return escapeMap[ch];
            }
            function _prettifyError(path, withInternals, err) {
              if (!err.Update) {
                err = new exports2.TemplateError(err);
              }
              err.Update(path);
              if (!withInternals) {
                var old = err;
                err = new Error(old.message);
                err.name = old.name;
              }
              return err;
            }
            exports2._prettifyError = _prettifyError;
            function TemplateError(message, lineno, colno) {
              var err;
              var cause;
              if (message instanceof Error) {
                cause = message;
                message = cause.name + ": " + cause.message;
              }
              if (Object.setPrototypeOf) {
                err = new Error(message);
                Object.setPrototypeOf(err, TemplateError.prototype);
              } else {
                err = this;
                Object.defineProperty(err, "message", {
                  enumerable: false,
                  writable: true,
                  value: message
                });
              }
              Object.defineProperty(err, "name", {
                value: "Template render error"
              });
              if (Error.captureStackTrace) {
                Error.captureStackTrace(err, this.constructor);
              }
              var getStack;
              if (cause) {
                var stackDescriptor = Object.getOwnPropertyDescriptor(cause, "stack");
                getStack = stackDescriptor && (stackDescriptor.get || function() {
                  return stackDescriptor.value;
                });
                if (!getStack) {
                  getStack = function getStack2() {
                    return cause.stack;
                  };
                }
              } else {
                var stack = new Error(message).stack;
                getStack = function getStack2() {
                  return stack;
                };
              }
              Object.defineProperty(err, "stack", {
                get: function get() {
                  return getStack.call(err);
                }
              });
              Object.defineProperty(err, "cause", {
                value: cause
              });
              err.lineno = lineno;
              err.colno = colno;
              err.firstUpdate = true;
              err.Update = function Update(path) {
                var msg = "(" + (path || "unknown path") + ")";
                if (this.firstUpdate) {
                  if (this.lineno && this.colno) {
                    msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
                  } else if (this.lineno) {
                    msg += " [Line " + this.lineno + "]";
                  }
                }
                msg += "\n ";
                if (this.firstUpdate) {
                  msg += " ";
                }
                this.message = msg + (this.message || "");
                this.firstUpdate = false;
                return this;
              };
              return err;
            }
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
            } else {
              TemplateError.prototype = Object.create(Error.prototype, {
                constructor: {
                  value: TemplateError
                }
              });
            }
            exports2.TemplateError = TemplateError;
            function escape(val) {
              return val.replace(escapeRegex, lookupEscape);
            }
            exports2.escape = escape;
            function isFunction(obj) {
              return ObjProto.toString.call(obj) === "[object Function]";
            }
            exports2.isFunction = isFunction;
            function isArray(obj) {
              return ObjProto.toString.call(obj) === "[object Array]";
            }
            exports2.isArray = isArray;
            function isString(obj) {
              return ObjProto.toString.call(obj) === "[object String]";
            }
            exports2.isString = isString;
            function isObject(obj) {
              return ObjProto.toString.call(obj) === "[object Object]";
            }
            exports2.isObject = isObject;
            function _prepareAttributeParts(attr) {
              if (!attr) {
                return [];
              }
              if (typeof attr === "string") {
                return attr.split(".");
              }
              return [attr];
            }
            function getAttrGetter(attribute) {
              var parts = _prepareAttributeParts(attribute);
              return function attrGetter(item) {
                var _item = item;
                for (var i = 0; i < parts.length; i++) {
                  var part = parts[i];
                  if (hasOwnProp(_item, part)) {
                    _item = _item[part];
                  } else {
                    return void 0;
                  }
                }
                return _item;
              };
            }
            exports2.getAttrGetter = getAttrGetter;
            function groupBy(obj, val, throwOnUndefined) {
              var result = {};
              var iterator = isFunction(val) ? val : getAttrGetter(val);
              for (var i = 0; i < obj.length; i++) {
                var value = obj[i];
                var key = iterator(value, i);
                if (key === void 0 && throwOnUndefined === true) {
                  throw new TypeError('groupby: attribute "' + val + '" resolved to undefined');
                }
                (result[key] || (result[key] = [])).push(value);
              }
              return result;
            }
            exports2.groupBy = groupBy;
            function toArray(obj) {
              return Array.prototype.slice.call(obj);
            }
            exports2.toArray = toArray;
            function without(array) {
              var result = [];
              if (!array) {
                return result;
              }
              var length = array.length;
              var contains = toArray(arguments).slice(1);
              var index = -1;
              while (++index < length) {
                if (indexOf(contains, array[index]) === -1) {
                  result.push(array[index]);
                }
              }
              return result;
            }
            exports2.without = without;
            function repeat(char_, n) {
              var str = "";
              for (var i = 0; i < n; i++) {
                str += char_;
              }
              return str;
            }
            exports2.repeat = repeat;
            function each(obj, func, context) {
              if (obj == null) {
                return;
              }
              if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
                obj.forEach(func, context);
              } else if (obj.length === +obj.length) {
                for (var i = 0, l = obj.length; i < l; i++) {
                  func.call(context, obj[i], i, obj);
                }
              }
            }
            exports2.each = each;
            function map(obj, func) {
              var results = [];
              if (obj == null) {
                return results;
              }
              if (ArrayProto.map && obj.map === ArrayProto.map) {
                return obj.map(func);
              }
              for (var i = 0; i < obj.length; i++) {
                results[results.length] = func(obj[i], i);
              }
              if (obj.length === +obj.length) {
                results.length = obj.length;
              }
              return results;
            }
            exports2.map = map;
            function asyncIter(arr, iter, cb) {
              var i = -1;
              function next() {
                i++;
                if (i < arr.length) {
                  iter(arr[i], i, next, cb);
                } else {
                  cb();
                }
              }
              next();
            }
            exports2.asyncIter = asyncIter;
            function asyncFor(obj, iter, cb) {
              var keys = keys_(obj || {});
              var len = keys.length;
              var i = -1;
              function next() {
                i++;
                var k = keys[i];
                if (i < len) {
                  iter(k, obj[k], i, len, next);
                } else {
                  cb();
                }
              }
              next();
            }
            exports2.asyncFor = asyncFor;
            function indexOf(arr, searchElement, fromIndex) {
              return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
            }
            exports2.indexOf = indexOf;
            function keys_(obj) {
              var arr = [];
              for (var k in obj) {
                if (hasOwnProp(obj, k)) {
                  arr.push(k);
                }
              }
              return arr;
            }
            exports2.keys = keys_;
            function _entries(obj) {
              return keys_(obj).map(function(k) {
                return [k, obj[k]];
              });
            }
            exports2._entries = _entries;
            function _values(obj) {
              return keys_(obj).map(function(k) {
                return obj[k];
              });
            }
            exports2._values = _values;
            function extend(obj1, obj2) {
              obj1 = obj1 || {};
              keys_(obj2).forEach(function(k) {
                obj1[k] = obj2[k];
              });
              return obj1;
            }
            exports2._assign = exports2.extend = extend;
            function inOperator(key, val) {
              if (isArray(val) || isString(val)) {
                return val.indexOf(key) !== -1;
              } else if (isObject(val)) {
                return key in val;
              }
              throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
            }
            exports2.inOperator = inOperator;
          },
          /* 1 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
              }
            }
            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps) _defineProperties(Constructor.prototype, protoProps);
              if (staticProps) _defineProperties(Constructor, staticProps);
              Object.defineProperty(Constructor, "prototype", { writable: false });
              return Constructor;
            }
            function _toPropertyKey(arg) {
              var key = _toPrimitive(arg, "string");
              return typeof key === "symbol" ? key : String(key);
            }
            function _toPrimitive(input, hint) {
              if (typeof input !== "object" || input === null) return input;
              var prim = input[Symbol.toPrimitive];
              if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (typeof res !== "object") return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (hint === "string" ? String : Number)(input);
            }
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var EventEmitter = __webpack_require__(16);
            var lib = __webpack_require__(0);
            function parentWrap(parent, prop) {
              if (typeof parent !== "function" || typeof prop !== "function") {
                return prop;
              }
              return function wrap() {
                var tmp = this.parent;
                this.parent = parent;
                var res = prop.apply(this, arguments);
                this.parent = tmp;
                return res;
              };
            }
            function extendClass(cls, name, props) {
              props = props || {};
              lib.keys(props).forEach(function(k) {
                props[k] = parentWrap(cls.prototype[k], props[k]);
              });
              var subclass = function(_cls) {
                _inheritsLoose(subclass2, _cls);
                function subclass2() {
                  return _cls.apply(this, arguments) || this;
                }
                _createClass(subclass2, [{
                  key: "typename",
                  get: function get() {
                    return name;
                  }
                }]);
                return subclass2;
              }(cls);
              lib._assign(subclass.prototype, props);
              return subclass;
            }
            var Obj = function() {
              function Obj2() {
                this.init.apply(this, arguments);
              }
              var _proto = Obj2.prototype;
              _proto.init = function init() {
              };
              Obj2.extend = function extend(name, props) {
                if (typeof name === "object") {
                  props = name;
                  name = "anonymous";
                }
                return extendClass(this, name, props);
              };
              _createClass(Obj2, [{
                key: "typename",
                get: function get() {
                  return this.constructor.name;
                }
              }]);
              return Obj2;
            }();
            var EmitterObj = function(_EventEmitter) {
              _inheritsLoose(EmitterObj2, _EventEmitter);
              function EmitterObj2() {
                var _this2;
                var _this;
                _this = _EventEmitter.call(this) || this;
                (_this2 = _this).init.apply(_this2, arguments);
                return _this;
              }
              var _proto2 = EmitterObj2.prototype;
              _proto2.init = function init() {
              };
              EmitterObj2.extend = function extend(name, props) {
                if (typeof name === "object") {
                  props = name;
                  name = "anonymous";
                }
                return extendClass(this, name, props);
              };
              _createClass(EmitterObj2, [{
                key: "typename",
                get: function get() {
                  return this.constructor.name;
                }
              }]);
              return EmitterObj2;
            }(EventEmitter);
            module2.exports = {
              Obj,
              EmitterObj
            };
          },
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var arrayFrom = Array.from;
            var supportsIterators = typeof Symbol === "function" && Symbol.iterator && typeof arrayFrom === "function";
            var Frame = function() {
              function Frame2(parent, isolateWrites) {
                this.variables = /* @__PURE__ */ Object.create(null);
                this.parent = parent;
                this.topLevel = false;
                this.isolateWrites = isolateWrites;
              }
              var _proto = Frame2.prototype;
              _proto.set = function set(name, val, resolveUp) {
                var parts = name.split(".");
                var obj = this.variables;
                var frame = this;
                if (resolveUp) {
                  if (frame = this.resolve(parts[0], true)) {
                    frame.set(name, val);
                    return;
                  }
                }
                for (var i = 0; i < parts.length - 1; i++) {
                  var id = parts[i];
                  if (!obj[id]) {
                    obj[id] = {};
                  }
                  obj = obj[id];
                }
                obj[parts[parts.length - 1]] = val;
              };
              _proto.get = function get(name) {
                var val = this.variables[name];
                if (val !== void 0) {
                  return val;
                }
                return null;
              };
              _proto.lookup = function lookup(name) {
                var p = this.parent;
                var val = this.variables[name];
                if (val !== void 0) {
                  return val;
                }
                return p && p.lookup(name);
              };
              _proto.resolve = function resolve(name, forWrite) {
                var p = forWrite && this.isolateWrites ? void 0 : this.parent;
                var val = this.variables[name];
                if (val !== void 0) {
                  return this;
                }
                return p && p.resolve(name);
              };
              _proto.push = function push(isolateWrites) {
                return new Frame2(this, isolateWrites);
              };
              _proto.pop = function pop() {
                return this.parent;
              };
              return Frame2;
            }();
            function makeMacro(argNames, kwargNames, func) {
              return function macro() {
                for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
                  macroArgs[_key] = arguments[_key];
                }
                var argCount = numArgs(macroArgs);
                var args;
                var kwargs = getKeywordArgs(macroArgs);
                if (argCount > argNames.length) {
                  args = macroArgs.slice(0, argNames.length);
                  macroArgs.slice(args.length, argCount).forEach(function(val, i2) {
                    if (i2 < kwargNames.length) {
                      kwargs[kwargNames[i2]] = val;
                    }
                  });
                  args.push(kwargs);
                } else if (argCount < argNames.length) {
                  args = macroArgs.slice(0, argCount);
                  for (var i = argCount; i < argNames.length; i++) {
                    var arg = argNames[i];
                    args.push(kwargs[arg]);
                    delete kwargs[arg];
                  }
                  args.push(kwargs);
                } else {
                  args = macroArgs;
                }
                return func.apply(this, args);
              };
            }
            function makeKeywordArgs(obj) {
              obj.__keywords = true;
              return obj;
            }
            function isKeywordArgs(obj) {
              return obj && Object.prototype.hasOwnProperty.call(obj, "__keywords");
            }
            function getKeywordArgs(args) {
              var len = args.length;
              if (len) {
                var lastArg = args[len - 1];
                if (isKeywordArgs(lastArg)) {
                  return lastArg;
                }
              }
              return {};
            }
            function numArgs(args) {
              var len = args.length;
              if (len === 0) {
                return 0;
              }
              var lastArg = args[len - 1];
              if (isKeywordArgs(lastArg)) {
                return len - 1;
              } else {
                return len;
              }
            }
            function SafeString(val) {
              if (typeof val !== "string") {
                return val;
              }
              this.val = val;
              this.length = val.length;
            }
            SafeString.prototype = Object.create(String.prototype, {
              length: {
                writable: true,
                configurable: true,
                value: 0
              }
            });
            SafeString.prototype.valueOf = function valueOf() {
              return this.val;
            };
            SafeString.prototype.toString = function toString() {
              return this.val;
            };
            function copySafeness(dest, target) {
              if (dest instanceof SafeString) {
                return new SafeString(target);
              }
              return target.toString();
            }
            function markSafe(val) {
              var type = typeof val;
              if (type === "string") {
                return new SafeString(val);
              } else if (type !== "function") {
                return val;
              } else {
                return function wrapSafe(args) {
                  var ret = val.apply(this, arguments);
                  if (typeof ret === "string") {
                    return new SafeString(ret);
                  }
                  return ret;
                };
              }
            }
            function suppressValue(val, autoescape) {
              val = val !== void 0 && val !== null ? val : "";
              if (autoescape && !(val instanceof SafeString)) {
                val = lib.escape(val.toString());
              }
              return val;
            }
            function ensureDefined(val, lineno, colno) {
              if (val === null || val === void 0) {
                throw new lib.TemplateError("attempted to output null or undefined value", lineno + 1, colno + 1);
              }
              return val;
            }
            function memberLookup(obj, val) {
              if (obj === void 0 || obj === null) {
                return void 0;
              }
              if (typeof obj[val] === "function") {
                return function() {
                  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                  }
                  return obj[val].apply(obj, args);
                };
              }
              return obj[val];
            }
            function callWrap(obj, name, context, args) {
              if (!obj) {
                throw new Error("Unable to call `" + name + "`, which is undefined or falsey");
              } else if (typeof obj !== "function") {
                throw new Error("Unable to call `" + name + "`, which is not a function");
              }
              return obj.apply(context, args);
            }
            function contextOrFrameLookup(context, frame, name) {
              var val = frame.lookup(name);
              return val !== void 0 ? val : context.lookup(name);
            }
            function handleError(error, lineno, colno) {
              if (error.lineno) {
                return error;
              } else {
                return new lib.TemplateError(error, lineno, colno);
              }
            }
            function asyncEach(arr, dimen, iter, cb) {
              if (lib.isArray(arr)) {
                var len = arr.length;
                lib.asyncIter(arr, function iterCallback(item, i, next) {
                  switch (dimen) {
                    case 1:
                      iter(item, i, len, next);
                      break;
                    case 2:
                      iter(item[0], item[1], i, len, next);
                      break;
                    case 3:
                      iter(item[0], item[1], item[2], i, len, next);
                      break;
                    default:
                      item.push(i, len, next);
                      iter.apply(this, item);
                  }
                }, cb);
              } else {
                lib.asyncFor(arr, function iterCallback(key, val, i, len2, next) {
                  iter(key, val, i, len2, next);
                }, cb);
              }
            }
            function asyncAll(arr, dimen, func, cb) {
              var finished = 0;
              var len;
              var outputArr;
              function done(i2, output) {
                finished++;
                outputArr[i2] = output;
                if (finished === len) {
                  cb(null, outputArr.join(""));
                }
              }
              if (lib.isArray(arr)) {
                len = arr.length;
                outputArr = new Array(len);
                if (len === 0) {
                  cb(null, "");
                } else {
                  for (var i = 0; i < arr.length; i++) {
                    var item = arr[i];
                    switch (dimen) {
                      case 1:
                        func(item, i, len, done);
                        break;
                      case 2:
                        func(item[0], item[1], i, len, done);
                        break;
                      case 3:
                        func(item[0], item[1], item[2], i, len, done);
                        break;
                      default:
                        item.push(i, len, done);
                        func.apply(this, item);
                    }
                  }
                }
              } else {
                var keys = lib.keys(arr || {});
                len = keys.length;
                outputArr = new Array(len);
                if (len === 0) {
                  cb(null, "");
                } else {
                  for (var _i = 0; _i < keys.length; _i++) {
                    var k = keys[_i];
                    func(k, arr[k], _i, len, done);
                  }
                }
              }
            }
            function fromIterator(arr) {
              if (typeof arr !== "object" || arr === null || lib.isArray(arr)) {
                return arr;
              } else if (supportsIterators && Symbol.iterator in arr) {
                return arrayFrom(arr);
              } else {
                return arr;
              }
            }
            module2.exports = {
              Frame,
              makeMacro,
              makeKeywordArgs,
              numArgs,
              suppressValue,
              ensureDefined,
              memberLookup,
              contextOrFrameLookup,
              callWrap,
              handleError,
              isArray: lib.isArray,
              keys: lib.keys,
              SafeString,
              copySafeness,
              markSafe,
              asyncEach,
              asyncAll,
              inOperator: lib.inOperator,
              fromIterator
            };
          },
          /* 3 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
              }
            }
            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps) _defineProperties(Constructor.prototype, protoProps);
              if (staticProps) _defineProperties(Constructor, staticProps);
              Object.defineProperty(Constructor, "prototype", { writable: false });
              return Constructor;
            }
            function _toPropertyKey(arg) {
              var key = _toPrimitive(arg, "string");
              return typeof key === "symbol" ? key : String(key);
            }
            function _toPrimitive(input, hint) {
              if (typeof input !== "object" || input === null) return input;
              var prim = input[Symbol.toPrimitive];
              if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (typeof res !== "object") return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (hint === "string" ? String : Number)(input);
            }
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var _require = __webpack_require__(1), Obj = _require.Obj;
            function traverseAndCheck(obj, type, results) {
              if (obj instanceof type) {
                results.push(obj);
              }
              if (obj instanceof Node) {
                obj.findAll(type, results);
              }
            }
            var Node = function(_Obj) {
              _inheritsLoose(Node2, _Obj);
              function Node2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto = Node2.prototype;
              _proto.init = function init(lineno, colno) {
                var _arguments = arguments, _this = this;
                for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                  args[_key - 2] = arguments[_key];
                }
                this.lineno = lineno;
                this.colno = colno;
                this.fields.forEach(function(field, i) {
                  var val = _arguments[i + 2];
                  if (val === void 0) {
                    val = null;
                  }
                  _this[field] = val;
                });
              };
              _proto.findAll = function findAll(type, results) {
                var _this2 = this;
                results = results || [];
                if (this instanceof NodeList) {
                  this.children.forEach(function(child) {
                    return traverseAndCheck(child, type, results);
                  });
                } else {
                  this.fields.forEach(function(field) {
                    return traverseAndCheck(_this2[field], type, results);
                  });
                }
                return results;
              };
              _proto.iterFields = function iterFields(func) {
                var _this3 = this;
                this.fields.forEach(function(field) {
                  func(_this3[field], field);
                });
              };
              return Node2;
            }(Obj);
            var Value = function(_Node) {
              _inheritsLoose(Value2, _Node);
              function Value2() {
                return _Node.apply(this, arguments) || this;
              }
              _createClass(Value2, [{
                key: "typename",
                get: function get() {
                  return "Value";
                }
              }, {
                key: "fields",
                get: function get() {
                  return ["value"];
                }
              }]);
              return Value2;
            }(Node);
            var NodeList = function(_Node2) {
              _inheritsLoose(NodeList2, _Node2);
              function NodeList2() {
                return _Node2.apply(this, arguments) || this;
              }
              var _proto2 = NodeList2.prototype;
              _proto2.init = function init(lineno, colno, nodes) {
                _Node2.prototype.init.call(this, lineno, colno, nodes || []);
              };
              _proto2.addChild = function addChild(node) {
                this.children.push(node);
              };
              _createClass(NodeList2, [{
                key: "typename",
                get: function get() {
                  return "NodeList";
                }
              }, {
                key: "fields",
                get: function get() {
                  return ["children"];
                }
              }]);
              return NodeList2;
            }(Node);
            var Root = NodeList.extend("Root");
            var Literal = Value.extend("Literal");
            var _Symbol = Value.extend("Symbol");
            var Group = NodeList.extend("Group");
            var ArrayNode = NodeList.extend("Array");
            var Pair = Node.extend("Pair", {
              fields: ["key", "value"]
            });
            var Dict = NodeList.extend("Dict");
            var LookupVal = Node.extend("LookupVal", {
              fields: ["target", "val"]
            });
            var If = Node.extend("If", {
              fields: ["cond", "body", "else_"]
            });
            var IfAsync = If.extend("IfAsync");
            var InlineIf = Node.extend("InlineIf", {
              fields: ["cond", "body", "else_"]
            });
            var For = Node.extend("For", {
              fields: ["arr", "name", "body", "else_"]
            });
            var AsyncEach = For.extend("AsyncEach");
            var AsyncAll = For.extend("AsyncAll");
            var Macro = Node.extend("Macro", {
              fields: ["name", "args", "body"]
            });
            var Caller = Macro.extend("Caller");
            var Import = Node.extend("Import", {
              fields: ["template", "target", "withContext"]
            });
            var FromImport = function(_Node3) {
              _inheritsLoose(FromImport2, _Node3);
              function FromImport2() {
                return _Node3.apply(this, arguments) || this;
              }
              var _proto3 = FromImport2.prototype;
              _proto3.init = function init(lineno, colno, template, names, withContext) {
                _Node3.prototype.init.call(this, lineno, colno, template, names || new NodeList(), withContext);
              };
              _createClass(FromImport2, [{
                key: "typename",
                get: function get() {
                  return "FromImport";
                }
              }, {
                key: "fields",
                get: function get() {
                  return ["template", "names", "withContext"];
                }
              }]);
              return FromImport2;
            }(Node);
            var FunCall = Node.extend("FunCall", {
              fields: ["name", "args"]
            });
            var Filter = FunCall.extend("Filter");
            var FilterAsync = Filter.extend("FilterAsync", {
              fields: ["name", "args", "symbol"]
            });
            var KeywordArgs = Dict.extend("KeywordArgs");
            var Block = Node.extend("Block", {
              fields: ["name", "body"]
            });
            var Super = Node.extend("Super", {
              fields: ["blockName", "symbol"]
            });
            var TemplateRef = Node.extend("TemplateRef", {
              fields: ["template"]
            });
            var Extends = TemplateRef.extend("Extends");
            var Include = Node.extend("Include", {
              fields: ["template", "ignoreMissing"]
            });
            var Set2 = Node.extend("Set", {
              fields: ["targets", "value"]
            });
            var Switch = Node.extend("Switch", {
              fields: ["expr", "cases", "default"]
            });
            var Case = Node.extend("Case", {
              fields: ["cond", "body"]
            });
            var Output = NodeList.extend("Output");
            var Capture = Node.extend("Capture", {
              fields: ["body"]
            });
            var TemplateData = Literal.extend("TemplateData");
            var UnaryOp = Node.extend("UnaryOp", {
              fields: ["target"]
            });
            var BinOp = Node.extend("BinOp", {
              fields: ["left", "right"]
            });
            var In = BinOp.extend("In");
            var Is = BinOp.extend("Is");
            var Or = BinOp.extend("Or");
            var And = BinOp.extend("And");
            var Not = UnaryOp.extend("Not");
            var Add = BinOp.extend("Add");
            var Concat = BinOp.extend("Concat");
            var Sub = BinOp.extend("Sub");
            var Mul = BinOp.extend("Mul");
            var Div = BinOp.extend("Div");
            var FloorDiv = BinOp.extend("FloorDiv");
            var Mod = BinOp.extend("Mod");
            var Pow = BinOp.extend("Pow");
            var Neg = UnaryOp.extend("Neg");
            var Pos = UnaryOp.extend("Pos");
            var Compare = Node.extend("Compare", {
              fields: ["expr", "ops"]
            });
            var CompareOperand = Node.extend("CompareOperand", {
              fields: ["expr", "type"]
            });
            var CallExtension = Node.extend("CallExtension", {
              init: function init(ext, prop, args, contentArgs) {
                this.parent();
                this.extName = ext.__name || ext;
                this.prop = prop;
                this.args = args || new NodeList();
                this.contentArgs = contentArgs || [];
                this.autoescape = ext.autoescape;
              },
              fields: ["extName", "prop", "args", "contentArgs"]
            });
            var CallExtensionAsync = CallExtension.extend("CallExtensionAsync");
            function print(str, indent, inline) {
              var lines = str.split("\n");
              lines.forEach(function(line, i) {
                if (line && (inline && i > 0 || !inline)) {
                  process.stdout.write(" ".repeat(indent));
                }
                var nl = i === lines.length - 1 ? "" : "\n";
                process.stdout.write("" + line + nl);
              });
            }
            function printNodes(node, indent) {
              indent = indent || 0;
              print(node.typename + ": ", indent);
              if (node instanceof NodeList) {
                print("\n");
                node.children.forEach(function(n) {
                  printNodes(n, indent + 2);
                });
              } else if (node instanceof CallExtension) {
                print(node.extName + "." + node.prop + "\n");
                if (node.args) {
                  printNodes(node.args, indent + 2);
                }
                if (node.contentArgs) {
                  node.contentArgs.forEach(function(n) {
                    printNodes(n, indent + 2);
                  });
                }
              } else {
                var nodes = [];
                var props = null;
                node.iterFields(function(val, fieldName) {
                  if (val instanceof Node) {
                    nodes.push([fieldName, val]);
                  } else {
                    props = props || {};
                    props[fieldName] = val;
                  }
                });
                if (props) {
                  print(JSON.stringify(props, null, 2) + "\n", null, true);
                } else {
                  print("\n");
                }
                nodes.forEach(function(_ref) {
                  var fieldName = _ref[0], n = _ref[1];
                  print("[" + fieldName + "] =>", indent + 2);
                  printNodes(n, indent + 4);
                });
              }
            }
            module2.exports = {
              Node,
              Root,
              NodeList,
              Value,
              Literal,
              Symbol: _Symbol,
              Group,
              Array: ArrayNode,
              Pair,
              Dict,
              Output,
              Capture,
              TemplateData,
              If,
              IfAsync,
              InlineIf,
              For,
              AsyncEach,
              AsyncAll,
              Macro,
              Caller,
              Import,
              FromImport,
              FunCall,
              Filter,
              FilterAsync,
              KeywordArgs,
              Block,
              Super,
              Extends,
              Include,
              Set: Set2,
              Switch,
              Case,
              LookupVal,
              BinOp,
              In,
              Is,
              Or,
              And,
              Not,
              Add,
              Concat,
              Sub,
              Mul,
              Div,
              FloorDiv,
              Mod,
              Pow,
              Neg,
              Pos,
              Compare,
              CompareOperand,
              CallExtension,
              CallExtensionAsync,
              printNodes
            };
          },
          /* 4 */
          /***/
          function(module2, exports2) {
          },
          /* 5 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var parser = __webpack_require__(8);
            var transformer = __webpack_require__(17);
            var nodes = __webpack_require__(3);
            var _require = __webpack_require__(0), TemplateError = _require.TemplateError;
            var _require2 = __webpack_require__(2), Frame = _require2.Frame;
            var _require3 = __webpack_require__(1), Obj = _require3.Obj;
            var compareOps = {
              "==": "==",
              "===": "===",
              "!=": "!=",
              "!==": "!==",
              "<": "<",
              ">": ">",
              "<=": "<=",
              ">=": ">="
            };
            var Compiler = function(_Obj) {
              _inheritsLoose(Compiler2, _Obj);
              function Compiler2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto = Compiler2.prototype;
              _proto.init = function init(templateName, throwOnUndefined) {
                this.templateName = templateName;
                this.codebuf = [];
                this.lastId = 0;
                this.buffer = null;
                this.bufferStack = [];
                this._scopeClosers = "";
                this.inBlock = false;
                this.throwOnUndefined = throwOnUndefined;
              };
              _proto.fail = function fail(msg, lineno, colno) {
                if (lineno !== void 0) {
                  lineno += 1;
                }
                if (colno !== void 0) {
                  colno += 1;
                }
                throw new TemplateError(msg, lineno, colno);
              };
              _proto._pushBuffer = function _pushBuffer() {
                var id = this._tmpid();
                this.bufferStack.push(this.buffer);
                this.buffer = id;
                this._emit("var " + this.buffer + ' = "";');
                return id;
              };
              _proto._popBuffer = function _popBuffer() {
                this.buffer = this.bufferStack.pop();
              };
              _proto._emit = function _emit(code) {
                this.codebuf.push(code);
              };
              _proto._emitLine = function _emitLine(code) {
                this._emit(code + "\n");
              };
              _proto._emitLines = function _emitLines() {
                var _this = this;
                for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
                  lines[_key] = arguments[_key];
                }
                lines.forEach(function(line) {
                  return _this._emitLine(line);
                });
              };
              _proto._emitFuncBegin = function _emitFuncBegin(node, name) {
                this.buffer = "output";
                this._scopeClosers = "";
                this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");
                this._emitLine("var lineno = " + node.lineno + ";");
                this._emitLine("var colno = " + node.colno + ";");
                this._emitLine("var " + this.buffer + ' = "";');
                this._emitLine("try {");
              };
              _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
                if (!noReturn) {
                  this._emitLine("cb(null, " + this.buffer + ");");
                }
                this._closeScopeLevels();
                this._emitLine("} catch (e) {");
                this._emitLine("  cb(runtime.handleError(e, lineno, colno));");
                this._emitLine("}");
                this._emitLine("}");
                this.buffer = null;
              };
              _proto._addScopeLevel = function _addScopeLevel() {
                this._scopeClosers += "})";
              };
              _proto._closeScopeLevels = function _closeScopeLevels() {
                this._emitLine(this._scopeClosers + ";");
                this._scopeClosers = "";
              };
              _proto._withScopedSyntax = function _withScopedSyntax(func) {
                var _scopeClosers = this._scopeClosers;
                this._scopeClosers = "";
                func.call(this);
                this._closeScopeLevels();
                this._scopeClosers = _scopeClosers;
              };
              _proto._makeCallback = function _makeCallback(res) {
                var err = this._tmpid();
                return "function(" + err + (res ? "," + res : "") + ") {\nif(" + err + ") { cb(" + err + "); return; }";
              };
              _proto._tmpid = function _tmpid() {
                this.lastId++;
                return "t_" + this.lastId;
              };
              _proto._templateName = function _templateName() {
                return this.templateName == null ? "undefined" : JSON.stringify(this.templateName);
              };
              _proto._compileChildren = function _compileChildren(node, frame) {
                var _this2 = this;
                node.children.forEach(function(child) {
                  _this2.compile(child, frame);
                });
              };
              _proto._compileAggregate = function _compileAggregate(node, frame, startChar, endChar) {
                var _this3 = this;
                if (startChar) {
                  this._emit(startChar);
                }
                node.children.forEach(function(child, i) {
                  if (i > 0) {
                    _this3._emit(",");
                  }
                  _this3.compile(child, frame);
                });
                if (endChar) {
                  this._emit(endChar);
                }
              };
              _proto._compileExpression = function _compileExpression(node, frame) {
                this.assertType(node, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
                this.compile(node, frame);
              };
              _proto.assertType = function assertType(node) {
                for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  types[_key2 - 1] = arguments[_key2];
                }
                if (!types.some(function(t) {
                  return node instanceof t;
                })) {
                  this.fail("assertType: invalid type: " + node.typename, node.lineno, node.colno);
                }
              };
              _proto.compileCallExtension = function compileCallExtension(node, frame, async) {
                var _this4 = this;
                var args = node.args;
                var contentArgs = node.contentArgs;
                var autoescape = typeof node.autoescape === "boolean" ? node.autoescape : true;
                if (!async) {
                  this._emit(this.buffer + " += runtime.suppressValue(");
                }
                this._emit('env.getExtension("' + node.extName + '")["' + node.prop + '"](');
                this._emit("context");
                if (args || contentArgs) {
                  this._emit(",");
                }
                if (args) {
                  if (!(args instanceof nodes.NodeList)) {
                    this.fail("compileCallExtension: arguments must be a NodeList, use `parser.parseSignature`");
                  }
                  args.children.forEach(function(arg, i) {
                    _this4._compileExpression(arg, frame);
                    if (i !== args.children.length - 1 || contentArgs.length) {
                      _this4._emit(",");
                    }
                  });
                }
                if (contentArgs.length) {
                  contentArgs.forEach(function(arg, i) {
                    if (i > 0) {
                      _this4._emit(",");
                    }
                    if (arg) {
                      _this4._emitLine("function(cb) {");
                      _this4._emitLine("if(!cb) { cb = function(err) { if(err) { throw err; }}}");
                      var id = _this4._pushBuffer();
                      _this4._withScopedSyntax(function() {
                        _this4.compile(arg, frame);
                        _this4._emitLine("cb(null, " + id + ");");
                      });
                      _this4._popBuffer();
                      _this4._emitLine("return " + id + ";");
                      _this4._emitLine("}");
                    } else {
                      _this4._emit("null");
                    }
                  });
                }
                if (async) {
                  var res = this._tmpid();
                  this._emitLine(", " + this._makeCallback(res));
                  this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");
                  this._addScopeLevel();
                } else {
                  this._emit(")");
                  this._emit(", " + autoescape + " && env.opts.autoescape);\n");
                }
              };
              _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node, frame) {
                this.compileCallExtension(node, frame, true);
              };
              _proto.compileNodeList = function compileNodeList(node, frame) {
                this._compileChildren(node, frame);
              };
              _proto.compileLiteral = function compileLiteral(node) {
                if (typeof node.value === "string") {
                  var val = node.value.replace(/\\/g, "\\\\");
                  val = val.replace(/"/g, '\\"');
                  val = val.replace(/\n/g, "\\n");
                  val = val.replace(/\r/g, "\\r");
                  val = val.replace(/\t/g, "\\t");
                  val = val.replace(/\u2028/g, "\\u2028");
                  this._emit('"' + val + '"');
                } else if (node.value === null) {
                  this._emit("null");
                } else {
                  this._emit(node.value.toString());
                }
              };
              _proto.compileSymbol = function compileSymbol(node, frame) {
                var name = node.value;
                var v = frame.lookup(name);
                if (v) {
                  this._emit(v);
                } else {
                  this._emit('runtime.contextOrFrameLookup(context, frame, "' + name + '")');
                }
              };
              _proto.compileGroup = function compileGroup(node, frame) {
                this._compileAggregate(node, frame, "(", ")");
              };
              _proto.compileArray = function compileArray(node, frame) {
                this._compileAggregate(node, frame, "[", "]");
              };
              _proto.compileDict = function compileDict(node, frame) {
                this._compileAggregate(node, frame, "{", "}");
              };
              _proto.compilePair = function compilePair(node, frame) {
                var key = node.key;
                var val = node.value;
                if (key instanceof nodes.Symbol) {
                  key = new nodes.Literal(key.lineno, key.colno, key.value);
                } else if (!(key instanceof nodes.Literal && typeof key.value === "string")) {
                  this.fail("compilePair: Dict keys must be strings or names", key.lineno, key.colno);
                }
                this.compile(key, frame);
                this._emit(": ");
                this._compileExpression(val, frame);
              };
              _proto.compileInlineIf = function compileInlineIf(node, frame) {
                this._emit("(");
                this.compile(node.cond, frame);
                this._emit("?");
                this.compile(node.body, frame);
                this._emit(":");
                if (node.else_ !== null) {
                  this.compile(node.else_, frame);
                } else {
                  this._emit('""');
                }
                this._emit(")");
              };
              _proto.compileIn = function compileIn(node, frame) {
                this._emit("runtime.inOperator(");
                this.compile(node.left, frame);
                this._emit(",");
                this.compile(node.right, frame);
                this._emit(")");
              };
              _proto.compileIs = function compileIs(node, frame) {
                var right = node.right.name ? node.right.name.value : node.right.value;
                this._emit('env.getTest("' + right + '").call(context, ');
                this.compile(node.left, frame);
                if (node.right.args) {
                  this._emit(",");
                  this.compile(node.right.args, frame);
                }
                this._emit(") === true");
              };
              _proto._binOpEmitter = function _binOpEmitter(node, frame, str) {
                this.compile(node.left, frame);
                this._emit(str);
                this.compile(node.right, frame);
              };
              _proto.compileOr = function compileOr(node, frame) {
                return this._binOpEmitter(node, frame, " || ");
              };
              _proto.compileAnd = function compileAnd(node, frame) {
                return this._binOpEmitter(node, frame, " && ");
              };
              _proto.compileAdd = function compileAdd(node, frame) {
                return this._binOpEmitter(node, frame, " + ");
              };
              _proto.compileConcat = function compileConcat(node, frame) {
                return this._binOpEmitter(node, frame, ' + "" + ');
              };
              _proto.compileSub = function compileSub(node, frame) {
                return this._binOpEmitter(node, frame, " - ");
              };
              _proto.compileMul = function compileMul(node, frame) {
                return this._binOpEmitter(node, frame, " * ");
              };
              _proto.compileDiv = function compileDiv(node, frame) {
                return this._binOpEmitter(node, frame, " / ");
              };
              _proto.compileMod = function compileMod(node, frame) {
                return this._binOpEmitter(node, frame, " % ");
              };
              _proto.compileNot = function compileNot(node, frame) {
                this._emit("!");
                this.compile(node.target, frame);
              };
              _proto.compileFloorDiv = function compileFloorDiv(node, frame) {
                this._emit("Math.floor(");
                this.compile(node.left, frame);
                this._emit(" / ");
                this.compile(node.right, frame);
                this._emit(")");
              };
              _proto.compilePow = function compilePow(node, frame) {
                this._emit("Math.pow(");
                this.compile(node.left, frame);
                this._emit(", ");
                this.compile(node.right, frame);
                this._emit(")");
              };
              _proto.compileNeg = function compileNeg(node, frame) {
                this._emit("-");
                this.compile(node.target, frame);
              };
              _proto.compilePos = function compilePos(node, frame) {
                this._emit("+");
                this.compile(node.target, frame);
              };
              _proto.compileCompare = function compileCompare(node, frame) {
                var _this5 = this;
                this.compile(node.expr, frame);
                node.ops.forEach(function(op) {
                  _this5._emit(" " + compareOps[op.type] + " ");
                  _this5.compile(op.expr, frame);
                });
              };
              _proto.compileLookupVal = function compileLookupVal(node, frame) {
                this._emit("runtime.memberLookup((");
                this._compileExpression(node.target, frame);
                this._emit("),");
                this._compileExpression(node.val, frame);
                this._emit(")");
              };
              _proto._getNodeName = function _getNodeName(node) {
                switch (node.typename) {
                  case "Symbol":
                    return node.value;
                  case "FunCall":
                    return "the return value of (" + this._getNodeName(node.name) + ")";
                  case "LookupVal":
                    return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';
                  case "Literal":
                    return node.value.toString();
                  default:
                    return "--expression--";
                }
              };
              _proto.compileFunCall = function compileFunCall(node, frame) {
                this._emit("(lineno = " + node.lineno + ", colno = " + node.colno + ", ");
                this._emit("runtime.callWrap(");
                this._compileExpression(node.name, frame);
                this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');
                this._compileAggregate(node.args, frame, "[", "])");
                this._emit(")");
              };
              _proto.compileFilter = function compileFilter(node, frame) {
                var name = node.name;
                this.assertType(name, nodes.Symbol);
                this._emit('env.getFilter("' + name.value + '").call(context, ');
                this._compileAggregate(node.args, frame);
                this._emit(")");
              };
              _proto.compileFilterAsync = function compileFilterAsync(node, frame) {
                var name = node.name;
                var symbol = node.symbol.value;
                this.assertType(name, nodes.Symbol);
                frame.set(symbol, symbol);
                this._emit('env.getFilter("' + name.value + '").call(context, ');
                this._compileAggregate(node.args, frame);
                this._emitLine(", " + this._makeCallback(symbol));
                this._addScopeLevel();
              };
              _proto.compileKeywordArgs = function compileKeywordArgs(node, frame) {
                this._emit("runtime.makeKeywordArgs(");
                this.compileDict(node, frame);
                this._emit(")");
              };
              _proto.compileSet = function compileSet(node, frame) {
                var _this6 = this;
                var ids = [];
                node.targets.forEach(function(target) {
                  var name = target.value;
                  var id = frame.lookup(name);
                  if (id === null || id === void 0) {
                    id = _this6._tmpid();
                    _this6._emitLine("var " + id + ";");
                  }
                  ids.push(id);
                });
                if (node.value) {
                  this._emit(ids.join(" = ") + " = ");
                  this._compileExpression(node.value, frame);
                  this._emitLine(";");
                } else {
                  this._emit(ids.join(" = ") + " = ");
                  this.compile(node.body, frame);
                  this._emitLine(";");
                }
                node.targets.forEach(function(target, i) {
                  var id = ids[i];
                  var name = target.value;
                  _this6._emitLine('frame.set("' + name + '", ' + id + ", true);");
                  _this6._emitLine("if(frame.topLevel) {");
                  _this6._emitLine('context.setVariable("' + name + '", ' + id + ");");
                  _this6._emitLine("}");
                  if (name.charAt(0) !== "_") {
                    _this6._emitLine("if(frame.topLevel) {");
                    _this6._emitLine('context.addExport("' + name + '", ' + id + ");");
                    _this6._emitLine("}");
                  }
                });
              };
              _proto.compileSwitch = function compileSwitch(node, frame) {
                var _this7 = this;
                this._emit("switch (");
                this.compile(node.expr, frame);
                this._emit(") {");
                node.cases.forEach(function(c, i) {
                  _this7._emit("case ");
                  _this7.compile(c.cond, frame);
                  _this7._emit(": ");
                  _this7.compile(c.body, frame);
                  if (c.body.children.length) {
                    _this7._emitLine("break;");
                  }
                });
                if (node.default) {
                  this._emit("default:");
                  this.compile(node.default, frame);
                }
                this._emit("}");
              };
              _proto.compileIf = function compileIf(node, frame, async) {
                var _this8 = this;
                this._emit("if(");
                this._compileExpression(node.cond, frame);
                this._emitLine(") {");
                this._withScopedSyntax(function() {
                  _this8.compile(node.body, frame);
                  if (async) {
                    _this8._emit("cb()");
                  }
                });
                if (node.else_) {
                  this._emitLine("}\nelse {");
                  this._withScopedSyntax(function() {
                    _this8.compile(node.else_, frame);
                    if (async) {
                      _this8._emit("cb()");
                    }
                  });
                } else if (async) {
                  this._emitLine("}\nelse {");
                  this._emit("cb()");
                }
                this._emitLine("}");
              };
              _proto.compileIfAsync = function compileIfAsync(node, frame) {
                this._emit("(function(cb) {");
                this.compileIf(node, frame, true);
                this._emit("})(" + this._makeCallback());
                this._addScopeLevel();
              };
              _proto._emitLoopBindings = function _emitLoopBindings(node, arr, i, len) {
                var _this9 = this;
                var bindings = [{
                  name: "index",
                  val: i + " + 1"
                }, {
                  name: "index0",
                  val: i
                }, {
                  name: "revindex",
                  val: len + " - " + i
                }, {
                  name: "revindex0",
                  val: len + " - " + i + " - 1"
                }, {
                  name: "first",
                  val: i + " === 0"
                }, {
                  name: "last",
                  val: i + " === " + len + " - 1"
                }, {
                  name: "length",
                  val: len
                }];
                bindings.forEach(function(b) {
                  _this9._emitLine('frame.set("loop.' + b.name + '", ' + b.val + ");");
                });
              };
              _proto.compileFor = function compileFor(node, frame) {
                var _this10 = this;
                var i = this._tmpid();
                var len = this._tmpid();
                var arr = this._tmpid();
                frame = frame.push();
                this._emitLine("frame = frame.push();");
                this._emit("var " + arr + " = ");
                this._compileExpression(node.arr, frame);
                this._emitLine(";");
                this._emit("if(" + arr + ") {");
                this._emitLine(arr + " = runtime.fromIterator(" + arr + ");");
                if (node.name instanceof nodes.Array) {
                  this._emitLine("var " + i + ";");
                  this._emitLine("if(runtime.isArray(" + arr + ")) {");
                  this._emitLine("var " + len + " = " + arr + ".length;");
                  this._emitLine("for(" + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");
                  node.name.children.forEach(function(child, u) {
                    var tid = _this10._tmpid();
                    _this10._emitLine("var " + tid + " = " + arr + "[" + i + "][" + u + "];");
                    _this10._emitLine('frame.set("' + child + '", ' + arr + "[" + i + "][" + u + "]);");
                    frame.set(node.name.children[u].value, tid);
                  });
                  this._emitLoopBindings(node, arr, i, len);
                  this._withScopedSyntax(function() {
                    _this10.compile(node.body, frame);
                  });
                  this._emitLine("}");
                  this._emitLine("} else {");
                  var _node$name$children = node.name.children, key = _node$name$children[0], val = _node$name$children[1];
                  var k = this._tmpid();
                  var v = this._tmpid();
                  frame.set(key.value, k);
                  frame.set(val.value, v);
                  this._emitLine(i + " = -1;");
                  this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");
                  this._emitLine("for(var " + k + " in " + arr + ") {");
                  this._emitLine(i + "++;");
                  this._emitLine("var " + v + " = " + arr + "[" + k + "];");
                  this._emitLine('frame.set("' + key.value + '", ' + k + ");");
                  this._emitLine('frame.set("' + val.value + '", ' + v + ");");
                  this._emitLoopBindings(node, arr, i, len);
                  this._withScopedSyntax(function() {
                    _this10.compile(node.body, frame);
                  });
                  this._emitLine("}");
                  this._emitLine("}");
                } else {
                  var _v = this._tmpid();
                  frame.set(node.name.value, _v);
                  this._emitLine("var " + len + " = " + arr + ".length;");
                  this._emitLine("for(var " + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");
                  this._emitLine("var " + _v + " = " + arr + "[" + i + "];");
                  this._emitLine('frame.set("' + node.name.value + '", ' + _v + ");");
                  this._emitLoopBindings(node, arr, i, len);
                  this._withScopedSyntax(function() {
                    _this10.compile(node.body, frame);
                  });
                  this._emitLine("}");
                }
                this._emitLine("}");
                if (node.else_) {
                  this._emitLine("if (!" + len + ") {");
                  this.compile(node.else_, frame);
                  this._emitLine("}");
                }
                this._emitLine("frame = frame.pop();");
              };
              _proto._compileAsyncLoop = function _compileAsyncLoop(node, frame, parallel) {
                var _this11 = this;
                var i = this._tmpid();
                var len = this._tmpid();
                var arr = this._tmpid();
                var asyncMethod = parallel ? "asyncAll" : "asyncEach";
                frame = frame.push();
                this._emitLine("frame = frame.push();");
                this._emit("var " + arr + " = runtime.fromIterator(");
                this._compileExpression(node.arr, frame);
                this._emitLine(");");
                if (node.name instanceof nodes.Array) {
                  var arrayLen = node.name.children.length;
                  this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");
                  node.name.children.forEach(function(name) {
                    _this11._emit(name.value + ",");
                  });
                  this._emit(i + "," + len + ",next) {");
                  node.name.children.forEach(function(name) {
                    var id2 = name.value;
                    frame.set(id2, id2);
                    _this11._emitLine('frame.set("' + id2 + '", ' + id2 + ");");
                  });
                } else {
                  var id = node.name.value;
                  this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i + ", " + len + ",next) {");
                  this._emitLine('frame.set("' + id + '", ' + id + ");");
                  frame.set(id, id);
                }
                this._emitLoopBindings(node, arr, i, len);
                this._withScopedSyntax(function() {
                  var buf;
                  if (parallel) {
                    buf = _this11._pushBuffer();
                  }
                  _this11.compile(node.body, frame);
                  _this11._emitLine("next(" + i + (buf ? "," + buf : "") + ");");
                  if (parallel) {
                    _this11._popBuffer();
                  }
                });
                var output = this._tmpid();
                this._emitLine("}, " + this._makeCallback(output));
                this._addScopeLevel();
                if (parallel) {
                  this._emitLine(this.buffer + " += " + output + ";");
                }
                if (node.else_) {
                  this._emitLine("if (!" + arr + ".length) {");
                  this.compile(node.else_, frame);
                  this._emitLine("}");
                }
                this._emitLine("frame = frame.pop();");
              };
              _proto.compileAsyncEach = function compileAsyncEach(node, frame) {
                this._compileAsyncLoop(node, frame);
              };
              _proto.compileAsyncAll = function compileAsyncAll(node, frame) {
                this._compileAsyncLoop(node, frame, true);
              };
              _proto._compileMacro = function _compileMacro(node, frame) {
                var _this12 = this;
                var args = [];
                var kwargs = null;
                var funcId = "macro_" + this._tmpid();
                var keepFrame = frame !== void 0;
                node.args.children.forEach(function(arg, i) {
                  if (i === node.args.children.length - 1 && arg instanceof nodes.Dict) {
                    kwargs = arg;
                  } else {
                    _this12.assertType(arg, nodes.Symbol);
                    args.push(arg);
                  }
                });
                var realNames = [].concat(args.map(function(n) {
                  return "l_" + n.value;
                }), ["kwargs"]);
                var argNames = args.map(function(n) {
                  return '"' + n.value + '"';
                });
                var kwargNames = (kwargs && kwargs.children || []).map(function(n) {
                  return '"' + n.key.value + '"';
                });
                var currFrame;
                if (keepFrame) {
                  currFrame = frame.push(true);
                } else {
                  currFrame = new Frame();
                }
                this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(", ") + "], ", "[" + kwargNames.join(", ") + "], ", "function (" + realNames.join(", ") + ") {", "var callerFrame = frame;", "frame = " + (keepFrame ? "frame.push(true);" : "new runtime.Frame();"), "kwargs = kwargs || {};", 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }');
                args.forEach(function(arg) {
                  _this12._emitLine('frame.set("' + arg.value + '", l_' + arg.value + ");");
                  currFrame.set(arg.value, "l_" + arg.value);
                });
                if (kwargs) {
                  kwargs.children.forEach(function(pair) {
                    var name = pair.key.value;
                    _this12._emit('frame.set("' + name + '", ');
                    _this12._emit('Object.prototype.hasOwnProperty.call(kwargs, "' + name + '")');
                    _this12._emit(' ? kwargs["' + name + '"] : ');
                    _this12._compileExpression(pair.value, currFrame);
                    _this12._emit(");");
                  });
                }
                var bufferId = this._pushBuffer();
                this._withScopedSyntax(function() {
                  _this12.compile(node.body, currFrame);
                });
                this._emitLine("frame = " + (keepFrame ? "frame.pop();" : "callerFrame;"));
                this._emitLine("return new runtime.SafeString(" + bufferId + ");");
                this._emitLine("});");
                this._popBuffer();
                return funcId;
              };
              _proto.compileMacro = function compileMacro(node, frame) {
                var funcId = this._compileMacro(node);
                var name = node.name.value;
                frame.set(name, funcId);
                if (frame.parent) {
                  this._emitLine('frame.set("' + name + '", ' + funcId + ");");
                } else {
                  if (node.name.value.charAt(0) !== "_") {
                    this._emitLine('context.addExport("' + name + '");');
                  }
                  this._emitLine('context.setVariable("' + name + '", ' + funcId + ");");
                }
              };
              _proto.compileCaller = function compileCaller(node, frame) {
                this._emit("(function (){");
                var funcId = this._compileMacro(node, frame);
                this._emit("return " + funcId + ";})()");
              };
              _proto._compileGetTemplate = function _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
                var parentTemplateId = this._tmpid();
                var parentName = this._templateName();
                var cb = this._makeCallback(parentTemplateId);
                var eagerCompileArg = eagerCompile ? "true" : "false";
                var ignoreMissingArg = ignoreMissing ? "true" : "false";
                this._emit("env.getTemplate(");
                this._compileExpression(node.template, frame);
                this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);
                return parentTemplateId;
              };
              _proto.compileImport = function compileImport(node, frame) {
                var target = node.target.value;
                var id = this._compileGetTemplate(node, frame, false, false);
                this._addScopeLevel();
                this._emitLine(id + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(id));
                this._addScopeLevel();
                frame.set(target, id);
                if (frame.parent) {
                  this._emitLine('frame.set("' + target + '", ' + id + ");");
                } else {
                  this._emitLine('context.setVariable("' + target + '", ' + id + ");");
                }
              };
              _proto.compileFromImport = function compileFromImport(node, frame) {
                var _this13 = this;
                var importedId = this._compileGetTemplate(node, frame, false, false);
                this._addScopeLevel();
                this._emitLine(importedId + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(importedId));
                this._addScopeLevel();
                node.names.children.forEach(function(nameNode) {
                  var name;
                  var alias;
                  var id = _this13._tmpid();
                  if (nameNode instanceof nodes.Pair) {
                    name = nameNode.key.value;
                    alias = nameNode.value.value;
                  } else {
                    name = nameNode.value;
                    alias = name;
                  }
                  _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ', "' + name + '")) {');
                  _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");
                  _this13._emitLine("} else {");
                  _this13._emitLine(`cb(new Error("cannot import '` + name + `'")); return;`);
                  _this13._emitLine("}");
                  frame.set(alias, id);
                  if (frame.parent) {
                    _this13._emitLine('frame.set("' + alias + '", ' + id + ");");
                  } else {
                    _this13._emitLine('context.setVariable("' + alias + '", ' + id + ");");
                  }
                });
              };
              _proto.compileBlock = function compileBlock(node) {
                var id = this._tmpid();
                if (!this.inBlock) {
                  this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
                }
                this._emit('context.getBlock("' + node.name.value + '")');
                if (!this.inBlock) {
                  this._emit(")");
                }
                this._emitLine("(env, context, frame, runtime, " + this._makeCallback(id));
                this._emitLine(this.buffer + " += " + id + ";");
                this._addScopeLevel();
              };
              _proto.compileSuper = function compileSuper(node, frame) {
                var name = node.blockName.value;
                var id = node.symbol.value;
                var cb = this._makeCallback(id);
                this._emitLine('context.getSuper(env, "' + name + '", b_' + name + ", frame, runtime, " + cb);
                this._emitLine(id + " = runtime.markSafe(" + id + ");");
                this._addScopeLevel();
                frame.set(id, id);
              };
              _proto.compileExtends = function compileExtends(node, frame) {
                var k = this._tmpid();
                var parentTemplateId = this._compileGetTemplate(node, frame, true, false);
                this._emitLine("parentTemplate = " + parentTemplateId);
                this._emitLine("for(var " + k + " in parentTemplate.blocks) {");
                this._emitLine("context.addBlock(" + k + ", parentTemplate.blocks[" + k + "]);");
                this._emitLine("}");
                this._addScopeLevel();
              };
              _proto.compileInclude = function compileInclude(node, frame) {
                this._emitLine("var tasks = [];");
                this._emitLine("tasks.push(");
                this._emitLine("function(callback) {");
                var id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);
                this._emitLine("callback(null," + id + ");});");
                this._emitLine("});");
                var id2 = this._tmpid();
                this._emitLine("tasks.push(");
                this._emitLine("function(template, callback){");
                this._emitLine("template.render(context.getVariables(), frame, " + this._makeCallback(id2));
                this._emitLine("callback(null," + id2 + ");});");
                this._emitLine("});");
                this._emitLine("tasks.push(");
                this._emitLine("function(result, callback){");
                this._emitLine(this.buffer + " += result;");
                this._emitLine("callback(null);");
                this._emitLine("});");
                this._emitLine("env.waterfall(tasks, function(){");
                this._addScopeLevel();
              };
              _proto.compileTemplateData = function compileTemplateData(node, frame) {
                this.compileLiteral(node, frame);
              };
              _proto.compileCapture = function compileCapture(node, frame) {
                var _this14 = this;
                var buffer = this.buffer;
                this.buffer = "output";
                this._emitLine("(function() {");
                this._emitLine('var output = "";');
                this._withScopedSyntax(function() {
                  _this14.compile(node.body, frame);
                });
                this._emitLine("return output;");
                this._emitLine("})()");
                this.buffer = buffer;
              };
              _proto.compileOutput = function compileOutput(node, frame) {
                var _this15 = this;
                var children = node.children;
                children.forEach(function(child) {
                  if (child instanceof nodes.TemplateData) {
                    if (child.value) {
                      _this15._emit(_this15.buffer + " += ");
                      _this15.compileLiteral(child, frame);
                      _this15._emitLine(";");
                    }
                  } else {
                    _this15._emit(_this15.buffer + " += runtime.suppressValue(");
                    if (_this15.throwOnUndefined) {
                      _this15._emit("runtime.ensureDefined(");
                    }
                    _this15.compile(child, frame);
                    if (_this15.throwOnUndefined) {
                      _this15._emit("," + node.lineno + "," + node.colno + ")");
                    }
                    _this15._emit(", env.opts.autoescape);\n");
                  }
                });
              };
              _proto.compileRoot = function compileRoot(node, frame) {
                var _this16 = this;
                if (frame) {
                  this.fail("compileRoot: root node can't have frame");
                }
                frame = new Frame();
                this._emitFuncBegin(node, "root");
                this._emitLine("var parentTemplate = null;");
                this._compileChildren(node, frame);
                this._emitLine("if(parentTemplate) {");
                this._emitLine("parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);");
                this._emitLine("} else {");
                this._emitLine("cb(null, " + this.buffer + ");");
                this._emitLine("}");
                this._emitFuncEnd(true);
                this.inBlock = true;
                var blockNames = [];
                var blocks = node.findAll(nodes.Block);
                blocks.forEach(function(block, i) {
                  var name = block.name.value;
                  if (blockNames.indexOf(name) !== -1) {
                    throw new Error('Block "' + name + '" defined more than once.');
                  }
                  blockNames.push(name);
                  _this16._emitFuncBegin(block, "b_" + name);
                  var tmpFrame = new Frame();
                  _this16._emitLine("var frame = frame.push(true);");
                  _this16.compile(block.body, tmpFrame);
                  _this16._emitFuncEnd();
                });
                this._emitLine("return {");
                blocks.forEach(function(block, i) {
                  var blockName = "b_" + block.name.value;
                  _this16._emitLine(blockName + ": " + blockName + ",");
                });
                this._emitLine("root: root\n};");
              };
              _proto.compile = function compile(node, frame) {
                var _compile = this["compile" + node.typename];
                if (_compile) {
                  _compile.call(this, node, frame);
                } else {
                  this.fail("compile: Cannot compile node: " + node.typename, node.lineno, node.colno);
                }
              };
              _proto.getCode = function getCode() {
                return this.codebuf.join("");
              };
              return Compiler2;
            }(Obj);
            module2.exports = {
              compile: function compile(src, asyncFilters, extensions, name, opts) {
                if (opts === void 0) {
                  opts = {};
                }
                var c = new Compiler(name, opts.throwOnUndefined);
                var preprocessors = (extensions || []).map(function(ext) {
                  return ext.preprocess;
                }).filter(function(f) {
                  return !!f;
                });
                var processedSrc = preprocessors.reduce(function(s, processor) {
                  return processor(s);
                }, src);
                c.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
                return c.getCode();
              },
              Compiler
            };
          },
          /* 6 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var path = __webpack_require__(4);
            var _require = __webpack_require__(1), EmitterObj = _require.EmitterObj;
            module2.exports = function(_EmitterObj) {
              _inheritsLoose(Loader, _EmitterObj);
              function Loader() {
                return _EmitterObj.apply(this, arguments) || this;
              }
              var _proto = Loader.prototype;
              _proto.resolve = function resolve(from, to) {
                return path.resolve(path.dirname(from), to);
              };
              _proto.isRelative = function isRelative(filename) {
                return filename.indexOf("./") === 0 || filename.indexOf("../") === 0;
              };
              return Loader;
            }(EmitterObj);
          },
          /* 7 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var asap = __webpack_require__(12);
            var _waterfall = __webpack_require__(15);
            var lib = __webpack_require__(0);
            var compiler = __webpack_require__(5);
            var filters = __webpack_require__(18);
            var _require = __webpack_require__(10), FileSystemLoader = _require.FileSystemLoader, WebLoader = _require.WebLoader, PrecompiledLoader = _require.PrecompiledLoader;
            var tests = __webpack_require__(20);
            var globals = __webpack_require__(21);
            var _require2 = __webpack_require__(1), Obj = _require2.Obj, EmitterObj = _require2.EmitterObj;
            var globalRuntime = __webpack_require__(2);
            var handleError = globalRuntime.handleError, Frame = globalRuntime.Frame;
            var expressApp = __webpack_require__(22);
            function callbackAsap(cb, err, res) {
              asap(function() {
                cb(err, res);
              });
            }
            var noopTmplSrc = {
              type: "code",
              obj: {
                root: function root(env, context, frame, runtime, cb) {
                  try {
                    cb(null, "");
                  } catch (e) {
                    cb(handleError(e, null, null));
                  }
                }
              }
            };
            var Environment = function(_EmitterObj) {
              _inheritsLoose(Environment2, _EmitterObj);
              function Environment2() {
                return _EmitterObj.apply(this, arguments) || this;
              }
              var _proto = Environment2.prototype;
              _proto.init = function init(loaders, opts) {
                var _this = this;
                opts = this.opts = opts || {};
                this.opts.dev = !!opts.dev;
                this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;
                this.opts.throwOnUndefined = !!opts.throwOnUndefined;
                this.opts.trimBlocks = !!opts.trimBlocks;
                this.opts.lstripBlocks = !!opts.lstripBlocks;
                this.loaders = [];
                if (!loaders) {
                  if (FileSystemLoader) {
                    this.loaders = [new FileSystemLoader("views")];
                  } else if (WebLoader) {
                    this.loaders = [new WebLoader("/views")];
                  }
                } else {
                  this.loaders = lib.isArray(loaders) ? loaders : [loaders];
                }
                if (typeof window !== "undefined" && window.nunjucksPrecompiled) {
                  this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
                }
                this._initLoaders();
                this.globals = globals();
                this.filters = {};
                this.tests = {};
                this.asyncFilters = [];
                this.extensions = {};
                this.extensionsList = [];
                lib._entries(filters).forEach(function(_ref) {
                  var name = _ref[0], filter = _ref[1];
                  return _this.addFilter(name, filter);
                });
                lib._entries(tests).forEach(function(_ref2) {
                  var name = _ref2[0], test = _ref2[1];
                  return _this.addTest(name, test);
                });
              };
              _proto._initLoaders = function _initLoaders() {
                var _this2 = this;
                this.loaders.forEach(function(loader) {
                  loader.cache = {};
                  if (typeof loader.on === "function") {
                    loader.on("update", function(name, fullname) {
                      loader.cache[name] = null;
                      _this2.emit("update", name, fullname, loader);
                    });
                    loader.on("load", function(name, source) {
                      _this2.emit("load", name, source, loader);
                    });
                  }
                });
              };
              _proto.invalidateCache = function invalidateCache() {
                this.loaders.forEach(function(loader) {
                  loader.cache = {};
                });
              };
              _proto.addExtension = function addExtension(name, extension) {
                extension.__name = name;
                this.extensions[name] = extension;
                this.extensionsList.push(extension);
                return this;
              };
              _proto.removeExtension = function removeExtension(name) {
                var extension = this.getExtension(name);
                if (!extension) {
                  return;
                }
                this.extensionsList = lib.without(this.extensionsList, extension);
                delete this.extensions[name];
              };
              _proto.getExtension = function getExtension(name) {
                return this.extensions[name];
              };
              _proto.hasExtension = function hasExtension(name) {
                return !!this.extensions[name];
              };
              _proto.addGlobal = function addGlobal(name, value) {
                this.globals[name] = value;
                return this;
              };
              _proto.getGlobal = function getGlobal(name) {
                if (typeof this.globals[name] === "undefined") {
                  throw new Error("global not found: " + name);
                }
                return this.globals[name];
              };
              _proto.addFilter = function addFilter(name, func, async) {
                var wrapped = func;
                if (async) {
                  this.asyncFilters.push(name);
                }
                this.filters[name] = wrapped;
                return this;
              };
              _proto.getFilter = function getFilter(name) {
                if (!this.filters[name]) {
                  throw new Error("filter not found: " + name);
                }
                return this.filters[name];
              };
              _proto.addTest = function addTest(name, func) {
                this.tests[name] = func;
                return this;
              };
              _proto.getTest = function getTest(name) {
                if (!this.tests[name]) {
                  throw new Error("test not found: " + name);
                }
                return this.tests[name];
              };
              _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
                var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
                return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
              };
              _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
                var _this3 = this;
                var that = this;
                var tmpl = null;
                if (name && name.raw) {
                  name = name.raw;
                }
                if (lib.isFunction(parentName)) {
                  cb = parentName;
                  parentName = null;
                  eagerCompile = eagerCompile || false;
                }
                if (lib.isFunction(eagerCompile)) {
                  cb = eagerCompile;
                  eagerCompile = false;
                }
                if (name instanceof Template) {
                  tmpl = name;
                } else if (typeof name !== "string") {
                  throw new Error("template names must be a string: " + name);
                } else {
                  for (var i = 0; i < this.loaders.length; i++) {
                    var loader = this.loaders[i];
                    tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];
                    if (tmpl) {
                      break;
                    }
                  }
                }
                if (tmpl) {
                  if (eagerCompile) {
                    tmpl.compile();
                  }
                  if (cb) {
                    cb(null, tmpl);
                    return void 0;
                  } else {
                    return tmpl;
                  }
                }
                var syncResult;
                var createTemplate = function createTemplate2(err, info) {
                  if (!info && !err && !ignoreMissing) {
                    err = new Error("template not found: " + name);
                  }
                  if (err) {
                    if (cb) {
                      cb(err);
                      return;
                    } else {
                      throw err;
                    }
                  }
                  var newTmpl;
                  if (!info) {
                    newTmpl = new Template(noopTmplSrc, _this3, "", eagerCompile);
                  } else {
                    newTmpl = new Template(info.src, _this3, info.path, eagerCompile);
                    if (!info.noCache) {
                      info.loader.cache[name] = newTmpl;
                    }
                  }
                  if (cb) {
                    cb(null, newTmpl);
                  } else {
                    syncResult = newTmpl;
                  }
                };
                lib.asyncIter(this.loaders, function(loader2, i2, next, done) {
                  function handle(err, src) {
                    if (err) {
                      done(err);
                    } else if (src) {
                      src.loader = loader2;
                      done(null, src);
                    } else {
                      next();
                    }
                  }
                  name = that.resolveTemplate(loader2, parentName, name);
                  if (loader2.async) {
                    loader2.getSource(name, handle);
                  } else {
                    handle(null, loader2.getSource(name));
                  }
                }, createTemplate);
                return syncResult;
              };
              _proto.express = function express(app) {
                return expressApp(this, app);
              };
              _proto.render = function render(name, ctx, cb) {
                if (lib.isFunction(ctx)) {
                  cb = ctx;
                  ctx = null;
                }
                var syncResult = null;
                this.getTemplate(name, function(err, tmpl) {
                  if (err && cb) {
                    callbackAsap(cb, err);
                  } else if (err) {
                    throw err;
                  } else {
                    syncResult = tmpl.render(ctx, cb);
                  }
                });
                return syncResult;
              };
              _proto.renderString = function renderString(src, ctx, opts, cb) {
                if (lib.isFunction(opts)) {
                  cb = opts;
                  opts = {};
                }
                opts = opts || {};
                var tmpl = new Template(src, this, opts.path);
                return tmpl.render(ctx, cb);
              };
              _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
                return _waterfall(tasks, callback, forceAsync);
              };
              return Environment2;
            }(EmitterObj);
            var Context = function(_Obj) {
              _inheritsLoose(Context2, _Obj);
              function Context2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto2 = Context2.prototype;
              _proto2.init = function init(ctx, blocks, env) {
                var _this4 = this;
                this.env = env || new Environment();
                this.ctx = lib.extend({}, ctx);
                this.blocks = {};
                this.exported = [];
                lib.keys(blocks).forEach(function(name) {
                  _this4.addBlock(name, blocks[name]);
                });
              };
              _proto2.lookup = function lookup(name) {
                if (name in this.env.globals && !(name in this.ctx)) {
                  return this.env.globals[name];
                } else {
                  return this.ctx[name];
                }
              };
              _proto2.setVariable = function setVariable(name, val) {
                this.ctx[name] = val;
              };
              _proto2.getVariables = function getVariables() {
                return this.ctx;
              };
              _proto2.addBlock = function addBlock(name, block) {
                this.blocks[name] = this.blocks[name] || [];
                this.blocks[name].push(block);
                return this;
              };
              _proto2.getBlock = function getBlock(name) {
                if (!this.blocks[name]) {
                  throw new Error('unknown block "' + name + '"');
                }
                return this.blocks[name][0];
              };
              _proto2.getSuper = function getSuper(env, name, block, frame, runtime, cb) {
                var idx = lib.indexOf(this.blocks[name] || [], block);
                var blk = this.blocks[name][idx + 1];
                var context = this;
                if (idx === -1 || !blk) {
                  throw new Error('no super block available for "' + name + '"');
                }
                blk(env, context, frame, runtime, cb);
              };
              _proto2.addExport = function addExport(name) {
                this.exported.push(name);
              };
              _proto2.getExported = function getExported() {
                var _this5 = this;
                var exported = {};
                this.exported.forEach(function(name) {
                  exported[name] = _this5.ctx[name];
                });
                return exported;
              };
              return Context2;
            }(Obj);
            var Template = function(_Obj2) {
              _inheritsLoose(Template2, _Obj2);
              function Template2() {
                return _Obj2.apply(this, arguments) || this;
              }
              var _proto3 = Template2.prototype;
              _proto3.init = function init(src, env, path, eagerCompile) {
                this.env = env || new Environment();
                if (lib.isObject(src)) {
                  switch (src.type) {
                    case "code":
                      this.tmplProps = src.obj;
                      break;
                    case "string":
                      this.tmplStr = src.obj;
                      break;
                    default:
                      throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
                  }
                } else if (lib.isString(src)) {
                  this.tmplStr = src;
                } else {
                  throw new Error("src must be a string or an object describing the source");
                }
                this.path = path;
                if (eagerCompile) {
                  try {
                    this._compile();
                  } catch (err) {
                    throw lib._prettifyError(this.path, this.env.opts.dev, err);
                  }
                } else {
                  this.compiled = false;
                }
              };
              _proto3.render = function render(ctx, parentFrame, cb) {
                var _this6 = this;
                if (typeof ctx === "function") {
                  cb = ctx;
                  ctx = {};
                } else if (typeof parentFrame === "function") {
                  cb = parentFrame;
                  parentFrame = null;
                }
                var forceAsync = !parentFrame;
                try {
                  this.compile();
                } catch (e) {
                  var err = lib._prettifyError(this.path, this.env.opts.dev, e);
                  if (cb) {
                    return callbackAsap(cb, err);
                  } else {
                    throw err;
                  }
                }
                var context = new Context(ctx || {}, this.blocks, this.env);
                var frame = parentFrame ? parentFrame.push(true) : new Frame();
                frame.topLevel = true;
                var syncResult = null;
                var didError = false;
                this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err2, res) {
                  if (didError && cb && typeof res !== "undefined") {
                    return;
                  }
                  if (err2) {
                    err2 = lib._prettifyError(_this6.path, _this6.env.opts.dev, err2);
                    didError = true;
                  }
                  if (cb) {
                    if (forceAsync) {
                      callbackAsap(cb, err2, res);
                    } else {
                      cb(err2, res);
                    }
                  } else {
                    if (err2) {
                      throw err2;
                    }
                    syncResult = res;
                  }
                });
                return syncResult;
              };
              _proto3.getExported = function getExported(ctx, parentFrame, cb) {
                if (typeof ctx === "function") {
                  cb = ctx;
                  ctx = {};
                }
                if (typeof parentFrame === "function") {
                  cb = parentFrame;
                  parentFrame = null;
                }
                try {
                  this.compile();
                } catch (e) {
                  if (cb) {
                    return cb(e);
                  } else {
                    throw e;
                  }
                }
                var frame = parentFrame ? parentFrame.push() : new Frame();
                frame.topLevel = true;
                var context = new Context(ctx || {}, this.blocks, this.env);
                this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err) {
                  if (err) {
                    cb(err, null);
                  } else {
                    cb(null, context.getExported());
                  }
                });
              };
              _proto3.compile = function compile() {
                if (!this.compiled) {
                  this._compile();
                }
              };
              _proto3._compile = function _compile() {
                var props;
                if (this.tmplProps) {
                  props = this.tmplProps;
                } else {
                  var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
                  var func = new Function(source);
                  props = func();
                }
                this.blocks = this._getBlocks(props);
                this.rootRenderFunc = props.root;
                this.compiled = true;
              };
              _proto3._getBlocks = function _getBlocks(props) {
                var blocks = {};
                lib.keys(props).forEach(function(k) {
                  if (k.slice(0, 2) === "b_") {
                    blocks[k.slice(2)] = props[k];
                  }
                });
                return blocks;
              };
              return Template2;
            }(Obj);
            module2.exports = {
              Environment,
              Template
            };
          },
          /* 8 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var lexer = __webpack_require__(9);
            var nodes = __webpack_require__(3);
            var Obj = __webpack_require__(1).Obj;
            var lib = __webpack_require__(0);
            var Parser = function(_Obj) {
              _inheritsLoose(Parser2, _Obj);
              function Parser2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto = Parser2.prototype;
              _proto.init = function init(tokens) {
                this.tokens = tokens;
                this.peeked = null;
                this.breakOnBlocks = null;
                this.dropLeadingWhitespace = false;
                this.extensions = [];
              };
              _proto.nextToken = function nextToken(withWhitespace) {
                var tok;
                if (this.peeked) {
                  if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
                    this.peeked = null;
                  } else {
                    tok = this.peeked;
                    this.peeked = null;
                    return tok;
                  }
                }
                tok = this.tokens.nextToken();
                if (!withWhitespace) {
                  while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
                    tok = this.tokens.nextToken();
                  }
                }
                return tok;
              };
              _proto.peekToken = function peekToken() {
                this.peeked = this.peeked || this.nextToken();
                return this.peeked;
              };
              _proto.pushToken = function pushToken(tok) {
                if (this.peeked) {
                  throw new Error("pushToken: can only push one token on between reads");
                }
                this.peeked = tok;
              };
              _proto.error = function error(msg, lineno, colno) {
                if (lineno === void 0 || colno === void 0) {
                  var tok = this.peekToken() || {};
                  lineno = tok.lineno;
                  colno = tok.colno;
                }
                if (lineno !== void 0) {
                  lineno += 1;
                }
                if (colno !== void 0) {
                  colno += 1;
                }
                return new lib.TemplateError(msg, lineno, colno);
              };
              _proto.fail = function fail(msg, lineno, colno) {
                throw this.error(msg, lineno, colno);
              };
              _proto.skip = function skip(type) {
                var tok = this.nextToken();
                if (!tok || tok.type !== type) {
                  this.pushToken(tok);
                  return false;
                }
                return true;
              };
              _proto.expect = function expect(type) {
                var tok = this.nextToken();
                if (tok.type !== type) {
                  this.fail("expected " + type + ", got " + tok.type, tok.lineno, tok.colno);
                }
                return tok;
              };
              _proto.skipValue = function skipValue(type, val) {
                var tok = this.nextToken();
                if (!tok || tok.type !== type || tok.value !== val) {
                  this.pushToken(tok);
                  return false;
                }
                return true;
              };
              _proto.skipSymbol = function skipSymbol(val) {
                return this.skipValue(lexer.TOKEN_SYMBOL, val);
              };
              _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
                var tok;
                if (!name) {
                  tok = this.peekToken();
                  if (!tok) {
                    this.fail("unexpected end of file");
                  }
                  if (tok.type !== lexer.TOKEN_SYMBOL) {
                    this.fail("advanceAfterBlockEnd: expected symbol token or explicit name to be passed");
                  }
                  name = this.nextToken().value;
                }
                tok = this.nextToken();
                if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
                  if (tok.value.charAt(0) === "-") {
                    this.dropLeadingWhitespace = true;
                  }
                } else {
                  this.fail("expected block end in " + name + " statement");
                }
                return tok;
              };
              _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
                var tok = this.nextToken();
                if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
                  this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === "-";
                } else {
                  this.pushToken(tok);
                  this.fail("expected variable end");
                }
              };
              _proto.parseFor = function parseFor() {
                var forTok = this.peekToken();
                var node;
                var endBlock;
                if (this.skipSymbol("for")) {
                  node = new nodes.For(forTok.lineno, forTok.colno);
                  endBlock = "endfor";
                } else if (this.skipSymbol("asyncEach")) {
                  node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
                  endBlock = "endeach";
                } else if (this.skipSymbol("asyncAll")) {
                  node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
                  endBlock = "endall";
                } else {
                  this.fail("parseFor: expected for{Async}", forTok.lineno, forTok.colno);
                }
                node.name = this.parsePrimary();
                if (!(node.name instanceof nodes.Symbol)) {
                  this.fail("parseFor: variable name expected for loop");
                }
                var type = this.peekToken().type;
                if (type === lexer.TOKEN_COMMA) {
                  var key = node.name;
                  node.name = new nodes.Array(key.lineno, key.colno);
                  node.name.addChild(key);
                  while (this.skip(lexer.TOKEN_COMMA)) {
                    var prim = this.parsePrimary();
                    node.name.addChild(prim);
                  }
                }
                if (!this.skipSymbol("in")) {
                  this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
                }
                node.arr = this.parseExpression();
                this.advanceAfterBlockEnd(forTok.value);
                node.body = this.parseUntilBlocks(endBlock, "else");
                if (this.skipSymbol("else")) {
                  this.advanceAfterBlockEnd("else");
                  node.else_ = this.parseUntilBlocks(endBlock);
                }
                this.advanceAfterBlockEnd();
                return node;
              };
              _proto.parseMacro = function parseMacro() {
                var macroTok = this.peekToken();
                if (!this.skipSymbol("macro")) {
                  this.fail("expected macro");
                }
                var name = this.parsePrimary(true);
                var args = this.parseSignature();
                var node = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
                this.advanceAfterBlockEnd(macroTok.value);
                node.body = this.parseUntilBlocks("endmacro");
                this.advanceAfterBlockEnd();
                return node;
              };
              _proto.parseCall = function parseCall() {
                var callTok = this.peekToken();
                if (!this.skipSymbol("call")) {
                  this.fail("expected call");
                }
                var callerArgs = this.parseSignature(true) || new nodes.NodeList();
                var macroCall = this.parsePrimary();
                this.advanceAfterBlockEnd(callTok.value);
                var body = this.parseUntilBlocks("endcall");
                this.advanceAfterBlockEnd();
                var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, "caller");
                var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body);
                var args = macroCall.args.children;
                if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
                  args.push(new nodes.KeywordArgs());
                }
                var kwargs = args[args.length - 1];
                kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
                return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
              };
              _proto.parseWithContext = function parseWithContext() {
                var tok = this.peekToken();
                var withContext = null;
                if (this.skipSymbol("with")) {
                  withContext = true;
                } else if (this.skipSymbol("without")) {
                  withContext = false;
                }
                if (withContext !== null) {
                  if (!this.skipSymbol("context")) {
                    this.fail("parseFrom: expected context after with/without", tok.lineno, tok.colno);
                  }
                }
                return withContext;
              };
              _proto.parseImport = function parseImport() {
                var importTok = this.peekToken();
                if (!this.skipSymbol("import")) {
                  this.fail("parseImport: expected import", importTok.lineno, importTok.colno);
                }
                var template = this.parseExpression();
                if (!this.skipSymbol("as")) {
                  this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
                }
                var target = this.parseExpression();
                var withContext = this.parseWithContext();
                var node = new nodes.Import(importTok.lineno, importTok.colno, template, target, withContext);
                this.advanceAfterBlockEnd(importTok.value);
                return node;
              };
              _proto.parseFrom = function parseFrom() {
                var fromTok = this.peekToken();
                if (!this.skipSymbol("from")) {
                  this.fail("parseFrom: expected from");
                }
                var template = this.parseExpression();
                if (!this.skipSymbol("import")) {
                  this.fail("parseFrom: expected import", fromTok.lineno, fromTok.colno);
                }
                var names = new nodes.NodeList();
                var withContext;
                while (1) {
                  var nextTok = this.peekToken();
                  if (nextTok.type === lexer.TOKEN_BLOCK_END) {
                    if (!names.children.length) {
                      this.fail("parseFrom: Expected at least one import name", fromTok.lineno, fromTok.colno);
                    }
                    if (nextTok.value.charAt(0) === "-") {
                      this.dropLeadingWhitespace = true;
                    }
                    this.nextToken();
                    break;
                  }
                  if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
                    this.fail("parseFrom: expected comma", fromTok.lineno, fromTok.colno);
                  }
                  var name = this.parsePrimary();
                  if (name.value.charAt(0) === "_") {
                    this.fail("parseFrom: names starting with an underscore cannot be imported", name.lineno, name.colno);
                  }
                  if (this.skipSymbol("as")) {
                    var alias = this.parsePrimary();
                    names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
                  } else {
                    names.addChild(name);
                  }
                  withContext = this.parseWithContext();
                }
                return new nodes.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
              };
              _proto.parseBlock = function parseBlock() {
                var tag = this.peekToken();
                if (!this.skipSymbol("block")) {
                  this.fail("parseBlock: expected block", tag.lineno, tag.colno);
                }
                var node = new nodes.Block(tag.lineno, tag.colno);
                node.name = this.parsePrimary();
                if (!(node.name instanceof nodes.Symbol)) {
                  this.fail("parseBlock: variable name expected", tag.lineno, tag.colno);
                }
                this.advanceAfterBlockEnd(tag.value);
                node.body = this.parseUntilBlocks("endblock");
                this.skipSymbol("endblock");
                this.skipSymbol(node.name.value);
                var tok = this.peekToken();
                if (!tok) {
                  this.fail("parseBlock: expected endblock, got end of file");
                }
                this.advanceAfterBlockEnd(tok.value);
                return node;
              };
              _proto.parseExtends = function parseExtends() {
                var tagName = "extends";
                var tag = this.peekToken();
                if (!this.skipSymbol(tagName)) {
                  this.fail("parseTemplateRef: expected " + tagName);
                }
                var node = new nodes.Extends(tag.lineno, tag.colno);
                node.template = this.parseExpression();
                this.advanceAfterBlockEnd(tag.value);
                return node;
              };
              _proto.parseInclude = function parseInclude() {
                var tagName = "include";
                var tag = this.peekToken();
                if (!this.skipSymbol(tagName)) {
                  this.fail("parseInclude: expected " + tagName);
                }
                var node = new nodes.Include(tag.lineno, tag.colno);
                node.template = this.parseExpression();
                if (this.skipSymbol("ignore") && this.skipSymbol("missing")) {
                  node.ignoreMissing = true;
                }
                this.advanceAfterBlockEnd(tag.value);
                return node;
              };
              _proto.parseIf = function parseIf() {
                var tag = this.peekToken();
                var node;
                if (this.skipSymbol("if") || this.skipSymbol("elif") || this.skipSymbol("elseif")) {
                  node = new nodes.If(tag.lineno, tag.colno);
                } else if (this.skipSymbol("ifAsync")) {
                  node = new nodes.IfAsync(tag.lineno, tag.colno);
                } else {
                  this.fail("parseIf: expected if, elif, or elseif", tag.lineno, tag.colno);
                }
                node.cond = this.parseExpression();
                this.advanceAfterBlockEnd(tag.value);
                node.body = this.parseUntilBlocks("elif", "elseif", "else", "endif");
                var tok = this.peekToken();
                switch (tok && tok.value) {
                  case "elseif":
                  case "elif":
                    node.else_ = this.parseIf();
                    break;
                  case "else":
                    this.advanceAfterBlockEnd();
                    node.else_ = this.parseUntilBlocks("endif");
                    this.advanceAfterBlockEnd();
                    break;
                  case "endif":
                    node.else_ = null;
                    this.advanceAfterBlockEnd();
                    break;
                  default:
                    this.fail("parseIf: expected elif, else, or endif, got end of file");
                }
                return node;
              };
              _proto.parseSet = function parseSet() {
                var tag = this.peekToken();
                if (!this.skipSymbol("set")) {
                  this.fail("parseSet: expected set", tag.lineno, tag.colno);
                }
                var node = new nodes.Set(tag.lineno, tag.colno, []);
                var target;
                while (target = this.parsePrimary()) {
                  node.targets.push(target);
                  if (!this.skip(lexer.TOKEN_COMMA)) {
                    break;
                  }
                }
                if (!this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
                  if (!this.skip(lexer.TOKEN_BLOCK_END)) {
                    this.fail("parseSet: expected = or block end in set tag", tag.lineno, tag.colno);
                  } else {
                    node.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks("endset"));
                    node.value = null;
                    this.advanceAfterBlockEnd();
                  }
                } else {
                  node.value = this.parseExpression();
                  this.advanceAfterBlockEnd(tag.value);
                }
                return node;
              };
              _proto.parseSwitch = function parseSwitch() {
                var switchStart = "switch";
                var switchEnd = "endswitch";
                var caseStart = "case";
                var caseDefault = "default";
                var tag = this.peekToken();
                if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
                  this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
                }
                var expr = this.parseExpression();
                this.advanceAfterBlockEnd(switchStart);
                this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
                var tok = this.peekToken();
                var cases = [];
                var defaultCase;
                do {
                  this.skipSymbol(caseStart);
                  var cond = this.parseExpression();
                  this.advanceAfterBlockEnd(switchStart);
                  var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
                  cases.push(new nodes.Case(tok.line, tok.col, cond, body));
                  tok = this.peekToken();
                } while (tok && tok.value === caseStart);
                switch (tok.value) {
                  case caseDefault:
                    this.advanceAfterBlockEnd();
                    defaultCase = this.parseUntilBlocks(switchEnd);
                    this.advanceAfterBlockEnd();
                    break;
                  case switchEnd:
                    this.advanceAfterBlockEnd();
                    break;
                  default:
                    this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
                }
                return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
              };
              _proto.parseStatement = function parseStatement() {
                var tok = this.peekToken();
                var node;
                if (tok.type !== lexer.TOKEN_SYMBOL) {
                  this.fail("tag name expected", tok.lineno, tok.colno);
                }
                if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
                  return null;
                }
                switch (tok.value) {
                  case "raw":
                    return this.parseRaw();
                  case "verbatim":
                    return this.parseRaw("verbatim");
                  case "if":
                  case "ifAsync":
                    return this.parseIf();
                  case "for":
                  case "asyncEach":
                  case "asyncAll":
                    return this.parseFor();
                  case "block":
                    return this.parseBlock();
                  case "extends":
                    return this.parseExtends();
                  case "include":
                    return this.parseInclude();
                  case "set":
                    return this.parseSet();
                  case "macro":
                    return this.parseMacro();
                  case "call":
                    return this.parseCall();
                  case "import":
                    return this.parseImport();
                  case "from":
                    return this.parseFrom();
                  case "filter":
                    return this.parseFilterStatement();
                  case "switch":
                    return this.parseSwitch();
                  default:
                    if (this.extensions.length) {
                      for (var i = 0; i < this.extensions.length; i++) {
                        var ext = this.extensions[i];
                        if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
                          return ext.parse(this, nodes, lexer);
                        }
                      }
                    }
                    this.fail("unknown block tag: " + tok.value, tok.lineno, tok.colno);
                }
                return node;
              };
              _proto.parseRaw = function parseRaw(tagName) {
                tagName = tagName || "raw";
                var endTagName = "end" + tagName;
                var rawBlockRegex = new RegExp("([\\s\\S]*?){%\\s*(" + tagName + "|" + endTagName + ")\\s*(?=%})%}");
                var rawLevel = 1;
                var str = "";
                var matches = null;
                var begun = this.advanceAfterBlockEnd();
                while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
                  var all = matches[0];
                  var pre = matches[1];
                  var blockName = matches[2];
                  if (blockName === tagName) {
                    rawLevel += 1;
                  } else if (blockName === endTagName) {
                    rawLevel -= 1;
                  }
                  if (rawLevel === 0) {
                    str += pre;
                    this.tokens.backN(all.length - pre.length);
                  } else {
                    str += all;
                  }
                }
                return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
              };
              _proto.parsePostfix = function parsePostfix(node) {
                var lookup;
                var tok = this.peekToken();
                while (tok) {
                  if (tok.type === lexer.TOKEN_LEFT_PAREN) {
                    node = new nodes.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
                  } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
                    lookup = this.parseAggregate();
                    if (lookup.children.length > 1) {
                      this.fail("invalid index");
                    }
                    node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
                  } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === ".") {
                    this.nextToken();
                    var val = this.nextToken();
                    if (val.type !== lexer.TOKEN_SYMBOL) {
                      this.fail("expected name as lookup value, got " + val.value, val.lineno, val.colno);
                    }
                    lookup = new nodes.Literal(val.lineno, val.colno, val.value);
                    node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup);
                  } else {
                    break;
                  }
                  tok = this.peekToken();
                }
                return node;
              };
              _proto.parseExpression = function parseExpression() {
                var node = this.parseInlineIf();
                return node;
              };
              _proto.parseInlineIf = function parseInlineIf() {
                var node = this.parseOr();
                if (this.skipSymbol("if")) {
                  var condNode = this.parseOr();
                  var bodyNode = node;
                  node = new nodes.InlineIf(node.lineno, node.colno);
                  node.body = bodyNode;
                  node.cond = condNode;
                  if (this.skipSymbol("else")) {
                    node.else_ = this.parseOr();
                  } else {
                    node.else_ = null;
                  }
                }
                return node;
              };
              _proto.parseOr = function parseOr() {
                var node = this.parseAnd();
                while (this.skipSymbol("or")) {
                  var node2 = this.parseAnd();
                  node = new nodes.Or(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseAnd = function parseAnd() {
                var node = this.parseNot();
                while (this.skipSymbol("and")) {
                  var node2 = this.parseNot();
                  node = new nodes.And(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseNot = function parseNot() {
                var tok = this.peekToken();
                if (this.skipSymbol("not")) {
                  return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
                }
                return this.parseIn();
              };
              _proto.parseIn = function parseIn() {
                var node = this.parseIs();
                while (1) {
                  var tok = this.nextToken();
                  if (!tok) {
                    break;
                  }
                  var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === "not";
                  if (!invert) {
                    this.pushToken(tok);
                  }
                  if (this.skipSymbol("in")) {
                    var node2 = this.parseIs();
                    node = new nodes.In(node.lineno, node.colno, node, node2);
                    if (invert) {
                      node = new nodes.Not(node.lineno, node.colno, node);
                    }
                  } else {
                    if (invert) {
                      this.pushToken(tok);
                    }
                    break;
                  }
                }
                return node;
              };
              _proto.parseIs = function parseIs() {
                var node = this.parseCompare();
                if (this.skipSymbol("is")) {
                  var not = this.skipSymbol("not");
                  var node2 = this.parseCompare();
                  node = new nodes.Is(node.lineno, node.colno, node, node2);
                  if (not) {
                    node = new nodes.Not(node.lineno, node.colno, node);
                  }
                }
                return node;
              };
              _proto.parseCompare = function parseCompare() {
                var compareOps = ["==", "===", "!=", "!==", "<", ">", "<=", ">="];
                var expr = this.parseConcat();
                var ops = [];
                while (1) {
                  var tok = this.nextToken();
                  if (!tok) {
                    break;
                  } else if (compareOps.indexOf(tok.value) !== -1) {
                    ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
                  } else {
                    this.pushToken(tok);
                    break;
                  }
                }
                if (ops.length) {
                  return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
                } else {
                  return expr;
                }
              };
              _proto.parseConcat = function parseConcat() {
                var node = this.parseAdd();
                while (this.skipValue(lexer.TOKEN_TILDE, "~")) {
                  var node2 = this.parseAdd();
                  node = new nodes.Concat(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseAdd = function parseAdd() {
                var node = this.parseSub();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
                  var node2 = this.parseSub();
                  node = new nodes.Add(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseSub = function parseSub() {
                var node = this.parseMul();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
                  var node2 = this.parseMul();
                  node = new nodes.Sub(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseMul = function parseMul() {
                var node = this.parseDiv();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "*")) {
                  var node2 = this.parseDiv();
                  node = new nodes.Mul(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseDiv = function parseDiv() {
                var node = this.parseFloorDiv();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "/")) {
                  var node2 = this.parseFloorDiv();
                  node = new nodes.Div(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseFloorDiv = function parseFloorDiv() {
                var node = this.parseMod();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "//")) {
                  var node2 = this.parseMod();
                  node = new nodes.FloorDiv(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseMod = function parseMod() {
                var node = this.parsePow();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "%")) {
                  var node2 = this.parsePow();
                  node = new nodes.Mod(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parsePow = function parsePow() {
                var node = this.parseUnary();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "**")) {
                  var node2 = this.parseUnary();
                  node = new nodes.Pow(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseUnary = function parseUnary(noFilters) {
                var tok = this.peekToken();
                var node;
                if (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
                  node = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
                } else if (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
                  node = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
                } else {
                  node = this.parsePrimary();
                }
                if (!noFilters) {
                  node = this.parseFilter(node);
                }
                return node;
              };
              _proto.parsePrimary = function parsePrimary(noPostfix) {
                var tok = this.nextToken();
                var val;
                var node = null;
                if (!tok) {
                  this.fail("expected expression, got end of file");
                } else if (tok.type === lexer.TOKEN_STRING) {
                  val = tok.value;
                } else if (tok.type === lexer.TOKEN_INT) {
                  val = parseInt(tok.value, 10);
                } else if (tok.type === lexer.TOKEN_FLOAT) {
                  val = parseFloat(tok.value);
                } else if (tok.type === lexer.TOKEN_BOOLEAN) {
                  if (tok.value === "true") {
                    val = true;
                  } else if (tok.value === "false") {
                    val = false;
                  } else {
                    this.fail("invalid boolean: " + tok.value, tok.lineno, tok.colno);
                  }
                } else if (tok.type === lexer.TOKEN_NONE) {
                  val = null;
                } else if (tok.type === lexer.TOKEN_REGEX) {
                  val = new RegExp(tok.value.body, tok.value.flags);
                }
                if (val !== void 0) {
                  node = new nodes.Literal(tok.lineno, tok.colno, val);
                } else if (tok.type === lexer.TOKEN_SYMBOL) {
                  node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
                } else {
                  this.pushToken(tok);
                  node = this.parseAggregate();
                }
                if (!noPostfix) {
                  node = this.parsePostfix(node);
                }
                if (node) {
                  return node;
                } else {
                  throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
                }
              };
              _proto.parseFilterName = function parseFilterName() {
                var tok = this.expect(lexer.TOKEN_SYMBOL);
                var name = tok.value;
                while (this.skipValue(lexer.TOKEN_OPERATOR, ".")) {
                  name += "." + this.expect(lexer.TOKEN_SYMBOL).value;
                }
                return new nodes.Symbol(tok.lineno, tok.colno, name);
              };
              _proto.parseFilterArgs = function parseFilterArgs(node) {
                if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
                  var call = this.parsePostfix(node);
                  return call.args.children;
                }
                return [];
              };
              _proto.parseFilter = function parseFilter(node) {
                while (this.skip(lexer.TOKEN_PIPE)) {
                  var name = this.parseFilterName();
                  node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node].concat(this.parseFilterArgs(node))));
                }
                return node;
              };
              _proto.parseFilterStatement = function parseFilterStatement() {
                var filterTok = this.peekToken();
                if (!this.skipSymbol("filter")) {
                  this.fail("parseFilterStatement: expected filter");
                }
                var name = this.parseFilterName();
                var args = this.parseFilterArgs(name);
                this.advanceAfterBlockEnd(filterTok.value);
                var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks("endfilter"));
                this.advanceAfterBlockEnd();
                var node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
                return new nodes.Output(name.lineno, name.colno, [node]);
              };
              _proto.parseAggregate = function parseAggregate() {
                var tok = this.nextToken();
                var node;
                switch (tok.type) {
                  case lexer.TOKEN_LEFT_PAREN:
                    node = new nodes.Group(tok.lineno, tok.colno);
                    break;
                  case lexer.TOKEN_LEFT_BRACKET:
                    node = new nodes.Array(tok.lineno, tok.colno);
                    break;
                  case lexer.TOKEN_LEFT_CURLY:
                    node = new nodes.Dict(tok.lineno, tok.colno);
                    break;
                  default:
                    return null;
                }
                while (1) {
                  var type = this.peekToken().type;
                  if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
                    this.nextToken();
                    break;
                  }
                  if (node.children.length > 0) {
                    if (!this.skip(lexer.TOKEN_COMMA)) {
                      this.fail("parseAggregate: expected comma after expression", tok.lineno, tok.colno);
                    }
                  }
                  if (node instanceof nodes.Dict) {
                    var key = this.parsePrimary();
                    if (!this.skip(lexer.TOKEN_COLON)) {
                      this.fail("parseAggregate: expected colon after dict key", tok.lineno, tok.colno);
                    }
                    var value = this.parseExpression();
                    node.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
                  } else {
                    var expr = this.parseExpression();
                    node.addChild(expr);
                  }
                }
                return node;
              };
              _proto.parseSignature = function parseSignature(tolerant, noParens) {
                var tok = this.peekToken();
                if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
                  if (tolerant) {
                    return null;
                  } else {
                    this.fail("expected arguments", tok.lineno, tok.colno);
                  }
                }
                if (tok.type === lexer.TOKEN_LEFT_PAREN) {
                  tok = this.nextToken();
                }
                var args = new nodes.NodeList(tok.lineno, tok.colno);
                var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
                var checkComma = false;
                while (1) {
                  tok = this.peekToken();
                  if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
                    this.nextToken();
                    break;
                  } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
                    break;
                  }
                  if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
                    this.fail("parseSignature: expected comma after expression", tok.lineno, tok.colno);
                  } else {
                    var arg = this.parseExpression();
                    if (this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
                      kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
                    } else {
                      args.addChild(arg);
                    }
                  }
                  checkComma = true;
                }
                if (kwargs.children.length) {
                  args.addChild(kwargs);
                }
                return args;
              };
              _proto.parseUntilBlocks = function parseUntilBlocks() {
                var prev = this.breakOnBlocks;
                for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
                  blockNames[_key] = arguments[_key];
                }
                this.breakOnBlocks = blockNames;
                var ret = this.parse();
                this.breakOnBlocks = prev;
                return ret;
              };
              _proto.parseNodes = function parseNodes() {
                var tok;
                var buf = [];
                while (tok = this.nextToken()) {
                  if (tok.type === lexer.TOKEN_DATA) {
                    var data = tok.value;
                    var nextToken = this.peekToken();
                    var nextVal = nextToken && nextToken.value;
                    if (this.dropLeadingWhitespace) {
                      data = data.replace(/^\s*/, "");
                      this.dropLeadingWhitespace = false;
                    }
                    if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === "-" || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === "-" || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === "-")) {
                      data = data.replace(/\s*$/, "");
                    }
                    buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
                  } else if (tok.type === lexer.TOKEN_BLOCK_START) {
                    this.dropLeadingWhitespace = false;
                    var n = this.parseStatement();
                    if (!n) {
                      break;
                    }
                    buf.push(n);
                  } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
                    var e = this.parseExpression();
                    this.dropLeadingWhitespace = false;
                    this.advanceAfterVariableEnd();
                    buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
                  } else if (tok.type === lexer.TOKEN_COMMENT) {
                    this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === "-";
                  } else {
                    this.fail("Unexpected token at top-level: " + tok.type, tok.lineno, tok.colno);
                  }
                }
                return buf;
              };
              _proto.parse = function parse() {
                return new nodes.NodeList(0, 0, this.parseNodes());
              };
              _proto.parseAsRoot = function parseAsRoot() {
                return new nodes.Root(0, 0, this.parseNodes());
              };
              return Parser2;
            }(Obj);
            module2.exports = {
              parse: function parse(src, extensions, opts) {
                var p = new Parser(lexer.lex(src, opts));
                if (extensions !== void 0) {
                  p.extensions = extensions;
                }
                return p.parseAsRoot();
              },
              Parser
            };
          },
          /* 9 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var whitespaceChars = " \n	\r ";
            var delimChars = "()[]{}%*-+~/#,:|.<>=!";
            var intChars = "0123456789";
            var BLOCK_START = "{%";
            var BLOCK_END = "%}";
            var VARIABLE_START = "{{";
            var VARIABLE_END = "}}";
            var COMMENT_START = "{#";
            var COMMENT_END = "#}";
            var TOKEN_STRING = "string";
            var TOKEN_WHITESPACE = "whitespace";
            var TOKEN_DATA = "data";
            var TOKEN_BLOCK_START = "block-start";
            var TOKEN_BLOCK_END = "block-end";
            var TOKEN_VARIABLE_START = "variable-start";
            var TOKEN_VARIABLE_END = "variable-end";
            var TOKEN_COMMENT = "comment";
            var TOKEN_LEFT_PAREN = "left-paren";
            var TOKEN_RIGHT_PAREN = "right-paren";
            var TOKEN_LEFT_BRACKET = "left-bracket";
            var TOKEN_RIGHT_BRACKET = "right-bracket";
            var TOKEN_LEFT_CURLY = "left-curly";
            var TOKEN_RIGHT_CURLY = "right-curly";
            var TOKEN_OPERATOR = "operator";
            var TOKEN_COMMA = "comma";
            var TOKEN_COLON = "colon";
            var TOKEN_TILDE = "tilde";
            var TOKEN_PIPE = "pipe";
            var TOKEN_INT = "int";
            var TOKEN_FLOAT = "float";
            var TOKEN_BOOLEAN = "boolean";
            var TOKEN_NONE = "none";
            var TOKEN_SYMBOL = "symbol";
            var TOKEN_SPECIAL = "special";
            var TOKEN_REGEX = "regex";
            function token(type, value, lineno, colno) {
              return {
                type,
                value,
                lineno,
                colno
              };
            }
            var Tokenizer = function() {
              function Tokenizer2(str, opts) {
                this.str = str;
                this.index = 0;
                this.len = str.length;
                this.lineno = 0;
                this.colno = 0;
                this.in_code = false;
                opts = opts || {};
                var tags = opts.tags || {};
                this.tags = {
                  BLOCK_START: tags.blockStart || BLOCK_START,
                  BLOCK_END: tags.blockEnd || BLOCK_END,
                  VARIABLE_START: tags.variableStart || VARIABLE_START,
                  VARIABLE_END: tags.variableEnd || VARIABLE_END,
                  COMMENT_START: tags.commentStart || COMMENT_START,
                  COMMENT_END: tags.commentEnd || COMMENT_END
                };
                this.trimBlocks = !!opts.trimBlocks;
                this.lstripBlocks = !!opts.lstripBlocks;
              }
              var _proto = Tokenizer2.prototype;
              _proto.nextToken = function nextToken() {
                var lineno = this.lineno;
                var colno = this.colno;
                var tok;
                if (this.in_code) {
                  var cur = this.current();
                  if (this.isFinished()) {
                    return null;
                  } else if (cur === '"' || cur === "'") {
                    return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
                  } else if (tok = this._extract(whitespaceChars)) {
                    return token(TOKEN_WHITESPACE, tok, lineno, colno);
                  } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString("-" + this.tags.BLOCK_END))) {
                    this.in_code = false;
                    if (this.trimBlocks) {
                      cur = this.current();
                      if (cur === "\n") {
                        this.forward();
                      } else if (cur === "\r") {
                        this.forward();
                        cur = this.current();
                        if (cur === "\n") {
                          this.forward();
                        } else {
                          this.back();
                        }
                      }
                    }
                    return token(TOKEN_BLOCK_END, tok, lineno, colno);
                  } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString("-" + this.tags.VARIABLE_END))) {
                    this.in_code = false;
                    return token(TOKEN_VARIABLE_END, tok, lineno, colno);
                  } else if (cur === "r" && this.str.charAt(this.index + 1) === "/") {
                    this.forwardN(2);
                    var regexBody = "";
                    while (!this.isFinished()) {
                      if (this.current() === "/" && this.previous() !== "\\") {
                        this.forward();
                        break;
                      } else {
                        regexBody += this.current();
                        this.forward();
                      }
                    }
                    var POSSIBLE_FLAGS = ["g", "i", "m", "y"];
                    var regexFlags = "";
                    while (!this.isFinished()) {
                      var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;
                      if (isCurrentAFlag) {
                        regexFlags += this.current();
                        this.forward();
                      } else {
                        break;
                      }
                    }
                    return token(TOKEN_REGEX, {
                      body: regexBody,
                      flags: regexFlags
                    }, lineno, colno);
                  } else if (delimChars.indexOf(cur) !== -1) {
                    this.forward();
                    var complexOps = ["==", "===", "!=", "!==", "<=", ">=", "//", "**"];
                    var curComplex = cur + this.current();
                    var type;
                    if (lib.indexOf(complexOps, curComplex) !== -1) {
                      this.forward();
                      cur = curComplex;
                      if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
                        cur = curComplex + this.current();
                        this.forward();
                      }
                    }
                    switch (cur) {
                      case "(":
                        type = TOKEN_LEFT_PAREN;
                        break;
                      case ")":
                        type = TOKEN_RIGHT_PAREN;
                        break;
                      case "[":
                        type = TOKEN_LEFT_BRACKET;
                        break;
                      case "]":
                        type = TOKEN_RIGHT_BRACKET;
                        break;
                      case "{":
                        type = TOKEN_LEFT_CURLY;
                        break;
                      case "}":
                        type = TOKEN_RIGHT_CURLY;
                        break;
                      case ",":
                        type = TOKEN_COMMA;
                        break;
                      case ":":
                        type = TOKEN_COLON;
                        break;
                      case "~":
                        type = TOKEN_TILDE;
                        break;
                      case "|":
                        type = TOKEN_PIPE;
                        break;
                      default:
                        type = TOKEN_OPERATOR;
                    }
                    return token(type, cur, lineno, colno);
                  } else {
                    tok = this._extractUntil(whitespaceChars + delimChars);
                    if (tok.match(/^[-+]?[0-9]+$/)) {
                      if (this.current() === ".") {
                        this.forward();
                        var dec = this._extract(intChars);
                        return token(TOKEN_FLOAT, tok + "." + dec, lineno, colno);
                      } else {
                        return token(TOKEN_INT, tok, lineno, colno);
                      }
                    } else if (tok.match(/^(true|false)$/)) {
                      return token(TOKEN_BOOLEAN, tok, lineno, colno);
                    } else if (tok === "none") {
                      return token(TOKEN_NONE, tok, lineno, colno);
                    } else if (tok === "null") {
                      return token(TOKEN_NONE, tok, lineno, colno);
                    } else if (tok) {
                      return token(TOKEN_SYMBOL, tok, lineno, colno);
                    } else {
                      throw new Error("Unexpected value while parsing: " + tok);
                    }
                  }
                } else {
                  var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);
                  if (this.isFinished()) {
                    return null;
                  } else if ((tok = this._extractString(this.tags.BLOCK_START + "-")) || (tok = this._extractString(this.tags.BLOCK_START))) {
                    this.in_code = true;
                    return token(TOKEN_BLOCK_START, tok, lineno, colno);
                  } else if ((tok = this._extractString(this.tags.VARIABLE_START + "-")) || (tok = this._extractString(this.tags.VARIABLE_START))) {
                    this.in_code = true;
                    return token(TOKEN_VARIABLE_START, tok, lineno, colno);
                  } else {
                    tok = "";
                    var data;
                    var inComment = false;
                    if (this._matches(this.tags.COMMENT_START)) {
                      inComment = true;
                      tok = this._extractString(this.tags.COMMENT_START);
                    }
                    while ((data = this._extractUntil(beginChars)) !== null) {
                      tok += data;
                      if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
                        if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
                          var lastLine = tok.slice(-this.colno);
                          if (/^\s+$/.test(lastLine)) {
                            tok = tok.slice(0, -this.colno);
                            if (!tok.length) {
                              return this.nextToken();
                            }
                          }
                        }
                        break;
                      } else if (this._matches(this.tags.COMMENT_END)) {
                        if (!inComment) {
                          throw new Error("unexpected end of comment");
                        }
                        tok += this._extractString(this.tags.COMMENT_END);
                        break;
                      } else {
                        tok += this.current();
                        this.forward();
                      }
                    }
                    if (data === null && inComment) {
                      throw new Error("expected end of comment, got end of file");
                    }
                    return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
                  }
                }
              };
              _proto._parseString = function _parseString(delimiter) {
                this.forward();
                var str = "";
                while (!this.isFinished() && this.current() !== delimiter) {
                  var cur = this.current();
                  if (cur === "\\") {
                    this.forward();
                    switch (this.current()) {
                      case "n":
                        str += "\n";
                        break;
                      case "t":
                        str += "	";
                        break;
                      case "r":
                        str += "\r";
                        break;
                      default:
                        str += this.current();
                    }
                    this.forward();
                  } else {
                    str += cur;
                    this.forward();
                  }
                }
                this.forward();
                return str;
              };
              _proto._matches = function _matches(str) {
                if (this.index + str.length > this.len) {
                  return null;
                }
                var m = this.str.slice(this.index, this.index + str.length);
                return m === str;
              };
              _proto._extractString = function _extractString(str) {
                if (this._matches(str)) {
                  this.forwardN(str.length);
                  return str;
                }
                return null;
              };
              _proto._extractUntil = function _extractUntil(charString) {
                return this._extractMatching(true, charString || "");
              };
              _proto._extract = function _extract(charString) {
                return this._extractMatching(false, charString);
              };
              _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
                if (this.isFinished()) {
                  return null;
                }
                var first = charString.indexOf(this.current());
                if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
                  var t = this.current();
                  this.forward();
                  var idx = charString.indexOf(this.current());
                  while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
                    t += this.current();
                    this.forward();
                    idx = charString.indexOf(this.current());
                  }
                  return t;
                }
                return "";
              };
              _proto._extractRegex = function _extractRegex(regex) {
                var matches = this.currentStr().match(regex);
                if (!matches) {
                  return null;
                }
                this.forwardN(matches[0].length);
                return matches;
              };
              _proto.isFinished = function isFinished() {
                return this.index >= this.len;
              };
              _proto.forwardN = function forwardN(n) {
                for (var i = 0; i < n; i++) {
                  this.forward();
                }
              };
              _proto.forward = function forward() {
                this.index++;
                if (this.previous() === "\n") {
                  this.lineno++;
                  this.colno = 0;
                } else {
                  this.colno++;
                }
              };
              _proto.backN = function backN(n) {
                for (var i = 0; i < n; i++) {
                  this.back();
                }
              };
              _proto.back = function back() {
                this.index--;
                if (this.current() === "\n") {
                  this.lineno--;
                  var idx = this.src.lastIndexOf("\n", this.index - 1);
                  if (idx === -1) {
                    this.colno = this.index;
                  } else {
                    this.colno = this.index - idx;
                  }
                } else {
                  this.colno--;
                }
              };
              _proto.current = function current() {
                if (!this.isFinished()) {
                  return this.str.charAt(this.index);
                }
                return "";
              };
              _proto.currentStr = function currentStr() {
                if (!this.isFinished()) {
                  return this.str.substr(this.index);
                }
                return "";
              };
              _proto.previous = function previous() {
                return this.str.charAt(this.index - 1);
              };
              return Tokenizer2;
            }();
            module2.exports = {
              lex: function lex(src, opts) {
                return new Tokenizer(src, opts);
              },
              TOKEN_STRING,
              TOKEN_WHITESPACE,
              TOKEN_DATA,
              TOKEN_BLOCK_START,
              TOKEN_BLOCK_END,
              TOKEN_VARIABLE_START,
              TOKEN_VARIABLE_END,
              TOKEN_COMMENT,
              TOKEN_LEFT_PAREN,
              TOKEN_RIGHT_PAREN,
              TOKEN_LEFT_BRACKET,
              TOKEN_RIGHT_BRACKET,
              TOKEN_LEFT_CURLY,
              TOKEN_RIGHT_CURLY,
              TOKEN_OPERATOR,
              TOKEN_COMMA,
              TOKEN_COLON,
              TOKEN_TILDE,
              TOKEN_PIPE,
              TOKEN_INT,
              TOKEN_FLOAT,
              TOKEN_BOOLEAN,
              TOKEN_NONE,
              TOKEN_SYMBOL,
              TOKEN_SPECIAL,
              TOKEN_REGEX
            };
          },
          /* 10 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var Loader = __webpack_require__(6);
            var _require = __webpack_require__(19), PrecompiledLoader = _require.PrecompiledLoader;
            var WebLoader = function(_Loader) {
              _inheritsLoose(WebLoader2, _Loader);
              function WebLoader2(baseURL, opts) {
                var _this;
                _this = _Loader.call(this) || this;
                _this.baseURL = baseURL || ".";
                opts = opts || {};
                _this.useCache = !!opts.useCache;
                _this.async = !!opts.async;
                return _this;
              }
              var _proto = WebLoader2.prototype;
              _proto.resolve = function resolve(from, to) {
                throw new Error("relative templates not support in the browser yet");
              };
              _proto.getSource = function getSource(name, cb) {
                var _this2 = this;
                var useCache = this.useCache;
                var result;
                this.fetch(this.baseURL + "/" + name, function(err, src) {
                  if (err) {
                    if (cb) {
                      cb(err.content);
                    } else if (err.status === 404) {
                      result = null;
                    } else {
                      throw err.content;
                    }
                  } else {
                    result = {
                      src,
                      path: name,
                      noCache: !useCache
                    };
                    _this2.emit("load", name, result);
                    if (cb) {
                      cb(null, result);
                    }
                  }
                });
                return result;
              };
              _proto.fetch = function fetch2(url, cb) {
                if (typeof window === "undefined") {
                  throw new Error("WebLoader can only by used in a browser");
                }
                var ajax = new XMLHttpRequest();
                var loading = true;
                ajax.onreadystatechange = function() {
                  if (ajax.readyState === 4 && loading) {
                    loading = false;
                    if (ajax.status === 0 || ajax.status === 200) {
                      cb(null, ajax.responseText);
                    } else {
                      cb({
                        status: ajax.status,
                        content: ajax.responseText
                      });
                    }
                  }
                };
                url += (url.indexOf("?") === -1 ? "?" : "&") + "s=" + (/* @__PURE__ */ new Date()).getTime();
                ajax.open("GET", url, this.async);
                ajax.send();
              };
              return WebLoader2;
            }(Loader);
            module2.exports = {
              WebLoader,
              PrecompiledLoader
            };
          },
          /* 11 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var _require = __webpack_require__(7), Environment = _require.Environment, Template = _require.Template;
            var Loader = __webpack_require__(6);
            var loaders = __webpack_require__(10);
            var precompile = __webpack_require__(23);
            var compiler = __webpack_require__(5);
            var parser = __webpack_require__(8);
            var lexer = __webpack_require__(9);
            var runtime = __webpack_require__(2);
            var nodes = __webpack_require__(3);
            var installJinjaCompat = __webpack_require__(25);
            var e;
            function configure(templatesPath, opts) {
              opts = opts || {};
              if (lib.isObject(templatesPath)) {
                opts = templatesPath;
                templatesPath = null;
              }
              var TemplateLoader;
              if (loaders.FileSystemLoader) {
                TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
                  watch: opts.watch,
                  noCache: opts.noCache
                });
              } else if (loaders.WebLoader) {
                TemplateLoader = new loaders.WebLoader(templatesPath, {
                  useCache: opts.web && opts.web.useCache,
                  async: opts.web && opts.web.async
                });
              }
              e = new Environment(TemplateLoader, opts);
              if (opts && opts.express) {
                e.express(opts.express);
              }
              return e;
            }
            module2.exports = {
              Environment,
              Template,
              Loader,
              FileSystemLoader: loaders.FileSystemLoader,
              NodeResolveLoader: loaders.NodeResolveLoader,
              PrecompiledLoader: loaders.PrecompiledLoader,
              WebLoader: loaders.WebLoader,
              compiler,
              parser,
              lexer,
              runtime,
              lib,
              nodes,
              installJinjaCompat,
              configure,
              reset: function reset() {
                e = void 0;
              },
              compile: function compile(src, env, path, eagerCompile) {
                if (!e) {
                  configure();
                }
                return new Template(src, env, path, eagerCompile);
              },
              render: function render(name, ctx, cb) {
                if (!e) {
                  configure();
                }
                return e.render(name, ctx, cb);
              },
              renderString: function renderString(src, ctx, cb) {
                if (!e) {
                  configure();
                }
                return e.renderString(src, ctx, cb);
              },
              precompile: precompile ? precompile.precompile : void 0,
              precompileString: precompile ? precompile.precompileString : void 0
            };
          },
          /* 12 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var rawAsap = __webpack_require__(13);
            var freeTasks = [];
            var pendingErrors = [];
            var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
            function throwFirstError() {
              if (pendingErrors.length) {
                throw pendingErrors.shift();
              }
            }
            module2.exports = asap;
            function asap(task) {
              var rawTask;
              if (freeTasks.length) {
                rawTask = freeTasks.pop();
              } else {
                rawTask = new RawTask();
              }
              rawTask.task = task;
              rawAsap(rawTask);
            }
            function RawTask() {
              this.task = null;
            }
            RawTask.prototype.call = function() {
              try {
                this.task.call();
              } catch (error) {
                if (asap.onerror) {
                  asap.onerror(error);
                } else {
                  pendingErrors.push(error);
                  requestErrorThrow();
                }
              } finally {
                this.task = null;
                freeTasks[freeTasks.length] = this;
              }
            };
          },
          /* 13 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            (function(global) {
              module2.exports = rawAsap;
              function rawAsap(task) {
                if (!queue.length) {
                  requestFlush();
                  flushing = true;
                }
                queue[queue.length] = task;
              }
              var queue = [];
              var flushing = false;
              var requestFlush;
              var index = 0;
              var capacity = 1024;
              function flush() {
                while (index < queue.length) {
                  var currentIndex = index;
                  index = index + 1;
                  queue[currentIndex].call();
                  if (index > capacity) {
                    for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                      queue[scan] = queue[scan + index];
                    }
                    queue.length -= index;
                    index = 0;
                  }
                }
                queue.length = 0;
                index = 0;
                flushing = false;
              }
              var scope = typeof global !== "undefined" ? global : self;
              var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
              if (typeof BrowserMutationObserver === "function") {
                requestFlush = makeRequestCallFromMutationObserver(flush);
              } else {
                requestFlush = makeRequestCallFromTimer(flush);
              }
              rawAsap.requestFlush = requestFlush;
              function makeRequestCallFromMutationObserver(callback) {
                var toggle = 1;
                var observer = new BrowserMutationObserver(callback);
                var node = document.createTextNode("");
                observer.observe(node, { characterData: true });
                return function requestCall() {
                  toggle = -toggle;
                  node.data = toggle;
                };
              }
              function makeRequestCallFromTimer(callback) {
                return function requestCall() {
                  var timeoutHandle = setTimeout(handleTimer, 0);
                  var intervalHandle = setInterval(handleTimer, 50);
                  function handleTimer() {
                    clearTimeout(timeoutHandle);
                    clearInterval(intervalHandle);
                    callback();
                  }
                };
              }
              rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
            }).call(exports2, __webpack_require__(14));
          },
          /* 14 */
          /***/
          function(module2, exports2) {
            var g;
            g = /* @__PURE__ */ function() {
              return this;
            }();
            try {
              g = g || Function("return this")() || (1, eval)("this");
            } catch (e) {
              if (typeof window === "object")
                g = window;
            }
            module2.exports = g;
          },
          /* 15 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function(globals) {
              "use strict";
              var executeSync = function() {
                var args = Array.prototype.slice.call(arguments);
                if (typeof args[0] === "function") {
                  args[0].apply(null, args.splice(1));
                }
              };
              var executeAsync = function(fn) {
                if (typeof setImmediate === "function") {
                  setImmediate(fn);
                } else if (typeof process !== "undefined" && process.nextTick) {
                  process.nextTick(fn);
                } else {
                  setTimeout(fn, 0);
                }
              };
              var makeIterator = function(tasks) {
                var makeCallback = function(index) {
                  var fn = function() {
                    if (tasks.length) {
                      tasks[index].apply(null, arguments);
                    }
                    return fn.next();
                  };
                  fn.next = function() {
                    return index < tasks.length - 1 ? makeCallback(index + 1) : null;
                  };
                  return fn;
                };
                return makeCallback(0);
              };
              var _isArray = Array.isArray || function(maybeArray) {
                return Object.prototype.toString.call(maybeArray) === "[object Array]";
              };
              var waterfall = function(tasks, callback, forceAsync) {
                var nextTick = forceAsync ? executeAsync : executeSync;
                callback = callback || function() {
                };
                if (!_isArray(tasks)) {
                  var err = new Error("First argument to waterfall must be an array of functions");
                  return callback(err);
                }
                if (!tasks.length) {
                  return callback();
                }
                var wrapIterator = function(iterator) {
                  return function(err2) {
                    if (err2) {
                      callback.apply(null, arguments);
                      callback = function() {
                      };
                    } else {
                      var args = Array.prototype.slice.call(arguments, 1);
                      var next = iterator.next();
                      if (next) {
                        args.push(wrapIterator(next));
                      } else {
                        args.push(callback);
                      }
                      nextTick(function() {
                        iterator.apply(null, args);
                      });
                    }
                  };
                };
                wrapIterator(makeIterator(tasks))();
              };
              if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                  return waterfall;
                }).apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else if (typeof module2 !== "undefined" && module2.exports) {
                module2.exports = waterfall;
              } else {
                globals.waterfall = waterfall;
              }
            })(this);
          },
          /* 16 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var R = typeof Reflect === "object" ? Reflect : null;
            var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
              return Function.prototype.apply.call(target, receiver, args);
            };
            var ReflectOwnKeys;
            if (R && typeof R.ownKeys === "function") {
              ReflectOwnKeys = R.ownKeys;
            } else if (Object.getOwnPropertySymbols) {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
              };
            } else {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target);
              };
            }
            function ProcessEmitWarning(warning) {
              if (console && console.warn) console.warn(warning);
            }
            var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
              return value !== value;
            };
            function EventEmitter() {
              EventEmitter.init.call(this);
            }
            module2.exports = EventEmitter;
            module2.exports.once = once;
            EventEmitter.EventEmitter = EventEmitter;
            EventEmitter.prototype._events = void 0;
            EventEmitter.prototype._eventsCount = 0;
            EventEmitter.prototype._maxListeners = void 0;
            var defaultMaxListeners = 10;
            function checkListener(listener) {
              if (typeof listener !== "function") {
                throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
              }
            }
            Object.defineProperty(EventEmitter, "defaultMaxListeners", {
              enumerable: true,
              get: function() {
                return defaultMaxListeners;
              },
              set: function(arg) {
                if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                  throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                }
                defaultMaxListeners = arg;
              }
            });
            EventEmitter.init = function() {
              if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
              }
              this._maxListeners = this._maxListeners || void 0;
            };
            EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
              if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
              }
              this._maxListeners = n;
              return this;
            };
            function _getMaxListeners(that) {
              if (that._maxListeners === void 0)
                return EventEmitter.defaultMaxListeners;
              return that._maxListeners;
            }
            EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
              return _getMaxListeners(this);
            };
            EventEmitter.prototype.emit = function emit(type) {
              var args = [];
              for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
              var doError = type === "error";
              var events = this._events;
              if (events !== void 0)
                doError = doError && events.error === void 0;
              else if (!doError)
                return false;
              if (doError) {
                var er;
                if (args.length > 0)
                  er = args[0];
                if (er instanceof Error) {
                  throw er;
                }
                var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                err.context = er;
                throw err;
              }
              var handler = events[type];
              if (handler === void 0)
                return false;
              if (typeof handler === "function") {
                ReflectApply(handler, this, args);
              } else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                  ReflectApply(listeners[i], this, args);
              }
              return true;
            };
            function _addListener(target, type, listener, prepend) {
              var m;
              var events;
              var existing;
              checkListener(listener);
              events = target._events;
              if (events === void 0) {
                events = target._events = /* @__PURE__ */ Object.create(null);
                target._eventsCount = 0;
              } else {
                if (events.newListener !== void 0) {
                  target.emit(
                    "newListener",
                    type,
                    listener.listener ? listener.listener : listener
                  );
                  events = target._events;
                }
                existing = events[type];
              }
              if (existing === void 0) {
                existing = events[type] = listener;
                ++target._eventsCount;
              } else {
                if (typeof existing === "function") {
                  existing = events[type] = prepend ? [listener, existing] : [existing, listener];
                } else if (prepend) {
                  existing.unshift(listener);
                } else {
                  existing.push(listener);
                }
                m = _getMaxListeners(target);
                if (m > 0 && existing.length > m && !existing.warned) {
                  existing.warned = true;
                  var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                  w.name = "MaxListenersExceededWarning";
                  w.emitter = target;
                  w.type = type;
                  w.count = existing.length;
                  ProcessEmitWarning(w);
                }
              }
              return target;
            }
            EventEmitter.prototype.addListener = function addListener(type, listener) {
              return _addListener(this, type, listener, false);
            };
            EventEmitter.prototype.on = EventEmitter.prototype.addListener;
            EventEmitter.prototype.prependListener = function prependListener(type, listener) {
              return _addListener(this, type, listener, true);
            };
            function onceWrapper() {
              if (!this.fired) {
                this.target.removeListener(this.type, this.wrapFn);
                this.fired = true;
                if (arguments.length === 0)
                  return this.listener.call(this.target);
                return this.listener.apply(this.target, arguments);
              }
            }
            function _onceWrap(target, type, listener) {
              var state = { fired: false, wrapFn: void 0, target, type, listener };
              var wrapped = onceWrapper.bind(state);
              wrapped.listener = listener;
              state.wrapFn = wrapped;
              return wrapped;
            }
            EventEmitter.prototype.once = function once2(type, listener) {
              checkListener(listener);
              this.on(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
              checkListener(listener);
              this.prependListener(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.removeListener = function removeListener(type, listener) {
              var list, events, position, i, originalListener;
              checkListener(listener);
              events = this._events;
              if (events === void 0)
                return this;
              list = events[type];
              if (list === void 0)
                return this;
              if (list === listener || list.listener === listener) {
                if (--this._eventsCount === 0)
                  this._events = /* @__PURE__ */ Object.create(null);
                else {
                  delete events[type];
                  if (events.removeListener)
                    this.emit("removeListener", type, list.listener || listener);
                }
              } else if (typeof list !== "function") {
                position = -1;
                for (i = list.length - 1; i >= 0; i--) {
                  if (list[i] === listener || list[i].listener === listener) {
                    originalListener = list[i].listener;
                    position = i;
                    break;
                  }
                }
                if (position < 0)
                  return this;
                if (position === 0)
                  list.shift();
                else {
                  spliceOne(list, position);
                }
                if (list.length === 1)
                  events[type] = list[0];
                if (events.removeListener !== void 0)
                  this.emit("removeListener", type, originalListener || listener);
              }
              return this;
            };
            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
            EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
              var listeners, events, i;
              events = this._events;
              if (events === void 0)
                return this;
              if (events.removeListener === void 0) {
                if (arguments.length === 0) {
                  this._events = /* @__PURE__ */ Object.create(null);
                  this._eventsCount = 0;
                } else if (events[type] !== void 0) {
                  if (--this._eventsCount === 0)
                    this._events = /* @__PURE__ */ Object.create(null);
                  else
                    delete events[type];
                }
                return this;
              }
              if (arguments.length === 0) {
                var keys = Object.keys(events);
                var key;
                for (i = 0; i < keys.length; ++i) {
                  key = keys[i];
                  if (key === "removeListener") continue;
                  this.removeAllListeners(key);
                }
                this.removeAllListeners("removeListener");
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
                return this;
              }
              listeners = events[type];
              if (typeof listeners === "function") {
                this.removeListener(type, listeners);
              } else if (listeners !== void 0) {
                for (i = listeners.length - 1; i >= 0; i--) {
                  this.removeListener(type, listeners[i]);
                }
              }
              return this;
            };
            function _listeners(target, type, unwrap) {
              var events = target._events;
              if (events === void 0)
                return [];
              var evlistener = events[type];
              if (evlistener === void 0)
                return [];
              if (typeof evlistener === "function")
                return unwrap ? [evlistener.listener || evlistener] : [evlistener];
              return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
            }
            EventEmitter.prototype.listeners = function listeners(type) {
              return _listeners(this, type, true);
            };
            EventEmitter.prototype.rawListeners = function rawListeners(type) {
              return _listeners(this, type, false);
            };
            EventEmitter.listenerCount = function(emitter, type) {
              if (typeof emitter.listenerCount === "function") {
                return emitter.listenerCount(type);
              } else {
                return listenerCount.call(emitter, type);
              }
            };
            EventEmitter.prototype.listenerCount = listenerCount;
            function listenerCount(type) {
              var events = this._events;
              if (events !== void 0) {
                var evlistener = events[type];
                if (typeof evlistener === "function") {
                  return 1;
                } else if (evlistener !== void 0) {
                  return evlistener.length;
                }
              }
              return 0;
            }
            EventEmitter.prototype.eventNames = function eventNames() {
              return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
            };
            function arrayClone(arr, n) {
              var copy = new Array(n);
              for (var i = 0; i < n; ++i)
                copy[i] = arr[i];
              return copy;
            }
            function spliceOne(list, index) {
              for (; index + 1 < list.length; index++)
                list[index] = list[index + 1];
              list.pop();
            }
            function unwrapListeners(arr) {
              var ret = new Array(arr.length);
              for (var i = 0; i < ret.length; ++i) {
                ret[i] = arr[i].listener || arr[i];
              }
              return ret;
            }
            function once(emitter, name) {
              return new Promise(function(resolve, reject) {
                function errorListener(err) {
                  emitter.removeListener(name, resolver);
                  reject(err);
                }
                function resolver() {
                  if (typeof emitter.removeListener === "function") {
                    emitter.removeListener("error", errorListener);
                  }
                  resolve([].slice.call(arguments));
                }
                ;
                eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
                if (name !== "error") {
                  addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                }
              });
            }
            function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
              if (typeof emitter.on === "function") {
                eventTargetAgnosticAddListener(emitter, "error", handler, flags);
              }
            }
            function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
              if (typeof emitter.on === "function") {
                if (flags.once) {
                  emitter.once(name, listener);
                } else {
                  emitter.on(name, listener);
                }
              } else if (typeof emitter.addEventListener === "function") {
                emitter.addEventListener(name, function wrapListener(arg) {
                  if (flags.once) {
                    emitter.removeEventListener(name, wrapListener);
                  }
                  listener(arg);
                });
              } else {
                throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
              }
            }
          },
          /* 17 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var nodes = __webpack_require__(3);
            var lib = __webpack_require__(0);
            var sym = 0;
            function gensym() {
              return "hole_" + sym++;
            }
            function mapCOW(arr, func) {
              var res = null;
              for (var i = 0; i < arr.length; i++) {
                var item = func(arr[i]);
                if (item !== arr[i]) {
                  if (!res) {
                    res = arr.slice();
                  }
                  res[i] = item;
                }
              }
              return res || arr;
            }
            function walk(ast, func, depthFirst) {
              if (!(ast instanceof nodes.Node)) {
                return ast;
              }
              if (!depthFirst) {
                var astT = func(ast);
                if (astT && astT !== ast) {
                  return astT;
                }
              }
              if (ast instanceof nodes.NodeList) {
                var children = mapCOW(ast.children, function(node) {
                  return walk(node, func, depthFirst);
                });
                if (children !== ast.children) {
                  ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
                }
              } else if (ast instanceof nodes.CallExtension) {
                var args = walk(ast.args, func, depthFirst);
                var contentArgs = mapCOW(ast.contentArgs, function(node) {
                  return walk(node, func, depthFirst);
                });
                if (args !== ast.args || contentArgs !== ast.contentArgs) {
                  ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
                }
              } else {
                var props = ast.fields.map(function(field) {
                  return ast[field];
                });
                var propsT = mapCOW(props, function(prop) {
                  return walk(prop, func, depthFirst);
                });
                if (propsT !== props) {
                  ast = new nodes[ast.typename](ast.lineno, ast.colno);
                  propsT.forEach(function(prop, i) {
                    ast[ast.fields[i]] = prop;
                  });
                }
              }
              return depthFirst ? func(ast) || ast : ast;
            }
            function depthWalk(ast, func) {
              return walk(ast, func, true);
            }
            function _liftFilters(node, asyncFilters, prop) {
              var children = [];
              var walked = depthWalk(prop ? node[prop] : node, function(descNode) {
                var symbol;
                if (descNode instanceof nodes.Block) {
                  return descNode;
                } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
                  symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
                  children.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
                }
                return symbol;
              });
              if (prop) {
                node[prop] = walked;
              } else {
                node = walked;
              }
              if (children.length) {
                children.push(node);
                return new nodes.NodeList(node.lineno, node.colno, children);
              } else {
                return node;
              }
            }
            function liftFilters(ast, asyncFilters) {
              return depthWalk(ast, function(node) {
                if (node instanceof nodes.Output) {
                  return _liftFilters(node, asyncFilters);
                } else if (node instanceof nodes.Set) {
                  return _liftFilters(node, asyncFilters, "value");
                } else if (node instanceof nodes.For) {
                  return _liftFilters(node, asyncFilters, "arr");
                } else if (node instanceof nodes.If) {
                  return _liftFilters(node, asyncFilters, "cond");
                } else if (node instanceof nodes.CallExtension) {
                  return _liftFilters(node, asyncFilters, "args");
                } else {
                  return void 0;
                }
              });
            }
            function liftSuper(ast) {
              return walk(ast, function(blockNode) {
                if (!(blockNode instanceof nodes.Block)) {
                  return;
                }
                var hasSuper = false;
                var symbol = gensym();
                blockNode.body = walk(blockNode.body, function(node) {
                  if (node instanceof nodes.FunCall && node.name.value === "super") {
                    hasSuper = true;
                    return new nodes.Symbol(node.lineno, node.colno, symbol);
                  }
                });
                if (hasSuper) {
                  blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
                }
              });
            }
            function convertStatements(ast) {
              return depthWalk(ast, function(node) {
                if (!(node instanceof nodes.If) && !(node instanceof nodes.For)) {
                  return void 0;
                }
                var async = false;
                walk(node, function(child) {
                  if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
                    async = true;
                    return child;
                  }
                  return void 0;
                });
                if (async) {
                  if (node instanceof nodes.If) {
                    return new nodes.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
                  } else if (node instanceof nodes.For && !(node instanceof nodes.AsyncAll)) {
                    return new nodes.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
                  }
                }
                return void 0;
              });
            }
            function cps(ast, asyncFilters) {
              return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
            }
            function transform(ast, asyncFilters) {
              return cps(ast, asyncFilters || []);
            }
            module2.exports = {
              transform
            };
          },
          /* 18 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var r = __webpack_require__(2);
            var exports2 = module2.exports = {};
            function normalize(value, defaultValue) {
              if (value === null || value === void 0 || value === false) {
                return defaultValue;
              }
              return value;
            }
            exports2.abs = Math.abs;
            function isNaN2(num) {
              return num !== num;
            }
            function batch(arr, linecount, fillWith) {
              var i;
              var res = [];
              var tmp = [];
              for (i = 0; i < arr.length; i++) {
                if (i % linecount === 0 && tmp.length) {
                  res.push(tmp);
                  tmp = [];
                }
                tmp.push(arr[i]);
              }
              if (tmp.length) {
                if (fillWith) {
                  for (i = tmp.length; i < linecount; i++) {
                    tmp.push(fillWith);
                  }
                }
                res.push(tmp);
              }
              return res;
            }
            exports2.batch = batch;
            function capitalize(str) {
              str = normalize(str, "");
              var ret = str.toLowerCase();
              return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
            }
            exports2.capitalize = capitalize;
            function center(str, width) {
              str = normalize(str, "");
              width = width || 80;
              if (str.length >= width) {
                return str;
              }
              var spaces = width - str.length;
              var pre = lib.repeat(" ", spaces / 2 - spaces % 2);
              var post = lib.repeat(" ", spaces / 2);
              return r.copySafeness(str, pre + str + post);
            }
            exports2.center = center;
            function default_(val, def, bool) {
              if (bool) {
                return val || def;
              } else {
                return val !== void 0 ? val : def;
              }
            }
            exports2["default"] = default_;
            function dictsort(val, caseSensitive, by) {
              if (!lib.isObject(val)) {
                throw new lib.TemplateError("dictsort filter: val must be an object");
              }
              var array = [];
              for (var k in val) {
                array.push([k, val[k]]);
              }
              var si;
              if (by === void 0 || by === "key") {
                si = 0;
              } else if (by === "value") {
                si = 1;
              } else {
                throw new lib.TemplateError("dictsort filter: You can only sort by either key or value");
              }
              array.sort(function(t1, t2) {
                var a = t1[si];
                var b = t2[si];
                if (!caseSensitive) {
                  if (lib.isString(a)) {
                    a = a.toUpperCase();
                  }
                  if (lib.isString(b)) {
                    b = b.toUpperCase();
                  }
                }
                return a > b ? 1 : a === b ? 0 : -1;
              });
              return array;
            }
            exports2.dictsort = dictsort;
            function dump(obj, spaces) {
              return JSON.stringify(obj, null, spaces);
            }
            exports2.dump = dump;
            function escape(str) {
              if (str instanceof r.SafeString) {
                return str;
              }
              str = str === null || str === void 0 ? "" : str;
              return r.markSafe(lib.escape(str.toString()));
            }
            exports2.escape = escape;
            function safe(str) {
              if (str instanceof r.SafeString) {
                return str;
              }
              str = str === null || str === void 0 ? "" : str;
              return r.markSafe(str.toString());
            }
            exports2.safe = safe;
            function first(arr) {
              return arr[0];
            }
            exports2.first = first;
            function forceescape(str) {
              str = str === null || str === void 0 ? "" : str;
              return r.markSafe(lib.escape(str.toString()));
            }
            exports2.forceescape = forceescape;
            function groupby(arr, attr) {
              return lib.groupBy(arr, attr, this.env.opts.throwOnUndefined);
            }
            exports2.groupby = groupby;
            function indent(str, width, indentfirst) {
              str = normalize(str, "");
              if (str === "") {
                return "";
              }
              width = width || 4;
              var lines = str.split("\n");
              var sp = lib.repeat(" ", width);
              var res = lines.map(function(l, i) {
                return i === 0 && !indentfirst ? l : "" + sp + l;
              }).join("\n");
              return r.copySafeness(str, res);
            }
            exports2.indent = indent;
            function join(arr, del, attr) {
              del = del || "";
              if (attr) {
                arr = lib.map(arr, function(v) {
                  return v[attr];
                });
              }
              return arr.join(del);
            }
            exports2.join = join;
            function last(arr) {
              return arr[arr.length - 1];
            }
            exports2.last = last;
            function lengthFilter(val) {
              var value = normalize(val, "");
              if (value !== void 0) {
                if (typeof Map === "function" && value instanceof Map || typeof Set === "function" && value instanceof Set) {
                  return value.size;
                }
                if (lib.isObject(value) && !(value instanceof r.SafeString)) {
                  return lib.keys(value).length;
                }
                return value.length;
              }
              return 0;
            }
            exports2.length = lengthFilter;
            function list(val) {
              if (lib.isString(val)) {
                return val.split("");
              } else if (lib.isObject(val)) {
                return lib._entries(val || {}).map(function(_ref) {
                  var key = _ref[0], value = _ref[1];
                  return {
                    key,
                    value
                  };
                });
              } else if (lib.isArray(val)) {
                return val;
              } else {
                throw new lib.TemplateError("list filter: type not iterable");
              }
            }
            exports2.list = list;
            function lower(str) {
              str = normalize(str, "");
              return str.toLowerCase();
            }
            exports2.lower = lower;
            function nl2br(str) {
              if (str === null || str === void 0) {
                return "";
              }
              return r.copySafeness(str, str.replace(/\r\n|\n/g, "<br />\n"));
            }
            exports2.nl2br = nl2br;
            function random(arr) {
              return arr[Math.floor(Math.random() * arr.length)];
            }
            exports2.random = random;
            function getSelectOrReject(expectedTestResult) {
              function filter(arr, testName, secondArg) {
                if (testName === void 0) {
                  testName = "truthy";
                }
                var context = this;
                var test = context.env.getTest(testName);
                return lib.toArray(arr).filter(function examineTestResult(item) {
                  return test.call(context, item, secondArg) === expectedTestResult;
                });
              }
              return filter;
            }
            exports2.reject = getSelectOrReject(false);
            function rejectattr(arr, attr) {
              return arr.filter(function(item) {
                return !item[attr];
              });
            }
            exports2.rejectattr = rejectattr;
            exports2.select = getSelectOrReject(true);
            function selectattr(arr, attr) {
              return arr.filter(function(item) {
                return !!item[attr];
              });
            }
            exports2.selectattr = selectattr;
            function replace(str, old, new_, maxCount) {
              var originalStr = str;
              if (old instanceof RegExp) {
                return str.replace(old, new_);
              }
              if (typeof maxCount === "undefined") {
                maxCount = -1;
              }
              var res = "";
              if (typeof old === "number") {
                old = "" + old;
              } else if (typeof old !== "string") {
                return str;
              }
              if (typeof str === "number") {
                str = "" + str;
              }
              if (typeof str !== "string" && !(str instanceof r.SafeString)) {
                return str;
              }
              if (old === "") {
                res = new_ + str.split("").join(new_) + new_;
                return r.copySafeness(str, res);
              }
              var nextIndex = str.indexOf(old);
              if (maxCount === 0 || nextIndex === -1) {
                return str;
              }
              var pos = 0;
              var count = 0;
              while (nextIndex > -1 && (maxCount === -1 || count < maxCount)) {
                res += str.substring(pos, nextIndex) + new_;
                pos = nextIndex + old.length;
                count++;
                nextIndex = str.indexOf(old, pos);
              }
              if (pos < str.length) {
                res += str.substring(pos);
              }
              return r.copySafeness(originalStr, res);
            }
            exports2.replace = replace;
            function reverse(val) {
              var arr;
              if (lib.isString(val)) {
                arr = list(val);
              } else {
                arr = lib.map(val, function(v) {
                  return v;
                });
              }
              arr.reverse();
              if (lib.isString(val)) {
                return r.copySafeness(val, arr.join(""));
              }
              return arr;
            }
            exports2.reverse = reverse;
            function round(val, precision, method) {
              precision = precision || 0;
              var factor = Math.pow(10, precision);
              var rounder;
              if (method === "ceil") {
                rounder = Math.ceil;
              } else if (method === "floor") {
                rounder = Math.floor;
              } else {
                rounder = Math.round;
              }
              return rounder(val * factor) / factor;
            }
            exports2.round = round;
            function slice(arr, slices, fillWith) {
              var sliceLength = Math.floor(arr.length / slices);
              var extra = arr.length % slices;
              var res = [];
              var offset = 0;
              for (var i = 0; i < slices; i++) {
                var start = offset + i * sliceLength;
                if (i < extra) {
                  offset++;
                }
                var end = offset + (i + 1) * sliceLength;
                var currSlice = arr.slice(start, end);
                if (fillWith && i >= extra) {
                  currSlice.push(fillWith);
                }
                res.push(currSlice);
              }
              return res;
            }
            exports2.slice = slice;
            function sum(arr, attr, start) {
              if (start === void 0) {
                start = 0;
              }
              if (attr) {
                arr = lib.map(arr, function(v) {
                  return v[attr];
                });
              }
              return start + arr.reduce(function(a, b) {
                return a + b;
              }, 0);
            }
            exports2.sum = sum;
            exports2.sort = r.makeMacro(["value", "reverse", "case_sensitive", "attribute"], [], function sortFilter(arr, reversed, caseSens, attr) {
              var _this = this;
              var array = lib.map(arr, function(v) {
                return v;
              });
              var getAttribute = lib.getAttrGetter(attr);
              array.sort(function(a, b) {
                var x = attr ? getAttribute(a) : a;
                var y = attr ? getAttribute(b) : b;
                if (_this.env.opts.throwOnUndefined && attr && (x === void 0 || y === void 0)) {
                  throw new TypeError('sort: attribute "' + attr + '" resolved to undefined');
                }
                if (!caseSens && lib.isString(x) && lib.isString(y)) {
                  x = x.toLowerCase();
                  y = y.toLowerCase();
                }
                if (x < y) {
                  return reversed ? 1 : -1;
                } else if (x > y) {
                  return reversed ? -1 : 1;
                } else {
                  return 0;
                }
              });
              return array;
            });
            function string(obj) {
              return r.copySafeness(obj, obj);
            }
            exports2.string = string;
            function striptags(input, preserveLinebreaks) {
              input = normalize(input, "");
              var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
              var trimmedInput = trim(input.replace(tags, ""));
              var res = "";
              if (preserveLinebreaks) {
                res = trimmedInput.replace(/^ +| +$/gm, "").replace(/ +/g, " ").replace(/(\r\n)/g, "\n").replace(/\n\n\n+/g, "\n\n");
              } else {
                res = trimmedInput.replace(/\s+/gi, " ");
              }
              return r.copySafeness(input, res);
            }
            exports2.striptags = striptags;
            function title(str) {
              str = normalize(str, "");
              var words = str.split(" ").map(function(word) {
                return capitalize(word);
              });
              return r.copySafeness(str, words.join(" "));
            }
            exports2.title = title;
            function trim(str) {
              return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ""));
            }
            exports2.trim = trim;
            function truncate(input, length, killwords, end) {
              var orig = input;
              input = normalize(input, "");
              length = length || 255;
              if (input.length <= length) {
                return input;
              }
              if (killwords) {
                input = input.substring(0, length);
              } else {
                var idx = input.lastIndexOf(" ", length);
                if (idx === -1) {
                  idx = length;
                }
                input = input.substring(0, idx);
              }
              input += end !== void 0 && end !== null ? end : "...";
              return r.copySafeness(orig, input);
            }
            exports2.truncate = truncate;
            function upper(str) {
              str = normalize(str, "");
              return str.toUpperCase();
            }
            exports2.upper = upper;
            function urlencode(obj) {
              var enc = encodeURIComponent;
              if (lib.isString(obj)) {
                return enc(obj);
              } else {
                var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
                return keyvals.map(function(_ref2) {
                  var k = _ref2[0], v = _ref2[1];
                  return enc(k) + "=" + enc(v);
                }).join("&");
              }
            }
            exports2.urlencode = urlencode;
            var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/;
            var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
            var httpHttpsRe = /^https?:\/\/.*$/;
            var wwwRe = /^www\./;
            var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;
            function urlize(str, length, nofollow) {
              if (isNaN2(length)) {
                length = Infinity;
              }
              var noFollowAttr = nofollow === true ? ' rel="nofollow"' : "";
              var words = str.split(/(\s+)/).filter(function(word) {
                return word && word.length;
              }).map(function(word) {
                var matches = word.match(puncRe);
                var possibleUrl = matches ? matches[1] : word;
                var shortUrl = possibleUrl.substr(0, length);
                if (httpHttpsRe.test(possibleUrl)) {
                  return '<a href="' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
                }
                if (wwwRe.test(possibleUrl)) {
                  return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
                }
                if (emailRe.test(possibleUrl)) {
                  return '<a href="mailto:' + possibleUrl + '">' + possibleUrl + "</a>";
                }
                if (tldRe.test(possibleUrl)) {
                  return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
                }
                return word;
              });
              return words.join("");
            }
            exports2.urlize = urlize;
            function wordcount(str) {
              str = normalize(str, "");
              var words = str ? str.match(/\w+/g) : null;
              return words ? words.length : null;
            }
            exports2.wordcount = wordcount;
            function float(val, def) {
              var res = parseFloat(val);
              return isNaN2(res) ? def : res;
            }
            exports2.float = float;
            var intFilter = r.makeMacro(["value", "default", "base"], [], function doInt(value, defaultValue, base) {
              if (base === void 0) {
                base = 10;
              }
              var res = parseInt(value, base);
              return isNaN2(res) ? defaultValue : res;
            });
            exports2.int = intFilter;
            exports2.d = exports2.default;
            exports2.e = exports2.escape;
          },
          /* 19 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var Loader = __webpack_require__(6);
            var PrecompiledLoader = function(_Loader) {
              _inheritsLoose(PrecompiledLoader2, _Loader);
              function PrecompiledLoader2(compiledTemplates) {
                var _this;
                _this = _Loader.call(this) || this;
                _this.precompiled = compiledTemplates || {};
                return _this;
              }
              var _proto = PrecompiledLoader2.prototype;
              _proto.getSource = function getSource(name) {
                if (this.precompiled[name]) {
                  return {
                    src: {
                      type: "code",
                      obj: this.precompiled[name]
                    },
                    path: name
                  };
                }
                return null;
              };
              return PrecompiledLoader2;
            }(Loader);
            module2.exports = {
              PrecompiledLoader
            };
          },
          /* 20 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var SafeString = __webpack_require__(2).SafeString;
            function callable(value) {
              return typeof value === "function";
            }
            exports2.callable = callable;
            function defined(value) {
              return value !== void 0;
            }
            exports2.defined = defined;
            function divisibleby(one, two) {
              return one % two === 0;
            }
            exports2.divisibleby = divisibleby;
            function escaped(value) {
              return value instanceof SafeString;
            }
            exports2.escaped = escaped;
            function equalto(one, two) {
              return one === two;
            }
            exports2.equalto = equalto;
            exports2.eq = exports2.equalto;
            exports2.sameas = exports2.equalto;
            function even(value) {
              return value % 2 === 0;
            }
            exports2.even = even;
            function falsy(value) {
              return !value;
            }
            exports2.falsy = falsy;
            function ge(one, two) {
              return one >= two;
            }
            exports2.ge = ge;
            function greaterthan(one, two) {
              return one > two;
            }
            exports2.greaterthan = greaterthan;
            exports2.gt = exports2.greaterthan;
            function le(one, two) {
              return one <= two;
            }
            exports2.le = le;
            function lessthan(one, two) {
              return one < two;
            }
            exports2.lessthan = lessthan;
            exports2.lt = exports2.lessthan;
            function lower(value) {
              return value.toLowerCase() === value;
            }
            exports2.lower = lower;
            function ne(one, two) {
              return one !== two;
            }
            exports2.ne = ne;
            function nullTest(value) {
              return value === null;
            }
            exports2.null = nullTest;
            function number(value) {
              return typeof value === "number";
            }
            exports2.number = number;
            function odd(value) {
              return value % 2 === 1;
            }
            exports2.odd = odd;
            function string(value) {
              return typeof value === "string";
            }
            exports2.string = string;
            function truthy(value) {
              return !!value;
            }
            exports2.truthy = truthy;
            function undefinedTest(value) {
              return value === void 0;
            }
            exports2.undefined = undefinedTest;
            function upper(value) {
              return value.toUpperCase() === value;
            }
            exports2.upper = upper;
            function iterable(value) {
              if (typeof Symbol !== "undefined") {
                return !!value[Symbol.iterator];
              } else {
                return Array.isArray(value) || typeof value === "string";
              }
            }
            exports2.iterable = iterable;
            function mapping(value) {
              var bool = value !== null && value !== void 0 && typeof value === "object" && !Array.isArray(value);
              if (Set) {
                return bool && !(value instanceof Set);
              } else {
                return bool;
              }
            }
            exports2.mapping = mapping;
          },
          /* 21 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _cycler(items) {
              var index = -1;
              return {
                current: null,
                reset: function reset() {
                  index = -1;
                  this.current = null;
                },
                next: function next() {
                  index++;
                  if (index >= items.length) {
                    index = 0;
                  }
                  this.current = items[index];
                  return this.current;
                }
              };
            }
            function _joiner(sep) {
              sep = sep || ",";
              var first = true;
              return function() {
                var val = first ? "" : sep;
                first = false;
                return val;
              };
            }
            function globals() {
              return {
                range: function range(start, stop, step) {
                  if (typeof stop === "undefined") {
                    stop = start;
                    start = 0;
                    step = 1;
                  } else if (!step) {
                    step = 1;
                  }
                  var arr = [];
                  if (step > 0) {
                    for (var i = start; i < stop; i += step) {
                      arr.push(i);
                    }
                  } else {
                    for (var _i = start; _i > stop; _i += step) {
                      arr.push(_i);
                    }
                  }
                  return arr;
                },
                cycler: function cycler() {
                  return _cycler(Array.prototype.slice.call(arguments));
                },
                joiner: function joiner(sep) {
                  return _joiner(sep);
                }
              };
            }
            module2.exports = globals;
          },
          /* 22 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var path = __webpack_require__(4);
            module2.exports = function express(env, app) {
              function NunjucksView(name, opts) {
                this.name = name;
                this.path = name;
                this.defaultEngine = opts.defaultEngine;
                this.ext = path.extname(name);
                if (!this.ext && !this.defaultEngine) {
                  throw new Error("No default engine was specified and no extension was provided.");
                }
                if (!this.ext) {
                  this.name += this.ext = (this.defaultEngine[0] !== "." ? "." : "") + this.defaultEngine;
                }
              }
              NunjucksView.prototype.render = function render(opts, cb) {
                env.render(this.name, opts, cb);
              };
              app.set("view", NunjucksView);
              app.set("nunjucksEnv", env);
              return env;
            };
          },
          /* 23 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var fs = __webpack_require__(4);
            var path = __webpack_require__(4);
            var _require = __webpack_require__(0), _prettifyError = _require._prettifyError;
            var compiler = __webpack_require__(5);
            var _require2 = __webpack_require__(7), Environment = _require2.Environment;
            var precompileGlobal = __webpack_require__(24);
            function match(filename, patterns) {
              if (!Array.isArray(patterns)) {
                return false;
              }
              return patterns.some(function(pattern) {
                return filename.match(pattern);
              });
            }
            function precompileString(str, opts) {
              opts = opts || {};
              opts.isString = true;
              var env = opts.env || new Environment([]);
              var wrapper = opts.wrapper || precompileGlobal;
              if (!opts.name) {
                throw new Error('the "name" option is required when compiling a string');
              }
              return wrapper([_precompile(str, opts.name, env)], opts);
            }
            function precompile(input, opts) {
              opts = opts || {};
              var env = opts.env || new Environment([]);
              var wrapper = opts.wrapper || precompileGlobal;
              if (opts.isString) {
                return precompileString(input, opts);
              }
              var pathStats = fs.existsSync(input) && fs.statSync(input);
              var precompiled = [];
              var templates = [];
              function addTemplates(dir) {
                fs.readdirSync(dir).forEach(function(file) {
                  var filepath = path.join(dir, file);
                  var subpath = filepath.substr(path.join(input, "/").length);
                  var stat = fs.statSync(filepath);
                  if (stat && stat.isDirectory()) {
                    subpath += "/";
                    if (!match(subpath, opts.exclude)) {
                      addTemplates(filepath);
                    }
                  } else if (match(subpath, opts.include)) {
                    templates.push(filepath);
                  }
                });
              }
              if (pathStats.isFile()) {
                precompiled.push(_precompile(fs.readFileSync(input, "utf-8"), opts.name || input, env));
              } else if (pathStats.isDirectory()) {
                addTemplates(input);
                for (var i = 0; i < templates.length; i++) {
                  var name = templates[i].replace(path.join(input, "/"), "");
                  try {
                    precompiled.push(_precompile(fs.readFileSync(templates[i], "utf-8"), name, env));
                  } catch (e) {
                    if (opts.force) {
                      console.error(e);
                    } else {
                      throw e;
                    }
                  }
                }
              }
              return wrapper(precompiled, opts);
            }
            function _precompile(str, name, env) {
              env = env || new Environment([]);
              var asyncFilters = env.asyncFilters;
              var extensions = env.extensionsList;
              var template;
              name = name.replace(/\\/g, "/");
              try {
                template = compiler.compile(str, asyncFilters, extensions, name, env.opts);
              } catch (err) {
                throw _prettifyError(name, false, err);
              }
              return {
                name,
                template
              };
            }
            module2.exports = {
              precompile,
              precompileString
            };
          },
          /* 24 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function precompileGlobal(templates, opts) {
              var out = "";
              opts = opts || {};
              for (var i = 0; i < templates.length; i++) {
                var name = JSON.stringify(templates[i].name);
                var template = templates[i].template;
                out += "(function() {(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})[" + name + "] = (function() {\n" + template + "\n})();\n";
                if (opts.asFunction) {
                  out += "return function(ctx, cb) { return nunjucks.render(" + name + ", ctx, cb); }\n";
                }
                out += "})();\n";
              }
              return out;
            }
            module2.exports = precompileGlobal;
          },
          /* 25 */
          /***/
          function(module2, exports2, __webpack_require__) {
            function installCompat() {
              "use strict";
              var runtime = this.runtime;
              var lib = this.lib;
              var Compiler = this.compiler.Compiler;
              var Parser = this.parser.Parser;
              var nodes = this.nodes;
              var lexer = this.lexer;
              var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
              var orig_memberLookup = runtime.memberLookup;
              var orig_Compiler_assertType;
              var orig_Parser_parseAggregate;
              if (Compiler) {
                orig_Compiler_assertType = Compiler.prototype.assertType;
              }
              if (Parser) {
                orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
              }
              function uninstall() {
                runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
                runtime.memberLookup = orig_memberLookup;
                if (Compiler) {
                  Compiler.prototype.assertType = orig_Compiler_assertType;
                }
                if (Parser) {
                  Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
                }
              }
              runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
                var val = orig_contextOrFrameLookup.apply(this, arguments);
                if (val !== void 0) {
                  return val;
                }
                switch (key) {
                  case "True":
                    return true;
                  case "False":
                    return false;
                  case "None":
                    return null;
                  default:
                    return void 0;
                }
              };
              function getTokensState(tokens) {
                return {
                  index: tokens.index,
                  lineno: tokens.lineno,
                  colno: tokens.colno
                };
              }
              if (nodes && Compiler && Parser) {
                var Slice = nodes.Node.extend("Slice", {
                  fields: ["start", "stop", "step"],
                  init: function init(lineno, colno, start, stop, step) {
                    start = start || new nodes.Literal(lineno, colno, null);
                    stop = stop || new nodes.Literal(lineno, colno, null);
                    step = step || new nodes.Literal(lineno, colno, 1);
                    this.parent(lineno, colno, start, stop, step);
                  }
                });
                Compiler.prototype.assertType = function assertType(node) {
                  if (node instanceof Slice) {
                    return;
                  }
                  orig_Compiler_assertType.apply(this, arguments);
                };
                Compiler.prototype.compileSlice = function compileSlice(node, frame) {
                  this._emit("(");
                  this._compileExpression(node.start, frame);
                  this._emit("),(");
                  this._compileExpression(node.stop, frame);
                  this._emit("),(");
                  this._compileExpression(node.step, frame);
                  this._emit(")");
                };
                Parser.prototype.parseAggregate = function parseAggregate() {
                  var _this = this;
                  var origState = getTokensState(this.tokens);
                  origState.colno--;
                  origState.index--;
                  try {
                    return orig_Parser_parseAggregate.apply(this);
                  } catch (e) {
                    var errState = getTokensState(this.tokens);
                    var rethrow = function rethrow2() {
                      lib._assign(_this.tokens, errState);
                      return e;
                    };
                    lib._assign(this.tokens, origState);
                    this.peeked = false;
                    var tok = this.peekToken();
                    if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
                      throw rethrow();
                    } else {
                      this.nextToken();
                    }
                    var node = new Slice(tok.lineno, tok.colno);
                    var isSlice = false;
                    for (var i = 0; i <= node.fields.length; i++) {
                      if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
                        break;
                      }
                      if (i === node.fields.length) {
                        if (isSlice) {
                          this.fail("parseSlice: too many slice components", tok.lineno, tok.colno);
                        } else {
                          break;
                        }
                      }
                      if (this.skip(lexer.TOKEN_COLON)) {
                        isSlice = true;
                      } else {
                        var field = node.fields[i];
                        node[field] = this.parseExpression();
                        isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
                      }
                    }
                    if (!isSlice) {
                      throw rethrow();
                    }
                    return new nodes.Array(tok.lineno, tok.colno, [node]);
                  }
                };
              }
              function sliceLookup(obj, start, stop, step) {
                obj = obj || [];
                if (start === null) {
                  start = step < 0 ? obj.length - 1 : 0;
                }
                if (stop === null) {
                  stop = step < 0 ? -1 : obj.length;
                } else if (stop < 0) {
                  stop += obj.length;
                }
                if (start < 0) {
                  start += obj.length;
                }
                var results = [];
                for (var i = start; ; i += step) {
                  if (i < 0 || i > obj.length) {
                    break;
                  }
                  if (step > 0 && i >= stop) {
                    break;
                  }
                  if (step < 0 && i <= stop) {
                    break;
                  }
                  results.push(runtime.memberLookup(obj, i));
                }
                return results;
              }
              function hasOwnProp(obj, key) {
                return Object.prototype.hasOwnProperty.call(obj, key);
              }
              var ARRAY_MEMBERS = {
                pop: function pop(index) {
                  if (index === void 0) {
                    return this.pop();
                  }
                  if (index >= this.length || index < 0) {
                    throw new Error("KeyError");
                  }
                  return this.splice(index, 1);
                },
                append: function append(element) {
                  return this.push(element);
                },
                remove: function remove(element) {
                  for (var i = 0; i < this.length; i++) {
                    if (this[i] === element) {
                      return this.splice(i, 1);
                    }
                  }
                  throw new Error("ValueError");
                },
                count: function count(element) {
                  var count2 = 0;
                  for (var i = 0; i < this.length; i++) {
                    if (this[i] === element) {
                      count2++;
                    }
                  }
                  return count2;
                },
                index: function index(element) {
                  var i;
                  if ((i = this.indexOf(element)) === -1) {
                    throw new Error("ValueError");
                  }
                  return i;
                },
                find: function find(element) {
                  return this.indexOf(element);
                },
                insert: function insert(index, elem) {
                  return this.splice(index, 0, elem);
                }
              };
              var OBJECT_MEMBERS = {
                items: function items() {
                  return lib._entries(this);
                },
                values: function values() {
                  return lib._values(this);
                },
                keys: function keys() {
                  return lib.keys(this);
                },
                get: function get(key, def) {
                  var output = this[key];
                  if (output === void 0) {
                    output = def;
                  }
                  return output;
                },
                has_key: function has_key(key) {
                  return hasOwnProp(this, key);
                },
                pop: function pop(key, def) {
                  var output = this[key];
                  if (output === void 0 && def !== void 0) {
                    output = def;
                  } else if (output === void 0) {
                    throw new Error("KeyError");
                  } else {
                    delete this[key];
                  }
                  return output;
                },
                popitem: function popitem() {
                  var keys = lib.keys(this);
                  if (!keys.length) {
                    throw new Error("KeyError");
                  }
                  var k = keys[0];
                  var val = this[k];
                  delete this[k];
                  return [k, val];
                },
                setdefault: function setdefault(key, def) {
                  if (def === void 0) {
                    def = null;
                  }
                  if (!(key in this)) {
                    this[key] = def;
                  }
                  return this[key];
                },
                update: function update(kwargs) {
                  lib._assign(this, kwargs);
                  return null;
                }
              };
              OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
              OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
              OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;
              runtime.memberLookup = function memberLookup(obj, val, autoescape) {
                if (arguments.length === 4) {
                  return sliceLookup.apply(this, arguments);
                }
                obj = obj || {};
                if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
                  return ARRAY_MEMBERS[val].bind(obj);
                }
                if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
                  return OBJECT_MEMBERS[val].bind(obj);
                }
                return orig_memberLookup.apply(this, arguments);
              };
              return uninstall;
            }
            module2.exports = installCompat;
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/formsmd/src/form-field-create.js
var require_form_field_create = __commonJS({
  "node_modules/formsmd/src/form-field-create.js"(exports) {
    "use strict";
    var { addReservedClass } = require_attrs_parse();
    var { isNumeric, unescape } = require_helpers();
    var {
      getPhoneNumberPlaceholder,
      createCountryCallingCodeOptions
    } = require_phone_numbers();
    var { getTranslation } = require_translations();
    var nunjucks = require_nunjucks();
    var formFieldPattern = new RegExp(
      /\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\s*(\*)?\s*=\s*(textinput|emailinput|urlinput|telinput|passwordinput|numberinput|selectbox|choiceinput|picturechoice|ratinginput|opinionscale|datetimeinput|dateinput|timeinput|fileinput)\((.*)\)/,
      "is"
    );
    function formFieldSetup(required, parsedAttrs, params, formDelimiter, localization, useFieldset) {
      const validParams = {
        question: required ? `<span class="fmd-text-nowrap" aria-hidden="true">...<sup class="fmd-text-accent">*</sup></span><span class="fmd-visually-hidden">... (${getTranslation(localization, "required")})</span>` : "..."
      };
      const restParams = {};
      for (let param of params.split(formDelimiter)) {
        param = param.trim();
        if (!param) {
          continue;
        }
        let key, value, equalIndex;
        equalIndex = param.indexOf("=");
        if (equalIndex !== -1) {
          key = param.slice(0, equalIndex).trim().toLowerCase();
          value = param.slice(equalIndex + 1).trim();
        } else {
          key = param.toLowerCase();
          value = true;
        }
        if (key === "question" && value) {
          if (required) {
            let question = value.split(" ");
            const questionLastWord = question.pop();
            question.push(
              `<span class="fmd-text-nowrap" aria-hidden="true">${questionLastWord}<sup class="fmd-text-accent">*</sup></span><span class="fmd-visually-hidden">${questionLastWord} (${getTranslation(localization, "required")})</span>`
            );
            validParams[key] = question.join(" ");
          } else {
            validParams[key] = value;
          }
        } else if (key === "description" && value) {
          validParams[key] = value;
        } else if (key === "fieldsize" && value && value === "sm") {
          validParams[key] = value;
        } else if (key === "subfield" && value) {
          validParams[key] = value;
        } else if (key === "labelstyle" && value && value === "classic") {
          validParams[key] = value;
        } else if (key === "autofocus" && value) {
          validParams[key] = value;
        } else {
          restParams[key] = value;
        }
      }
      const startTagName = useFieldset ? "fieldset" : "div";
      let startTag = `<${startTagName}>`;
      if (parsedAttrs) {
        startTag = `<${startTagName} ${parsedAttrs}>`;
      }
      startTag = addReservedClass(startTag, "fmd-form-field");
      if (validParams.fieldsize === "sm") {
        startTag = addReservedClass(startTag, "fmd-form-field-sm");
      }
      if (validParams.subfield !== void 0 || validParams.labelstyle === "classic") {
        startTag = addReservedClass(startTag, "fmd-form-field-classic-labels");
      }
      return {
        startTag,
        validParams,
        restParams
      };
    }
    var textFieldTemplate = `
{{ startTag }}
	<label class="fmd-form-question" for="{{ inputId }}">
		{{ validParams.question | safe }}
	</label>
	{% if validParams.description %}
	<p class="fmd-form-description">
		{{ validParams.description }}
	</p>
	{% endif %}
	<input
		name="{{ name }}"
		id="{{ inputId }}"
		type="{{ inputType }}"
		class="{% if inputType == 'password' %}fmd-form-password-input{% else %}fmd-form-str-input{% endif %} fmd-form-control"
		placeholder="{{ validParams.placeholder }}"
		{% if required %}required{% endif %}
		{% if validParams.value %}value="{{ validParams.value }}"{% endif %}
		{% if validParams.maxlength %}maxlength="{{ validParams.maxlength }}"{% endif %}
		{% if validParams.pattern %}pattern="{{ validParams.pattern }}"{% endif %}
		{% if validParams.disabled %}disabled{% endif %}
		{% if validParams.autofocus %}data-fmd-autofocus{% endif %}
	>
</div>
`;
    var multilineTextFieldTemplate = `
{{ startTag }}
	<label class="fmd-form-question" for="{{ inputId }}">
		{{ validParams.question | safe }}
	</label>
	{% if validParams.description %}
	<p class="fmd-form-description">
		{{ validParams.description }}
	</p>
	{% endif %}
	<textarea
		name="{{ name }}"
		id="{{ inputId }}"
		class="fmd-form-str-input fmd-form-control"
		placeholder="{{ validParams.placeholder }}"
		{% if required %}required{% endif %}
		{% if validParams.maxlength %}maxlength="{{ validParams.maxlength }}"{% endif %}
		{% if validParams.disabled %}disabled{% endif %}
		{% if validParams.autofocus %}data-fmd-autofocus{% endif %}
		aria-describedby="{{ inputId }}-form-text"
	>{% if validParams.value %}{{ validParams.value }}{% endif %}</textarea>
	<div id="{{ inputId }}-form-text" class="fmd-form-text-bottom fmd-d-flex fmd-align-items-center">
		<kbd class="fmd-d-flex fmd-align-items-center fmd-me-1"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="fmd-icon fmd-mt-1 fmd-me-2" aria-hidden="true" focusable="false"><path d="M464 56V32h48V56 288v24H488 93.1l79 79 17 17-33.9 33.9-17-17L18.2 305l-17-17 17-17 120-120 17-17L189.1 168l-17 17-79 79H464V56z"/></svg> Enter</kbd>
		{{ translations.newLineText }}
	</div>
</div>
`;
    var telFieldTemplate = `
{{ startTag }}
	<legend class="fmd-form-question">
		{{ validParams.question | safe }}
	</legend>
	{% if validParams.description %}
	<p class="fmd-form-description">
		{{ validParams.description }}
	</p>
	{% endif %}
	<div class="fmd-input-group">
		<select
			name="{{ name }}CountryCode"
			id="{{ inputId }}CountryCode"
			class="fmd-form-str-select fmd-form-countrycode-select fmd-form-select"
			required
			{% if validParams.disabled %}disabled{% endif %}
			{% if validParams.autofocus %}data-fmd-autofocus{% endif %}
			aria-label="{{ translations.countryCallingCodeLabel }}"
		>
			{{ availableCountryOptions | safe }}
		</select>
		<input
			name="{{ name }}"
			id="{{ inputId }}"
			type="{{ inputType }}"
			class="fmd-form-str-input fmd-form-control"
			placeholder="{{ validParams.placeholder }}"
			{% if required %}required{% endif %}
			{% if validParams.value %}value="{{ validParams.value }}"{% endif %}
			{% if validParams.maxlength %}maxlength="{{ validParams.maxlength }}"{% endif %}
			{% if validParams.pattern %}pattern="{{ validParams.pattern }}"{% endif %}
			{% if validParams.disabled %}disabled{% endif %}
			{% if validParams.autofocus %}data-fmd-autofocus{% endif %}
			aria-label="{{ translations.phoneNumberLabel }}"
		>
	</div>
</fieldset>
`;
    function createTextField(name, inputType, required, parsedAttrs, params, formDelimiter, id, localization) {
      const {
        startTag,
        validParams,
        restParams
      } = formFieldSetup(
        required,
        parsedAttrs,
        params,
        formDelimiter,
        localization,
        inputType === "tel" ? true : false
      );
      const translations = {};
      validParams.placeholder = getTranslation(
        localization,
        "text-input-placeholder"
      );
      if (inputType === "email") {
        validParams.placeholder = "name@example.com";
      } else if (inputType === "url") {
        validParams.placeholder = "https://example.com";
      } else if (inputType === "password") {
        validParams.placeholder = "&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;";
      }
      for (let [key, value] of Object.entries(restParams)) {
        if (key === "placeholder" && value && typeof value === "string") {
          validParams[key] = value;
        } else if (key === "disabled" && value) {
          validParams[key] = value;
        } else if (key === "multiline" && value) {
          validParams[key] = value;
        } else if (key === "maxlength" && value && value >>> 0 === parseFloat(value)) {
          validParams[key] = value;
        } else if (key === "pattern" && value && typeof value === "string") {
          validParams[key] = value;
        } else if (key === "value" && value && typeof value === "string") {
          validParams[key] = value;
        } else if (key === "country" && value && typeof value === "string") {
          validParams[key] = value;
        } else if (key === "availablecountries" && value && typeof value === "string") {
          validParams[key] = value;
        } else {
          console.warn(
            `[FORM-FIELDS] "${name}": "${key} = ${value}" is not a valid parameter`
          );
        }
      }
      if (inputType === "tel") {
        validParams.country = validParams.country || "US";
        validParams.placeholder = getPhoneNumberPlaceholder(validParams.country);
        validParams.availablecountries = validParams.availablecountries || "";
        if (validParams.availablecountries.trim() === "") {
          validParams.availablecountries = [];
        } else {
          validParams.availablecountries = validParams.availablecountries.split(",");
        }
      }
      let template = textFieldTemplate;
      if (inputType === "text" && validParams.multiline !== void 0) {
        template = multilineTextFieldTemplate;
        translations.newLineText = getTranslation(
          localization,
          "textarea-new-line-text"
        );
      } else if (inputType === "tel") {
        template = telFieldTemplate;
        translations.countryCallingCodeLabel = getTranslation(
          localization,
          "country-calling-code-label"
        );
        translations.phoneNumberLabel = getTranslation(
          localization,
          "phone-number-label"
        );
      }
      nunjucks.configure({ autoescape: false });
      return nunjucks.renderString(template, {
        startTag,
        name,
        inputId: id !== "" ? `${id}:id_${name}` : `id_${name}`,
        inputType,
        required,
        validParams,
        translations,
        availableCountryOptions: inputType === "tel" ? createCountryCallingCodeOptions(
          validParams.country,
          validParams.availablecountries
        ) : ""
      });
    }
    var numberFieldTemplate = `
{{ startTag }}
	<label class="fmd-form-question" for="{{ inputId }}">
		{{ validParams.question | safe }}
	</label>
	{% if validParams.description %}
	<p class="fmd-form-description">
		{{ validParams.description }}
	</p>
	{% endif %}
	<div class="fmd-input-group">
		{% if validParams.unit %}
		<span id="{{ inputId }}-unit" class="fmd-input-group-text">{{ validParams.unit }}</span>
		{% endif %}
		<input
			name="{{ name }}"
			id="{{ inputId }}"
			type="number"
			class="fmd-form-num-input fmd-form-control"
			placeholder="{{ validParams.placeholder }}"
			{% if required %}required{% endif %}
			{% if validParams.value %}value="{{ validParams.value }}"{% endif %}
			{% if validParams.min %}min="{{ validParams.min }}"{% endif %}
			{% if validParams.max %}max="{{ validParams.max }}"{% endif %}
			{% if validParams.step %}step="{{ validParams.step }}"{% endif %}
			{% if validParams.disabled %}disabled{% endif %}
			{% if validParams.autofocus %}data-fmd-autofocus{% endif %}
			{% if validParams.unit and validParams.unitend %}
			aria-describedby="{{ inputId }}-unit {{ inputId }}-unit-end"
			{% elif validParams.unit %}
			aria-describedby="{{ inputId }}-unit"
			{% elif validParams.unitend %}
			aria-describedby="{{ inputId }}-unit-end"
			{% endif %}
		>
		{% if validParams.unitend %}
		<span id="{{ inputId }}-unit-end" class="fmd-input-group-text">{{ validParams.unitend }}</span>
		{% endif %}
	</div>
</div>
`;
    function createNumberField(name, required, parsedAttrs, params, formDelimiter, id, localization) {
      const {
        startTag,
        validParams,
        restParams
      } = formFieldSetup(
        required,
        parsedAttrs,
        params,
        formDelimiter,
        localization,
        false
      );
      const translations = {};
      validParams.placeholder = getTranslation(
        localization,
        "number-input-placeholder"
      );
      for (let [key, value] of Object.entries(restParams)) {
        if (key === "placeholder" && value && typeof value === "string") {
          validParams[key] = value;
        } else if (key === "disabled" && value) {
          validParams[key] = value;
        } else if (key === "max" && isNumeric(value)) {
          validParams[key] = value;
        } else if (key === "min" && isNumeric(value)) {
          validParams[key] = value;
        } else if (key === "step" && isNumeric(value)) {
          validParams[key] = value;
        } else if (key === "unit" && value && typeof value === "string") {
          validParams[key] = value;
        } else if (key === "unitend" && value && typeof value === "string") {
          validParams[key] = value;
        } else if (key === "value" && isNumeric(value)) {
          validParams[key] = value;
        } else {
          console.warn(
            `[FORM-FIELDS] "${name}": "${key} = ${value}" is not a valid parameter`
          );
        }
      }
      nunjucks.configure({ autoescape: false });
      return nunjucks.renderString(numberFieldTemplate, {
        startTag,
        name,
        inputId: id !== "" ? `${id}:id_${name}` : `id_${name}`,
        required,
        validParams,
        translations
      });
    }
    var selectFieldTemplate = `
{{ startTag }}
	<label class="fmd-form-question" for="{{ inputId }}">
		{{ validParams.question | safe }}
	</label>
	{% if validParams.description %}
	<p class="fmd-form-description">
		{{ validParams.description }}
	</p>
	{% endif %}
	<select
		name="{{ name }}"
		id="{{ inputId }}"
		class="fmd-form-str-select fmd-form-select"
		{% if required %}required{% endif %}
		{% if validParams.disabled %}disabled{% endif %}
		{% if validParams.autofocus %}data-fmd-autofocus{% endif %}
	>
		<option
			value=""
			{% if required %}disabled{% endif %}
			{% if not validParams.selected %}selected{% endif %}
		>
			{{ validParams.placeholder }}
		</option>
		{% for option in validParams.options %}
		<option
			value="{{ option.value }}"
			{% if validParams.selected == option.value and option.value %}selected{% endif %}
		>
			{{ option.label }}
		</option>
		{% endfor %}
	</select>
</div>
`;
    function createSelectField(name, required, parsedAttrs, params, formDelimiter, id, localization) {
      const {
        startTag,
        validParams,
        restParams
      } = formFieldSetup(
        required,
        parsedAttrs,
        params,
        formDelimiter,
        localization,
        false
      );
      const translations = {};
      validParams.placeholder = getTranslation(
        localization,
        "select-box-placeholder"
      );
      for (let [key, value] of Object.entries(restParams)) {
        if (key === "placeholder" && value && typeof value === "string") {
          validParams[key] = value;
        } else if (key === "disabled" && value) {
          validParams[key] = value;
        } else if (key === "options" && value && typeof value === "string") {
          const options = [];
          for (let option of value.split(",")) {
            option = unescape(option.trim());
            if (!option) {
              continue;
            }
            let optionValue = option;
            let optionLabel = option;
            optionLabel = optionLabel.replace(
              /"\s*(.*?)\s*"/s,
              function(match, content) {
                optionValue = content;
                return "";
              }
            );
            options.push({ value: optionValue.trim(), label: optionLabel.trim() });
          }
          validParams[key] = options;
        } else if (key === "selected" && value && typeof value === "string") {
          validParams[key] = value;
        } else {
          console.warn(
            `[FORM-FIELDS] "${name}": "${key} = ${value}" is not a valid parameter`
          );
        }
      }
      nunjucks.configure({ autoescape: false });
      return nunjucks.renderString(selectFieldTemplate, {
        startTag,
        name,
        inputId: id !== "" ? `${id}:id_${name}` : `id_${name}`,
        required,
        validParams,
        translations
      });
    }
    var choiceFieldTemplate = `
{{ startTag }}
	<legend class="fmd-form-question">
		{{ validParams.question | safe }}
	</legend>
	{% if validParams.description %}
	<p class="fmd-form-description">
		{{ validParams.description }}
	</p>
	{% endif %}
	{% if validParams.multiple and not validParams.hideformtext %}
	<div class="fmd-form-text">
		{{ translations.chooseManyText }}
	</div>
	{% endif %}
	<div class="fmd-check-grid-wrapper">
		<div class="fmd-check-grid{% if isPictureChoice or validParams.horizontal %} fmd-check-grid-h{% endif %}{% if isPictureChoice and validParams.supersize %} fmd-check-grid-h-lg{% endif %}">
			{% for choice in validParams.choices %}
			<div class="fmd-form-check{% if isPictureChoice %} fmd-form-img-check{% endif %}">
				<input
					name="{{ name }}"
					id="{{ inputId }}-{{ loop.index }}"
					type="{% if validParams.multiple %}checkbox{% else %}radio{% endif %}"
					class="fmd-form-str-check-input fmd-form-check-input"
					value="{{ choice.value }}"
					{% if validParams.checked %}{% if choice.value in validParams.checked %}checked{% endif %}{% endif %}
					{% if validParams.disabled %}disabled{% endif %}
					{% if validParams.autofocus %}data-fmd-autofocus{% endif %}
				>
				<label class="fmd-form-check-label" for="{{ inputId }}-{{ loop.index }}">
					{% if isPictureChoice %}
					<span class="fmd-form-check-frame">
						<img src="{{ choice.image }}" alt="{{ choice.label }}">
					</span>
					{% if not validParams.hidelabels %}{{ choice.label }}{% endif %}
					{% else %}
					{{ choice.label }}
					{% endif %}
					<span class="fmd-form-check-mark">
						<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="fmd-icon" aria-hidden="true" focusable="false"><path d="M441 103c9.4 9.4 9.4 24.6 0 33.9L177 401c-9.4 9.4-24.6 9.4-33.9 0L7 265c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l119 119L407 103c9.4-9.4 24.6-9.4 33.9 0z"/></svg>
					</span>
				</label>
			</div>
			{% endfor %}
		</div>
	</div>
</fieldset>
`;
    function createChoiceField(name, isPictureChoice, required, parsedAttrs, params, formDelimiter, id, localization) {
      const {
        startTag,
        validParams,
        restParams
      } = formFieldSetup(
        required,
        parsedAttrs,
        params,
        formDelimiter,
        localization,
        true
      );
      const translations = {
        chooseManyText: getTranslation(localization, "choose-many-text")
      };
      for (let [key, value] of Object.entries(restParams)) {
        if (key === "disabled" && value) {
          validParams[key] = value;
        } else if (key === "multiple" && value) {
          validParams[key] = value;
        } else if (key === "horizontal" && value) {
          validParams[key] = value;
        } else if (key === "supersize" && value) {
          validParams[key] = value;
        } else if (key === "choices" && value && typeof value === "string") {
          const choices = [];
          for (let choice of value.split(",")) {
            choice = unescape(choice.trim());
            if (!choice) {
              continue;
            }
            const choiceAndImage = choice.split("&&");
            let choiceValue = choiceAndImage[0];
            let choiceLabel = choiceAndImage[0];
            let choiceImage = choiceAndImage.length > 1 ? choiceAndImage[1] : "";
            choiceLabel = choiceLabel.replace(
              /"\s*(.*?)\s*"/s,
              function(match, content) {
                choiceValue = content;
                return "";
              }
            );
            choices.push({
              value: choiceValue.trim(),
              label: choiceLabel.trim(),
              image: choiceImage.trim()
            });
          }
          validParams[key] = choices;
        } else if (key === "checked" && value && typeof value === "string") {
          validParams[key] = value.split(",").map(function(item) {
            return item.trim();
          });
        } else if (key === "hidelabels" && value) {
          validParams[key] = value;
        } else if (key === "hideformtext" && value) {
          validParams[key] = value;
        } else {
          console.warn(
            `[FORM-FIELDS] "${name}": "${key} = ${value}" is not a valid parameter`
          );
        }
      }
      let validationAttrs = `data-fmd-name="${name}"`;
      if (!validParams.multiple) {
        validationAttrs += ' data-fmd-type="radio"';
      } else {
        validationAttrs += ' data-fmd-type="checkbox"';
      }
      if (required) {
        validationAttrs += " data-fmd-required";
      }
      if (!validParams.multiple && Array.isArray(validParams.checked)) {
        validParams.checked.splice(1);
      }
      nunjucks.configure({ autoescape: false });
      return nunjucks.renderString(choiceFieldTemplate, {
        startTag: `${startTag.slice(0, 9)} ${validationAttrs} ${startTag.slice(9)}`,
        name,
        inputId: id !== "" ? `${id}:id_${name}` : `id_${name}`,
        isPictureChoice,
        required,
        validParams,
        translations
      });
    }
    var ratingFieldTemplate = `
{{ startTag }}
	<legend class="fmd-form-question">
		{{ validParams.question | safe }}
	</legend>
	{% if validParams.description %}
	<p class="fmd-form-description">
		{{ validParams.description }}
	</p>
	{% endif %}
	<div class="fmd-rating-grid{% if validParams.outof > 5 %} fmd-rating-grid-5-or-more{% endif %}">
		{% for i in range(1, validParams.outof + 1) %}
		<input 
			name="{{ name }}"
			id="{{ inputId }}-{{ i }}"
			type="radio"
			class="fmd-form-num-check-input fmd-form-rating-input"
			value="{{ i }}"
			{% if validParams.value == i %}checked{% endif %}
			{% if validParams.disabled %}disabled{% endif %}
			{% if validParams.autofocus %}data-fmd-autofocus{% endif %}
		>
		<label class="fmd-form-rating-label" for="{{ inputId }}-{{ i }}">
			{% if validParams.icon == "heart" or validParams.icon == "hearts" %}
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="fmd-form-rating-svg" aria-hidden="true" focusable="false">
				<path d="M39.8 263.8L64 288 256 480 448 288l24.2-24.2c25.5-25.5 39.8-60 39.8-96C512 92.8 451.2 32 376.2 32c-36 0-70.5 14.3-96 39.8L256 96 231.8 71.8c-25.5-25.5-60-39.8-96-39.8C60.8 32 0 92.8 0 167.8c0 36 14.3 70.5 39.8 96z" class="fmd-form-rating-svg-path-inner"/>
				<path d="M256 141.3l-22.6-22.6L209.1 94.4C189.7 74.9 163.3 64 135.8 64C78.5 64 32 110.5 32 167.8c0 27.5 10.9 53.9 30.4 73.4l24.2 24.2L256 434.8 425.4 265.4l24.2-24.2c19.5-19.5 30.4-45.9 30.4-73.4C480 110.5 433.5 64 376.2 64c-27.5 0-53.9 10.9-73.4 30.4l-24.2 24.2L256 141.3zm22.6 316.1L256 480l-22.6-22.6L64 288 39.8 263.8C14.3 238.3 0 203.8 0 167.8C0 92.8 60.8 32 135.8 32c36 0 70.5 14.3 96 39.8l1.6 1.6L256 96l22.6-22.6 1.6-1.6c25.5-25.5 60-39.8 96-39.8C451.2 32 512 92.8 512 167.8c0 36-14.3 70.5-39.8 96L448 288 278.6 457.4z" class="fmd-form-rating-svg-path-outer"/>
			</svg>
			{% else %}
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" class="fmd-form-rating-svg" aria-hidden="true" focusable="false">
				<path d="M288.1 0l63.5 195.6H557.2L390.9 316.4 454.4 512 288.1 391.1 121.7 512l63.5-195.6L18.9 195.6H224.5L288.1 0z" class="fmd-form-rating-svg-path-inner"/>
				<path d="M351.6 195.6L304.9 51.8 288.1 0 271.2 51.8 224.5 195.6l-151.2 0-54.4 0 44 32 122.3 88.9L138.5 460.2 121.7 512l44-32 122.3-88.9L410.4 480l44 32-16.8-51.8L390.9 316.4l122.3-88.9 44-32-54.4 0-151.2 0zm107.1 32l-86.7 63-18.8 13.7 7.2 22.1 33.1 101.9-86.7-63-18.8-13.7-18.8 13.7-86.7 63 33.1-101.9 7.2-22.1L204 290.5l-86.7-63 107.1 0 23.2 0 7.2-22.1 33.1-101.9 33.1 101.9 7.2 22.1 23.3 0 107.1 0z" class="fmd-form-rating-svg-path-outer"/>
			</svg>
			{% endif %}
			{% if not validParams.hidelabels %}
			{{ i }}<span class="fmd-visually-hidden"> {% if i == 1 %}{{ translations.starSingular }}{% else %}{{ translations.starPlural }}{% endif %}</span>
			{% else %}
			<span class="fmd-visually-hidden">{{ i }} {% if i == 1 %}{{ translations.starSingular }}{% else %}{{ translations.starPlural }}{% endif %}</span>
			{% endif %}
		</label>
		{% endfor %}
	</div>
</fieldset>
`;
    function createRatingField(name, required, parsedAttrs, params, formDelimiter, id, localization) {
      const {
        startTag,
        validParams,
        restParams
      } = formFieldSetup(
        required,
        parsedAttrs,
        params,
        formDelimiter,
        localization,
        true
      );
      const translations = {
        starSingular: getTranslation(localization, "star-singular"),
        starPlural: getTranslation(localization, "star-plural")
      };
      validParams.outof = 5;
      validParams.icon = "star";
      for (let [key, value] of Object.entries(restParams)) {
        if (key === "disabled" && value) {
          validParams[key] = value;
        } else if (key === "outof" && value && value.match(/^([1-9]|10)$/)) {
          validParams[key] = parseInt(value);
        } else if (key === "icon" && value && (value.toLowerCase() === "heart" || value.toLowerCase() === "hearts")) {
          validParams[key] = value.toLowerCase();
        } else if (key === "value" && value && typeof value === "string") {
          validParams[key] = parseInt(value);
        } else if (key === "hidelabels" && value) {
          validParams[key] = value;
        } else {
          console.warn(
            `[FORM-FIELDS] "${name}": "${key} = ${value}" is not a valid parameter`
          );
        }
      }
      let validationAttrs = `data-fmd-name="${name}" data-fmd-type="num-radio"`;
      if (required) {
        validationAttrs += " data-fmd-required";
      }
      nunjucks.configure({ autoescape: false });
      return nunjucks.renderString(ratingFieldTemplate, {
        startTag: `${startTag.slice(0, 9)} ${validationAttrs} ${startTag.slice(9)}`,
        name,
        inputId: id !== "" ? `${id}:id_${name}` : `id_${name}`,
        required,
        validParams,
        translations
      });
    }
    var opinionScaleFieldTemplate = `
{{ startTag }}
	<legend class="fmd-form-question">
		{{ validParams.question | safe }}
	</legend>
	{% if validParams.description %}
	<p class="fmd-form-description">
		{{ validParams.description }}
	</p>
	{% endif %}
	<div class="fmd-scale-grid">
		{% for i in range(validParams.startat, validParams.outof + 1) %}
		<input 
			name="{{ name }}"
			id="{{ inputId }}-{{ i }}"
			type="radio"
			class="fmd-form-num-check-input fmd-form-scale-input"
			value="{{ i }}"
			{% if validParams.value == i %}checked{% endif %}
			{% if validParams.disabled %}disabled{% endif %}
			{% if validParams.autofocus %}data-fmd-autofocus{% endif %}
			{% if i == validParams.startat and validParams.labelstart %}
			aria-describedby="{{ inputId }}-label-start"
			{% endif %}
			{% if i == validParams.outof and validParams.labelend %}
			aria-describedby="{{ inputId }}-label-end"
			{% endif %}
		>
		<label class="fmd-form-scale-label" for="{{ inputId }}-{{ i }}">{{ i }}</label>
		{% endfor %}
	</div>
	{% if validParams.labelstart or validParams.labelend  %}
	<div class="fmd-form-scale-text">
		{% if validParams.labelstart %}
		<div class="fmd-form-scale-text-start">
			<span class="fmd-d-none fmd-xs:d-inline-block">{{ validParams.startat }} &mdash;</span>
			<span id="{{ inputId }}-label-start">{{ validParams.labelstart }}</span>
		</div>
		{% endif %}
		{% if validParams.labelend %}
		<div class="fmd-form-scale-text-end">
			<span class="fmd-d-none fmd-xs:d-inline-block">{{ validParams.outof }} &mdash;</span>
			<span id="{{ inputId }}-label-end">{{ validParams.labelend }}</span>
		</div>
		{% endif %}
	</div>
	{% endif %}
</fieldset>
`;
    function createOpinionScaleField(name, required, parsedAttrs, params, formDelimiter, id, localization) {
      const {
        startTag,
        validParams,
        restParams
      } = formFieldSetup(
        required,
        parsedAttrs,
        params,
        formDelimiter,
        localization,
        true
      );
      const translations = {};
      validParams.startat = 0;
      validParams.outof = 10;
      validParams.labelstart = getTranslation(localization, "nps-label-start");
      validParams.labelend = getTranslation(localization, "nps-label-end");
      for (let [key, value] of Object.entries(restParams)) {
        if (key === "disabled" && value) {
          validParams[key] = value;
        } else if (key === "startat" && value && value.match(/^(0|1)$/)) {
          validParams[key] = parseInt(value);
        } else if (key === "outof" && value && value.match(/^([5-9]|10)$/)) {
          validParams[key] = parseInt(value);
        } else if (key === "labelstart" && value && typeof value === "string") {
          validParams[key] = value;
        } else if (key === "labelend" && value && typeof value === "string") {
          validParams[key] = value;
        } else if (key === "hidelabelstart" && value) {
          validParams[key] = value;
        } else if (key === "hidelabelend" && value) {
          validParams[key] = value;
        } else if (key === "value" && value && typeof value === "string") {
          validParams[key] = parseInt(value);
        } else {
          console.warn(
            `[FORM-FIELDS] "${name}": "${key} = ${value}" is not a valid parameter`
          );
        }
      }
      if (validParams.hidelabelstart !== void 0) {
        validParams.labelstart = "";
      }
      if (validParams.hidelabelend !== void 0) {
        validParams.labelend = "";
      }
      let validationAttrs = `data-fmd-name="${name}" data-fmd-type="num-radio"`;
      if (required) {
        validationAttrs += " data-fmd-required";
      }
      nunjucks.configure({ autoescape: false });
      return nunjucks.renderString(opinionScaleFieldTemplate, {
        startTag: `${startTag.slice(0, 9)} ${validationAttrs} ${startTag.slice(9)}`,
        name,
        inputId: id !== "" ? `${id}:id_${name}` : `id_${name}`,
        required,
        validParams,
        translations
      });
    }
    var datetimeFieldTemplate = `
{{ startTag }}
	<label class="fmd-form-question" for="{{ inputId }}">
		{{ validParams.question | safe }}
	</label>
	{% if validParams.description %}
	<p class="fmd-form-description">
		{{ validParams.description }}
	</p>
	{% endif %}
	<input
		name="{{ name }}"
		id="{{ inputId }}"
		type="{{ inputType }}"
		class="fmd-form-datetime-input fmd-form-control"
		placeholder="{{ validParams.placeholder }}"
		{% if required %}required{% endif %}
		{% if validParams.value %}value="{{ validParams.value }}"{% endif %}
		{% if validParams.min %}min="{{ validParams.min }}"{% endif %}
		{% if validParams.max %}max="{{ validParams.max }}"{% endif %}
		{% if validParams.step %}step="{{ validParams.step }}"{% endif %}
		{% if validParams.disabled %}disabled{% endif %}
		{% if validParams.autofocus %}data-fmd-autofocus{% endif %}
	>
</div>
`;
    function createDatetimeField(name, inputType, required, parsedAttrs, params, formDelimiter, id, localization) {
      const {
        startTag,
        validParams,
        restParams
      } = formFieldSetup(
        required,
        parsedAttrs,
        params,
        formDelimiter,
        localization,
        false
      );
      const translations = {};
      if (inputType === "datetime") {
        inputType = "datetime-local";
      }
      let pattern = /.*/;
      if (inputType === "datetime-local") {
        validParams.placeholder = "YYYY-MM-DDTHH:mm";
        pattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/;
      } else if (inputType === "date") {
        validParams.placeholder = "YYYY-MM-DD";
        pattern = /^\d{4}-\d{2}-\d{2}$/;
      } else if (inputType === "time") {
        validParams.placeholder = "HH:mm";
        pattern = /^\d{2}:\d{2}$/;
      }
      for (let [key, value] of Object.entries(restParams)) {
        if (key === "disabled" && value) {
          validParams[key] = value;
        } else if (key === "max" && value && value.match(pattern)) {
          validParams[key] = value;
        } else if (key === "min" && value && value.match(pattern)) {
          validParams[key] = value;
        } else if (key === "step" && value && typeof value === "string") {
          validParams[key] = value;
        } else if (key === "value" && value && value.match(pattern)) {
          validParams[key] = value;
        } else {
          console.warn(
            `[FORM-FIELDS] "${name}": "${key} = ${value}" is not a valid parameter`
          );
        }
      }
      let validationAttrs = `data-fmd-name="${name}" data-fmd-type="${inputType}"`;
      nunjucks.configure({ autoescape: false });
      return nunjucks.renderString(datetimeFieldTemplate, {
        startTag: `${startTag.slice(0, 4)} ${validationAttrs} ${startTag.slice(4)}`,
        name,
        inputId: id !== "" ? `${id}:id_${name}` : `id_${name}`,
        inputType,
        required,
        validParams,
        translations
      });
    }
    var fileFieldTemplate = `
{{ startTag }}
	<label class="fmd-form-question">
		{{ validParams.question | safe }}
	</label>
	{% if validParams.description %}
	<p class="fmd-form-description">
		{{ validParams.description }}
	</p>
	{% endif %}
	{% if validParams.currentfile %}
	<div class="fmd-current-file">
		<div class="fmd-current-file-label">
			{{ translations.fileInputCurrently }}: <a href="{{ validParams.currentfile }}">{{ validParams.currentfilename }}</a>
		</div>
		{% if not required %}
		<div class="fmd-current-file-clear">
			<div class="fmd-form-check">
				<input
					name="{{ name }}Clear"
					id="{{ inputId }}Clear"
					type="checkbox"
					class="fmd-form-file-clear-check-input fmd-form-check-input"
					value="Clear"
				>
				<label class="fmd-form-check-label" for="{{ inputId }}Clear">
					{{ translations.fileInputClearCheck | safe }}
					<span class="fmd-form-clear-mark">
						<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="fmd-icon" aria-hidden="true" focusable="false"><path d="M441 103c9.4 9.4 9.4 24.6 0 33.9L177 401c-9.4 9.4-24.6 9.4-33.9 0L7 265c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l119 119L407 103c9.4-9.4 24.6-9.4 33.9 0z"></path></svg>
					</span>
				</label>
			</div>
		</div>
		{% endif %}
	</div>
	{% endif %}
	<div class="fmd-form-file">
		<label class="fmd-form-file-label{% if validParams.disabled %} fmd-disabled{% endif %}">
			<input
				name="{{ name }}"
				id="{{ inputId }}"
				type="file"
				class="fmd-form-file-input"
				{% if required and not validParams.currentfile %}required{% endif %}
				{% if validParams.imageonly %}accept="image/*"{% endif %}
				{% if validParams.disabled %}disabled{% endif %}
				{% if validParams.autofocus %}data-fmd-autofocus{% endif %}
			>
			<span class="fmd-d-block fmd-w-auto fmd-mw-100">
				<span class="fmd-visually-hidden">
					{{ validParams.question | safe }}
				</span>
				<span class="fmd-file-empty-section">
					<span class="fmd-form-file-img-container">
						<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" class="fmd-icon" aria-hidden="true" focusable="false"><path d="M389.8 125.2C363.7 88.1 320.7 64 272 64c-77.4 0-140.5 61-143.9 137.5c-.6 13-9 24.4-21.3 28.8C63.2 245.7 32 287.2 32 336c0 61.9 50.1 112 112 112l368 0c53 0 96-43 96-96c0-36.8-20.7-68.8-51.2-84.9c-13.4-7.1-20-22.5-15.8-37.1c2-6.9 3-14.3 3-22c0-44.2-35.8-80-80-80c-12.3 0-23.9 2.8-34.3 7.7c-14.1 6.7-30.9 2.3-39.9-10.5zM272 32c59.5 0 112.1 29.5 144 74.8C430.5 99.9 446.8 96 464 96c61.9 0 112 50.1 112 112c0 10.7-1.5 21-4.3 30.8C612.3 260.2 640 302.9 640 352c0 70.7-57.3 128-128 128l-368 0C64.5 480 0 415.5 0 336c0-62.8 40.2-116.1 96.2-135.9C100.3 106.6 177.4 32 272 32zM228.7 244.7l80-80c6.2-6.2 16.4-6.2 22.6 0l80 80c6.2 6.2 6.2 16.4 0 22.6s-16.4 6.2-22.6 0L336 214.6 336 368c0 8.8-7.2 16-16 16s-16-7.2-16-16l0-153.4-52.7 52.7c-6.2 6.2-16.4 6.2-22.6 0s-6.2-16.4 0-22.6z"/></svg>
					</span>
					<span class="fmd-d-block fmd-mt-3 fmd-first-letter-uppercase">
						{% if validParams.currentfile %}{{ translations.fileInputChange }}: {% endif %}{{ translations.fileInputChoose | safe }}
					</span>
				</span>
				<span class="fmd-file-exists-section"></span>
				<span class="fmd-form-file-size-limit fmd-mt-1">
					{{ translations.fileInputSizeLimit }}: {{ validParams.sizelimit }}MB
				</span>
			</span>
		</label>
		<div class="fmd-form-file-reset-btn-container">
			<button type="button" class="fmd-form-file-reset-btn" aria-label="{{ translations.fileInputResetBtn }}">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" class="fmd-icon" aria-hidden="true" focusable="false"><path d="M345 137c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-119 119L73 103c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l119 119L39 375c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l119-119L311 409c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-119-119L345 137z"/></svg>
			</button>
		</div>
	</div>
</div>
`;
    function createFileField(name, required, parsedAttrs, params, formDelimiter, id, localization) {
      const {
        startTag,
        validParams,
        restParams
      } = formFieldSetup(
        required,
        parsedAttrs,
        params,
        formDelimiter,
        localization,
        false
      );
      const translations = {
        fileInputChange: getTranslation(localization, "file-input-change"),
        fileInputChoose: getTranslation(localization, "file-input-choose"),
        fileInputClearCheck: getTranslation(localization, "file-input-clear-check"),
        fileInputCurrently: getTranslation(localization, "file-input-currently"),
        fileInputResetBtn: getTranslation(localization, "file-input-reset-btn"),
        fileInputSizeLimit: getTranslation(localization, "file-input-size-limit")
      };
      for (let [key, value] of Object.entries(restParams)) {
        if (key === "disabled" && value) {
          validParams[key] = value;
        } else if (key === "sizelimit" && isNumeric(value)) {
          validParams[key] = Math.ceil(Math.abs(Number(value)));
        } else if (key === "imageonly" && value) {
          validParams[key] = value;
        } else if (key === "currentfile" && value && typeof value === "string") {
          validParams[key] = value;
          validParams.currentfilename = value.substring(value.lastIndexOf("/") + 1) || value;
        } else {
          console.warn(
            `[FORM-FIELDS] "${name}": "${key} = ${value}" is not a valid parameter`
          );
        }
      }
      validParams.sizelimit = validParams.sizelimit || 10;
      let validationAttrs = `data-fmd-name="${name}" data-fmd-type="file" data-fmd-size-limit="${validParams.sizelimit}"`;
      nunjucks.configure({ autoescape: false });
      return nunjucks.renderString(fileFieldTemplate, {
        startTag: `${startTag.slice(0, 4)} ${validationAttrs} ${startTag.slice(4)}`,
        name,
        inputId: id !== "" ? `${id}:id_${name}` : `id_${name}`,
        required,
        validParams,
        translations
      });
    }
    exports.formFieldPattern = formFieldPattern;
    exports.formFieldSetup = formFieldSetup;
    exports.createTextField = createTextField;
    exports.createNumberField = createNumberField;
    exports.createSelectField = createSelectField;
    exports.createChoiceField = createChoiceField;
    exports.createRatingField = createRatingField;
    exports.createOpinionScaleField = createOpinionScaleField;
    exports.createDatetimeField = createDatetimeField;
    exports.createFileField = createFileField;
  }
});

// node_modules/marked/lib/marked.cjs
var require_marked = __commonJS({
  "node_modules/marked/lib/marked.cjs"(exports) {
    "use strict";
    function _getDefaults() {
      return {
        async: false,
        breaks: false,
        extensions: null,
        gfm: true,
        hooks: null,
        pedantic: false,
        renderer: null,
        silent: false,
        tokenizer: null,
        walkTokens: null
      };
    }
    exports.defaults = _getDefaults();
    function changeDefaults(newDefaults) {
      exports.defaults = newDefaults;
    }
    var escapeTest = /[&<>"']/;
    var escapeReplace = new RegExp(escapeTest.source, "g");
    var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
    var escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape$1(html2, encode) {
      if (encode) {
        if (escapeTest.test(html2)) {
          return html2.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html2)) {
          return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html2;
    }
    var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape(html2) {
      return html2.replace(unescapeTest, (_, n) => {
        n = n.toLowerCase();
        if (n === "colon")
          return ":";
        if (n.charAt(0) === "#") {
          return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return "";
      });
    }
    var caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
      let source = typeof regex === "string" ? regex : regex.source;
      opt = opt || "";
      const obj = {
        replace: (name, val) => {
          let valSource = typeof val === "string" ? val : val.source;
          valSource = valSource.replace(caret, "$1");
          source = source.replace(name, valSource);
          return obj;
        },
        getRegex: () => {
          return new RegExp(source, opt);
        }
      };
      return obj;
    }
    function cleanUrl(href) {
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e) {
        return null;
      }
      return href;
    }
    var noopTest = { exec: () => null };
    function splitCells(tableRow, count) {
      const row = tableRow.replace(/\|/g, (match, offset, str) => {
        let escaped = false;
        let curr = offset;
        while (--curr >= 0 && str[curr] === "\\")
          escaped = !escaped;
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      let i = 0;
      if (!cells[0].trim()) {
        cells.shift();
      }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) {
        cells.pop();
      }
      if (count) {
        if (cells.length > count) {
          cells.splice(count);
        } else {
          while (cells.length < count)
            cells.push("");
        }
      }
      for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
        return "";
      }
      let suffLen = 0;
      while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.slice(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      let level = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === "\\") {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }
    function outputLink(cap, link2, raw, lexer2) {
      const href = link2.href;
      const title = link2.title ? escape$1(link2.title) : null;
      const text = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        lexer2.state.inLink = true;
        const token = {
          type: "link",
          raw,
          href,
          title,
          text,
          tokens: lexer2.inlineTokens(text)
        };
        lexer2.state.inLink = false;
        return token;
      }
      return {
        type: "image",
        raw,
        href,
        title,
        text: escape$1(text)
      };
    }
    function indentCodeCompensation(raw, text) {
      const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text;
      }
      const indentToCode = matchIndentToCode[1];
      return text.split("\n").map((node) => {
        const matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    var _Tokenizer = class {
      // set by the lexer
      constructor(options2) {
        __publicField(this, "options");
        __publicField(this, "rules");
        // set by the lexer
        __publicField(this, "lexer");
        this.options = options2 || exports.defaults;
      }
      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
      }
      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text, "\n") : text
          };
        }
      }
      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
            text
          };
        }
      }
      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text = cap[2].trim();
          if (/#$/.test(text)) {
            const trimmed = rtrim(text, "#");
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }
      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }
      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          let text = cap[0].replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, "\n    $1");
          text = rtrim(text.replace(/^ *>[ \t]?/gm, ""), "\n");
          const top = this.lexer.state.top;
          this.lexer.state.top = true;
          const tokens = this.lexer.blockTokens(text);
          this.lexer.state.top = top;
          return {
            type: "blockquote",
            raw: cap[0],
            tokens,
            text
          };
        }
      }
      list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
          let bull = cap[1].trim();
          const isordered = bull.length > 1;
          const list2 = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
          let raw = "";
          let itemContents = "";
          let endsWithBlankLine = false;
          while (src) {
            let endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
            let nextLine = src.split("\n", 1)[0];
            let indent = 0;
            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimStart();
            } else {
              indent = cap[2].search(/[^ ]/);
              indent = indent > 4 ? 1 : indent;
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }
            let blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + "\n";
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
              const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
              const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
              const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
              while (src) {
                const rawLine = src.split("\n", 1)[0];
                nextLine = rawLine;
                if (this.options.pedantic) {
                  nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                }
                if (fencesBeginRegex.test(nextLine)) {
                  break;
                }
                if (headingBeginRegex.test(nextLine)) {
                  break;
                }
                if (nextBulletRegex.test(nextLine)) {
                  break;
                }
                if (hrRegex.test(src)) {
                  break;
                }
                if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
                  itemContents += "\n" + nextLine.slice(indent);
                } else {
                  if (blankLine) {
                    break;
                  }
                  if (line.search(/[^ ]/) >= 4) {
                    break;
                  }
                  if (fencesBeginRegex.test(line)) {
                    break;
                  }
                  if (headingBeginRegex.test(line)) {
                    break;
                  }
                  if (hrRegex.test(line)) {
                    break;
                  }
                  itemContents += "\n" + nextLine;
                }
                if (!blankLine && !nextLine.trim()) {
                  blankLine = true;
                }
                raw += rawLine + "\n";
                src = src.substring(rawLine.length + 1);
                line = nextLine.slice(indent);
              }
            }
            if (!list2.loose) {
              if (endsWithBlankLine) {
                list2.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            let istask = null;
            let ischecked;
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents,
              tokens: []
            });
            list2.raw += raw;
          }
          list2.items[list2.items.length - 1].raw = raw.trimEnd();
          list2.items[list2.items.length - 1].text = itemContents.trimEnd();
          list2.raw = list2.raw.trimEnd();
          for (let i = 0; i < list2.items.length; i++) {
            this.lexer.state.top = false;
            list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
            if (!list2.loose) {
              const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
              const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
              list2.loose = hasMultipleLineBreaks;
            }
          }
          if (list2.loose) {
            for (let i = 0; i < list2.items.length; i++) {
              list2.items[i].loose = true;
            }
          }
          return list2;
        }
      }
      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          const token = {
            type: "html",
            block: true,
            raw: cap[0],
            pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
            text: cap[0]
          };
          return token;
        }
      }
      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          const tag2 = cap[1].toLowerCase().replace(/\s+/g, " ");
          const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
          const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
          return {
            type: "def",
            tag: tag2,
            raw: cap[0],
            href,
            title
          };
        }
      }
      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (!cap) {
          return;
        }
        if (!/[:|]/.test(cap[2])) {
          return;
        }
        const headers = splitCells(cap[1]);
        const aligns = cap[2].replace(/^\||\| *$/g, "").split("|");
        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : [];
        const item = {
          type: "table",
          raw: cap[0],
          header: [],
          align: [],
          rows: []
        };
        if (headers.length !== aligns.length) {
          return;
        }
        for (const align of aligns) {
          if (/^ *-+: *$/.test(align)) {
            item.align.push("right");
          } else if (/^ *:-+: *$/.test(align)) {
            item.align.push("center");
          } else if (/^ *:-+ *$/.test(align)) {
            item.align.push("left");
          } else {
            item.align.push(null);
          }
        }
        for (const header of headers) {
          item.header.push({
            text: header,
            tokens: this.lexer.inline(header)
          });
        }
        for (const row of rows) {
          item.rows.push(splitCells(row, item.header.length).map((cell) => {
            return {
              text: cell,
              tokens: this.lexer.inline(cell)
            };
          }));
        }
        return item;
      }
      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: this.lexer.inline(cap[1])
          };
        }
      }
      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
          return {
            type: "paragraph",
            raw: cap[0],
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }
      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: this.lexer.inline(cap[0])
          };
        }
      }
      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape$1(cap[1])
          };
        }
      }
      tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: false,
            text: cap[0]
          };
        }
      }
      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            const lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf("!") === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          let href = cap[2];
          let title = "";
          if (this.options.pedantic) {
            const link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link2) {
              href = link2[1];
              title = link2[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
            title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
          }, cap[0], this.lexer);
        }
      }
      reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          const linkString = (cap[2] || cap[1]).replace(/\s+/g, " ");
          const link2 = links[linkString.toLowerCase()];
          if (!link2) {
            const text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          return outputLink(cap, link2, cap[0], this.lexer);
        }
      }
      emStrong(src, maskedSrc, prevChar = "") {
        let match = this.rules.inline.emStrongLDelim.exec(src);
        if (!match)
          return;
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
          return;
        const nextChar = match[1] || match[2] || "";
        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
          const lLength = [...match[0]].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim)
              continue;
            rLength = [...rDelim].length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0)
              continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            const lastCharLength = [...match[0]][0].length;
            const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
            if (Math.min(lLength, rLength) % 2) {
              const text2 = raw.slice(1, -1);
              return {
                type: "em",
                raw,
                text: text2,
                tokens: this.lexer.inlineTokens(text2)
              };
            }
            const text = raw.slice(2, -2);
            return {
              type: "strong",
              raw,
              text,
              tokens: this.lexer.inlineTokens(text)
            };
          }
        }
      }
      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text = cap[2].replace(/\n/g, " ");
          const hasNonSpaceChars = /[^ ]/.test(text);
          const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape$1(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      }
      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }
      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2])
          };
        }
      }
      autolink(src) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text, href;
          if (cap[2] === "@") {
            text = escape$1(cap[1]);
            href = "mailto:" + text;
          } else {
            text = escape$1(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      url(src) {
        var _a;
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text, href;
          if (cap[2] === "@") {
            text = escape$1(cap[0]);
            href = "mailto:" + text;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = ((_a = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a[0]) ?? "";
            } while (prevCapZero !== cap[0]);
            text = escape$1(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + cap[0];
            } else {
              href = cap[0];
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      inlineText(src) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text;
          if (this.lexer.state.inRawBlock) {
            text = cap[0];
          } else {
            text = escape$1(cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      }
    };
    var newline = /^(?: *(?:\n|$))+/;
    var blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/;
    var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
    var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
    var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
    var bullet = /(?:[*+-]|\d{1,9}[.)])/;
    var lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).replace(/blockCode/g, / {4}/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex();
    var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
    var blockText = /^[^\n]+/;
    var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    var def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
    var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
    var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
    var html = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
    var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
    var blockNormal = {
      blockquote,
      code: blockCode,
      def,
      fences,
      heading,
      hr,
      html,
      lheading,
      list,
      newline,
      paragraph,
      table: noopTest,
      text: blockText
    };
    var gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
    var blockGfm = {
      ...blockNormal,
      table: gfmTable,
      paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
    };
    var blockPedantic = {
      ...blockNormal,
      html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      // fences not supported
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
    };
    var escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
    var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
    var br = /^( {2,}|\\)\n(?!\s*$)/;
    var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
    var _punctuation = "\\p{P}\\p{S}";
    var punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex();
    var blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
    var emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex();
    var emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex();
    var emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex();
    var anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex();
    var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
    var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
    var tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
    var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    var link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
    var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
    var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
    var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
    var inlineNormal = {
      _backpedal: noopTest,
      // only used for GFM url
      anyPunctuation,
      autolink,
      blockSkip,
      br,
      code: inlineCode,
      del: noopTest,
      emStrongLDelim,
      emStrongRDelimAst,
      emStrongRDelimUnd,
      escape,
      link,
      nolink,
      punctuation,
      reflink,
      reflinkSearch,
      tag,
      text: inlineText,
      url: noopTest
    };
    var inlinePedantic = {
      ...inlineNormal,
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
    };
    var inlineGfm = {
      ...inlineNormal,
      escape: edit(escape).replace("])", "~|])").getRegex(),
      url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    };
    var inlineBreaks = {
      ...inlineGfm,
      br: edit(br).replace("{2,}", "*").getRegex(),
      text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    };
    var block = {
      normal: blockNormal,
      gfm: blockGfm,
      pedantic: blockPedantic
    };
    var inline = {
      normal: inlineNormal,
      gfm: inlineGfm,
      breaks: inlineBreaks,
      pedantic: inlinePedantic
    };
    var _Lexer = class __Lexer {
      constructor(options2) {
        __publicField(this, "tokens");
        __publicField(this, "options");
        __publicField(this, "state");
        __publicField(this, "tokenizer");
        __publicField(this, "inlineQueue");
        this.tokens = [];
        this.tokens.links = /* @__PURE__ */ Object.create(null);
        this.options = options2 || exports.defaults;
        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        const rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block,
          inline
        };
      }
      /**
       * Static Lex Method
       */
      static lex(src, options2) {
        const lexer2 = new __Lexer(options2);
        return lexer2.lex(src);
      }
      /**
       * Static Lex Inline Method
       */
      static lexInline(src, options2) {
        const lexer2 = new __Lexer(options2);
        return lexer2.inlineTokens(src);
      }
      /**
       * Preprocessing
       */
      lex(src) {
        src = src.replace(/\r\n|\r/g, "\n");
        this.blockTokens(src, this.tokens);
        for (let i = 0; i < this.inlineQueue.length; i++) {
          const next = this.inlineQueue[i];
          this.inlineTokens(next.src, next.tokens);
        }
        this.inlineQueue = [];
        return this.tokens;
      }
      blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
          src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
        } else {
          src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
            return leading + "    ".repeat(tabs.length);
          });
        }
        let token;
        let lastToken;
        let cutSrc;
        let lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += "\n";
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach((getStartIndex) => {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      }
      inline(src, tokens = []) {
        this.inlineQueue.push({ src, tokens });
        return tokens;
      }
      /**
       * Lexing/Compiling
       */
      inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach((getStartIndex) => {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    };
    var _Renderer = class {
      constructor(options2) {
        __publicField(this, "options");
        this.options = options2 || exports.defaults;
      }
      code(code, infostring, escaped) {
        var _a;
        const lang = (_a = (infostring || "").match(/^\S*/)) == null ? void 0 : _a[0];
        code = code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="language-' + escape$1(lang) + '">' + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
      }
      blockquote(quote) {
        return `<blockquote>
${quote}</blockquote>
`;
      }
      html(html2, block2) {
        return html2;
      }
      heading(text, level, raw) {
        return `<h${level}>${text}</h${level}>
`;
      }
      hr() {
        return "<hr>\n";
      }
      list(body, ordered, start) {
        const type = ordered ? "ol" : "ul";
        const startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      }
      listitem(text, task, checked) {
        return `<li>${text}</li>
`;
      }
      checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
      }
      paragraph(text) {
        return `<p>${text}</p>
`;
      }
      table(header, body) {
        if (body)
          body = `<tbody>${body}</tbody>`;
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      }
      tablerow(content) {
        return `<tr>
${content}</tr>
`;
      }
      tablecell(content, flags) {
        const type = flags.header ? "th" : "td";
        const tag2 = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
        return tag2 + content + `</${type}>
`;
      }
      /**
       * span level renderer
       */
      strong(text) {
        return `<strong>${text}</strong>`;
      }
      em(text) {
        return `<em>${text}</em>`;
      }
      codespan(text) {
        return `<code>${text}</code>`;
      }
      br() {
        return "<br>";
      }
      del(text) {
        return `<del>${text}</del>`;
      }
      link(href, title, text) {
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
          return text;
        }
        href = cleanHref;
        let out = '<a href="' + href + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      }
      image(href, title, text) {
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
          return text;
        }
        href = cleanHref;
        let out = `<img src="${href}" alt="${text}"`;
        if (title) {
          out += ` title="${title}"`;
        }
        out += ">";
        return out;
      }
      text(text) {
        return text;
      }
    };
    var _TextRenderer = class {
      // no need for block level renderers
      strong(text) {
        return text;
      }
      em(text) {
        return text;
      }
      codespan(text) {
        return text;
      }
      del(text) {
        return text;
      }
      html(text) {
        return text;
      }
      text(text) {
        return text;
      }
      link(href, title, text) {
        return "" + text;
      }
      image(href, title, text) {
        return "" + text;
      }
      br() {
        return "";
      }
    };
    var _Parser = class __Parser {
      constructor(options2) {
        __publicField(this, "options");
        __publicField(this, "renderer");
        __publicField(this, "textRenderer");
        this.options = options2 || exports.defaults;
        this.options.renderer = this.options.renderer || new _Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new _TextRenderer();
      }
      /**
       * Static Parse Method
       */
      static parse(tokens, options2) {
        const parser2 = new __Parser(options2);
        return parser2.parse(tokens);
      }
      /**
       * Static Parse Inline Method
       */
      static parseInline(tokens, options2) {
        const parser2 = new __Parser(options2);
        return parser2.parseInline(tokens);
      }
      /**
       * Parse Loop
       */
      parse(tokens, top = true) {
        let out = "";
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            const genericToken = token;
            const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              const headingToken = token;
              out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));
              continue;
            }
            case "code": {
              const codeToken = token;
              out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
              continue;
            }
            case "table": {
              const tableToken = token;
              let header = "";
              let cell = "";
              for (let j = 0; j < tableToken.header.length; j++) {
                cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });
              }
              header += this.renderer.tablerow(cell);
              let body = "";
              for (let j = 0; j < tableToken.rows.length; j++) {
                const row = tableToken.rows[j];
                cell = "";
                for (let k = 0; k < row.length; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              const blockquoteToken = token;
              const body = this.parse(blockquoteToken.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              const listToken = token;
              const ordered = listToken.ordered;
              const start = listToken.start;
              const loose = listToken.loose;
              let body = "";
              for (let j = 0; j < listToken.items.length; j++) {
                const item = listToken.items[j];
                const checked = item.checked;
                const task = item.task;
                let itemBody = "";
                if (item.task) {
                  const checkbox = this.renderer.checkbox(!!checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox + " "
                      });
                    }
                  } else {
                    itemBody += checkbox + " ";
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, !!checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              const htmlToken = token;
              out += this.renderer.html(htmlToken.text, htmlToken.block);
              continue;
            }
            case "paragraph": {
              const paragraphToken = token;
              out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
              continue;
            }
            case "text": {
              let textToken = token;
              let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
              while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
                textToken = tokens[++i];
                body += "\n" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return "";
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
      /**
       * Parse Inline Tokens
       */
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = "";
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              const escapeToken = token;
              out += renderer.text(escapeToken.text);
              break;
            }
            case "html": {
              const tagToken = token;
              out += renderer.html(tagToken.text);
              break;
            }
            case "link": {
              const linkToken = token;
              out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
              break;
            }
            case "image": {
              const imageToken = token;
              out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
              break;
            }
            case "strong": {
              const strongToken = token;
              out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
              break;
            }
            case "em": {
              const emToken = token;
              out += renderer.em(this.parseInline(emToken.tokens, renderer));
              break;
            }
            case "codespan": {
              const codespanToken = token;
              out += renderer.codespan(codespanToken.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              const delToken = token;
              out += renderer.del(this.parseInline(delToken.tokens, renderer));
              break;
            }
            case "text": {
              const textToken = token;
              out += renderer.text(textToken.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return "";
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    };
    var _Hooks = class {
      constructor(options2) {
        __publicField(this, "options");
        this.options = options2 || exports.defaults;
      }
      /**
       * Process markdown before marked
       */
      preprocess(markdown) {
        return markdown;
      }
      /**
       * Process HTML after marked is finished
       */
      postprocess(html2) {
        return html2;
      }
      /**
       * Process all tokens before walk tokens
       */
      processAllTokens(tokens) {
        return tokens;
      }
    };
    __publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
      "preprocess",
      "postprocess",
      "processAllTokens"
    ]));
    var _Marked_instances, parseMarkdown_fn, onError_fn;
    var Marked = class {
      constructor(...args) {
        __privateAdd(this, _Marked_instances);
        __publicField(this, "defaults", _getDefaults());
        __publicField(this, "options", this.setOptions);
        __publicField(this, "parse", __privateMethod(this, _Marked_instances, parseMarkdown_fn).call(this, _Lexer.lex, _Parser.parse));
        __publicField(this, "parseInline", __privateMethod(this, _Marked_instances, parseMarkdown_fn).call(this, _Lexer.lexInline, _Parser.parseInline));
        __publicField(this, "Parser", _Parser);
        __publicField(this, "Renderer", _Renderer);
        __publicField(this, "TextRenderer", _TextRenderer);
        __publicField(this, "Lexer", _Lexer);
        __publicField(this, "Tokenizer", _Tokenizer);
        __publicField(this, "Hooks", _Hooks);
        this.use(...args);
      }
      /**
       * Run callback for every token
       */
      walkTokens(tokens, callback) {
        var _a, _b;
        let values = [];
        for (const token of tokens) {
          values = values.concat(callback.call(this, token));
          switch (token.type) {
            case "table": {
              const tableToken = token;
              for (const cell of tableToken.header) {
                values = values.concat(this.walkTokens(cell.tokens, callback));
              }
              for (const row of tableToken.rows) {
                for (const cell of row) {
                  values = values.concat(this.walkTokens(cell.tokens, callback));
                }
              }
              break;
            }
            case "list": {
              const listToken = token;
              values = values.concat(this.walkTokens(listToken.items, callback));
              break;
            }
            default: {
              const genericToken = token;
              if ((_b = (_a = this.defaults.extensions) == null ? void 0 : _a.childTokens) == null ? void 0 : _b[genericToken.type]) {
                this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                  const tokens2 = genericToken[childTokens].flat(Infinity);
                  values = values.concat(this.walkTokens(tokens2, callback));
                });
              } else if (genericToken.tokens) {
                values = values.concat(this.walkTokens(genericToken.tokens, callback));
              }
            }
          }
        }
        return values;
      }
      use(...args) {
        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
        args.forEach((pack) => {
          const opts = { ...pack };
          opts.async = this.defaults.async || opts.async || false;
          if (pack.extensions) {
            pack.extensions.forEach((ext) => {
              if (!ext.name) {
                throw new Error("extension name required");
              }
              if ("renderer" in ext) {
                const prevRenderer = extensions.renderers[ext.name];
                if (prevRenderer) {
                  extensions.renderers[ext.name] = function(...args2) {
                    let ret = ext.renderer.apply(this, args2);
                    if (ret === false) {
                      ret = prevRenderer.apply(this, args2);
                    }
                    return ret;
                  };
                } else {
                  extensions.renderers[ext.name] = ext.renderer;
                }
              }
              if ("tokenizer" in ext) {
                if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                  throw new Error("extension level must be 'block' or 'inline'");
                }
                const extLevel = extensions[ext.level];
                if (extLevel) {
                  extLevel.unshift(ext.tokenizer);
                } else {
                  extensions[ext.level] = [ext.tokenizer];
                }
                if (ext.start) {
                  if (ext.level === "block") {
                    if (extensions.startBlock) {
                      extensions.startBlock.push(ext.start);
                    } else {
                      extensions.startBlock = [ext.start];
                    }
                  } else if (ext.level === "inline") {
                    if (extensions.startInline) {
                      extensions.startInline.push(ext.start);
                    } else {
                      extensions.startInline = [ext.start];
                    }
                  }
                }
              }
              if ("childTokens" in ext && ext.childTokens) {
                extensions.childTokens[ext.name] = ext.childTokens;
              }
            });
            opts.extensions = extensions;
          }
          if (pack.renderer) {
            const renderer = this.defaults.renderer || new _Renderer(this.defaults);
            for (const prop in pack.renderer) {
              if (!(prop in renderer)) {
                throw new Error(`renderer '${prop}' does not exist`);
              }
              if (prop === "options") {
                continue;
              }
              const rendererProp = prop;
              const rendererFunc = pack.renderer[rendererProp];
              const prevRenderer = renderer[rendererProp];
              renderer[rendererProp] = (...args2) => {
                let ret = rendererFunc.apply(renderer, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(renderer, args2);
                }
                return ret || "";
              };
            }
            opts.renderer = renderer;
          }
          if (pack.tokenizer) {
            const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
            for (const prop in pack.tokenizer) {
              if (!(prop in tokenizer)) {
                throw new Error(`tokenizer '${prop}' does not exist`);
              }
              if (["options", "rules", "lexer"].includes(prop)) {
                continue;
              }
              const tokenizerProp = prop;
              const tokenizerFunc = pack.tokenizer[tokenizerProp];
              const prevTokenizer = tokenizer[tokenizerProp];
              tokenizer[tokenizerProp] = (...args2) => {
                let ret = tokenizerFunc.apply(tokenizer, args2);
                if (ret === false) {
                  ret = prevTokenizer.apply(tokenizer, args2);
                }
                return ret;
              };
            }
            opts.tokenizer = tokenizer;
          }
          if (pack.hooks) {
            const hooks = this.defaults.hooks || new _Hooks();
            for (const prop in pack.hooks) {
              if (!(prop in hooks)) {
                throw new Error(`hook '${prop}' does not exist`);
              }
              if (prop === "options") {
                continue;
              }
              const hooksProp = prop;
              const hooksFunc = pack.hooks[hooksProp];
              const prevHook = hooks[hooksProp];
              if (_Hooks.passThroughHooks.has(prop)) {
                hooks[hooksProp] = (arg) => {
                  if (this.defaults.async) {
                    return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                      return prevHook.call(hooks, ret2);
                    });
                  }
                  const ret = hooksFunc.call(hooks, arg);
                  return prevHook.call(hooks, ret);
                };
              } else {
                hooks[hooksProp] = (...args2) => {
                  let ret = hooksFunc.apply(hooks, args2);
                  if (ret === false) {
                    ret = prevHook.apply(hooks, args2);
                  }
                  return ret;
                };
              }
            }
            opts.hooks = hooks;
          }
          if (pack.walkTokens) {
            const walkTokens2 = this.defaults.walkTokens;
            const packWalktokens = pack.walkTokens;
            opts.walkTokens = function(token) {
              let values = [];
              values.push(packWalktokens.call(this, token));
              if (walkTokens2) {
                values = values.concat(walkTokens2.call(this, token));
              }
              return values;
            };
          }
          this.defaults = { ...this.defaults, ...opts };
        });
        return this;
      }
      setOptions(opt) {
        this.defaults = { ...this.defaults, ...opt };
        return this;
      }
      lexer(src, options2) {
        return _Lexer.lex(src, options2 ?? this.defaults);
      }
      parser(tokens, options2) {
        return _Parser.parse(tokens, options2 ?? this.defaults);
      }
    };
    _Marked_instances = new WeakSet();
    parseMarkdown_fn = function(lexer2, parser2) {
      return (src, options2) => {
        const origOpt = { ...options2 };
        const opt = { ...this.defaults, ...origOpt };
        if (this.defaults.async === true && origOpt.async === false) {
          if (!opt.silent) {
            console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.");
          }
          opt.async = true;
        }
        const throwError = __privateMethod(this, _Marked_instances, onError_fn).call(this, !!opt.silent, !!opt.async);
        if (typeof src === "undefined" || src === null) {
          return throwError(new Error("marked(): input parameter is undefined or null"));
        }
        if (typeof src !== "string") {
          return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
        }
        if (opt.hooks) {
          opt.hooks.options = opt;
        }
        if (opt.async) {
          return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
        }
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          let tokens = lexer2(src, opt);
          if (opt.hooks) {
            tokens = opt.hooks.processAllTokens(tokens);
          }
          if (opt.walkTokens) {
            this.walkTokens(tokens, opt.walkTokens);
          }
          let html2 = parser2(tokens, opt);
          if (opt.hooks) {
            html2 = opt.hooks.postprocess(html2);
          }
          return html2;
        } catch (e) {
          return throwError(e);
        }
      };
    };
    onError_fn = function(silent, async) {
      return (e) => {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (silent) {
          const msg = "<p>An error occurred:</p><pre>" + escape$1(e.message + "", true) + "</pre>";
          if (async) {
            return Promise.resolve(msg);
          }
          return msg;
        }
        if (async) {
          return Promise.reject(e);
        }
        throw e;
      };
    };
    var markedInstance = new Marked();
    function marked(src, opt) {
      return markedInstance.parse(src, opt);
    }
    marked.options = marked.setOptions = function(options2) {
      markedInstance.setOptions(options2);
      marked.defaults = markedInstance.defaults;
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.getDefaults = _getDefaults;
    marked.defaults = exports.defaults;
    marked.use = function(...args) {
      markedInstance.use(...args);
      marked.defaults = markedInstance.defaults;
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.walkTokens = function(tokens, callback) {
      return markedInstance.walkTokens(tokens, callback);
    };
    marked.parseInline = markedInstance.parseInline;
    marked.Parser = _Parser;
    marked.parser = _Parser.parse;
    marked.Renderer = _Renderer;
    marked.TextRenderer = _TextRenderer;
    marked.Lexer = _Lexer;
    marked.lexer = _Lexer.lex;
    marked.Tokenizer = _Tokenizer;
    marked.Hooks = _Hooks;
    marked.parse = marked;
    var options = marked.options;
    var setOptions = marked.setOptions;
    var use = marked.use;
    var walkTokens = marked.walkTokens;
    var parseInline = marked.parseInline;
    var parse = marked;
    var parser = _Parser.parse;
    var lexer = _Lexer.lex;
    exports.Hooks = _Hooks;
    exports.Lexer = _Lexer;
    exports.Marked = Marked;
    exports.Parser = _Parser;
    exports.Renderer = _Renderer;
    exports.TextRenderer = _TextRenderer;
    exports.Tokenizer = _Tokenizer;
    exports.getDefaults = _getDefaults;
    exports.lexer = lexer;
    exports.marked = marked;
    exports.options = options;
    exports.parse = parse;
    exports.parseInline = parseInline;
    exports.parser = parser;
    exports.setOptions = setOptions;
    exports.use = use;
    exports.walkTokens = walkTokens;
  }
});

// node_modules/formsmd/src/marked-renderer.js
var require_marked_renderer = __commonJS({
  "node_modules/formsmd/src/marked-renderer.js"(exports) {
    "use strict";
    var { parseElemAttrs, addReservedClass } = require_attrs_parse();
    var {
      formFieldPattern,
      createTextField,
      createNumberField,
      createSelectField,
      createChoiceField,
      createRatingField,
      createOpinionScaleField,
      createDatetimeField,
      createFileField
    } = require_form_field_create();
    var { escape$1, cleanUrl } = require_helpers();
    var { getTranslation } = require_translations();
    var { marked } = require_marked();
    function getMarkedSettings(options) {
      let markedSettings = {
        "css-prefix": "fmd-",
        "form-delimiter": "|",
        "id": "",
        "localization": "en"
      };
      if (options.markedSettings === void 0) {
        return markedSettings;
      }
      if (options.markedSettings["css-prefix"] !== void 0) {
        markedSettings["css-prefix"] = options.markedSettings["css-prefix"];
      }
      if (options.markedSettings["form-delimiter"] !== void 0) {
        markedSettings["form-delimiter"] = options.markedSettings["form-delimiter"];
      }
      if (options.markedSettings.id !== void 0) {
        markedSettings.id = options.markedSettings.id;
      }
      if (options.markedSettings.localization !== void 0) {
        markedSettings.localization = options.markedSettings.localization;
      }
      return markedSettings;
    }
    var renderer = new marked.Renderer();
    renderer.blockquote = function(quote) {
      quote = quote.trim();
      const containsParagraph = quote.match(/^<p(.*?)>(.*?)<\/p>$/s);
      if (containsParagraph) {
        return `<blockquote${containsParagraph[1]}>
<p>${containsParagraph[2]}</p>
</blockquote>
`;
      } else {
        return `<blockquote>
${quote}</blockquote>
`;
      }
    };
    renderer.checkbox = function(checked) {
      const markedSettings = getMarkedSettings(this.options);
      if (checked) {
        return `<div role="checkbox" class="fmd-list-check fmd-list-checked" aria-label="${getTranslation(markedSettings.localization, "list-checked")}" aria-checked="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="fmd-icon" aria-hidden="true" focusable="false"><path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"/></svg></div>`;
      } else {
        return `<div role="checkbox" class="fmd-list-check" aria-label="${getTranslation(markedSettings.localization, "list-check")}" aria-checked="false"></div>`;
      }
    };
    renderer.code = function(code, infostring, escaped) {
      const markedSettings = getMarkedSettings(this.options);
      infostring = infostring || "";
      let startTag = '<div class="fmd-code-wrapper">';
      const startAttrsIndex = infostring.indexOf("[");
      const endAttrsIndex = infostring.indexOf("]");
      let parsedAttrs = "";
      if (startAttrsIndex !== -1 && endAttrsIndex !== -1) {
        const attrs = infostring.substring(startAttrsIndex + 1, endAttrsIndex).trim();
        infostring = infostring.substring(0, startAttrsIndex) + infostring.substring(endAttrsIndex + 1);
        infostring = infostring.trim();
        parsedAttrs = parseElemAttrs(attrs, markedSettings["css-prefix"]);
        startTag = `<div ${parsedAttrs}>`;
        startTag = addReservedClass(startTag, "fmd-code-wrapper");
      }
      let lang = "";
      const containsLang = infostring.match(/^\S*/);
      if (containsLang) {
        lang = containsLang[0];
      }
      code = code.replace(/\n$/, "") + "\n";
      if (lang.toLowerCase() === "mermaid") {
        startTag = parsedAttrs ? `<div ${parsedAttrs}>` : "<div>";
        startTag = addReservedClass(startTag, "fmd-mermaid-wrapper");
        return [
          `${startTag}`,
          `	<pre class="mermaid">${code}</pre>`,
          `</div>
`
        ].join("\n");
      }
      if (!escaped) {
        code = escape$1(code, true);
      }
      let langClass = "";
      if (lang) {
        langClass = ` class="language-${escape$1(lang, true)}"`;
      }
      return [
        `${startTag}`,
        `	<div class="fmd-code-header"><span>${lang}</span><button type="button" class="fmd-copy-btn">${getTranslation(markedSettings.localization, "copy-btn")}</button></div>`,
        `	<pre tabindex="0"><code${langClass}>${code}</code></pre>`,
        `</div>
`
      ].join("\n");
    };
    renderer.heading = function(text, level, raw) {
      const markedSettings = getMarkedSettings(this.options);
      text = text.trim();
      let startTag = `<h${level}>`;
      const containsAttrs = text.match(/^\[(.*?)\](.*)/s);
      if (containsAttrs) {
        let [, attrs, rest] = containsAttrs;
        startTag = `<h${level} ${parseElemAttrs(attrs, markedSettings["css-prefix"])}>`;
        text = rest.trim();
      }
      let id;
      const containsId = startTag.match(/id="([^"]*)"/);
      if (containsId) {
        id = containsId[1];
      } else {
        id = text.replace(/(<([^>]+)>)/gi, "").toLowerCase().replace(/[^a-z0-9 -]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-");
        if (markedSettings.id !== "") {
          id = `${markedSettings.id}:${id}`;
        }
        startTag = startTag.replace(/<([^\s>]+)/, `<$1 id="${id}"`);
      }
      return `${startTag}${text}&nbsp;<a href="#${id}" class="fmd-heading-anchor">#</a></h${level}>
`;
    };
    renderer.image = function(href, title, text) {
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return text;
      }
      href = cleanHref;
      let out = `<img src="${href}" loading="lazy" alt="${text}"`;
      if (title) {
        out += ` title="${title}"`;
      }
      out += ">";
      return out;
    };
    renderer.list = function(body, ordered, start) {
      const markedSettings = getMarkedSettings(this.options);
      const type = ordered ? "ol" : "ul";
      let startAttr = "";
      if (ordered) {
        if (start !== 0 && start !== 1) {
          startAttr = ` start="${start}"`;
        }
      }
      let startTag = `<${type}${startAttr}>`;
      const containsFirstItem = body.match(/<li>(.*?)<\/li>/);
      if (containsFirstItem) {
        const firstItem = containsFirstItem[1].trim();
        const containsAttrs = firstItem.match(/^\[(.*?)\](.*)/s);
        if (containsAttrs) {
          startTag = `<${type}${startAttr} ${parseElemAttrs(containsAttrs[1], markedSettings["css-prefix"])}>`;
          body = body.replace(/<li>(.*?)<\/li>/, "").trim();
        }
      }
      return `${startTag}
${body}</${type}>
`;
    };
    renderer.paragraph = function(text) {
      const markedSettings = getMarkedSettings(this.options);
      text = text.trim();
      let startTag = "<p>";
      let parsedAttrs = "";
      const containsAttrs = text.match(/^\[(.*?)\](.*)/s);
      if (containsAttrs) {
        let [, attrs, rest] = containsAttrs;
        parsedAttrs = parseElemAttrs(attrs, markedSettings["css-prefix"]);
        startTag = `<p ${parsedAttrs}>`;
        text = rest.trim();
      }
      const matchesFormField = text.match(formFieldPattern);
      if (matchesFormField) {
        const fieldName = matchesFormField[1];
        const fieldInputType = matchesFormField[3].toLowerCase();
        const fieldRequired = matchesFormField[2] ? true : false;
        const fieldParams = matchesFormField[4].replace(/(<([^>]+)>)/gi, "");
        try {
          if (fieldInputType === "textinput" || fieldInputType === "emailinput" || fieldInputType === "urlinput" || fieldInputType === "telinput" || fieldInputType === "passwordinput") {
            return createTextField(
              fieldName,
              fieldInputType.replace("input", ""),
              fieldRequired,
              parsedAttrs,
              fieldParams,
              markedSettings["form-delimiter"],
              markedSettings.id,
              markedSettings.localization
            );
          } else if (fieldInputType === "numberinput") {
            return createNumberField(
              fieldName,
              fieldRequired,
              parsedAttrs,
              fieldParams,
              markedSettings["form-delimiter"],
              markedSettings.id,
              markedSettings.localization
            );
          } else if (fieldInputType === "selectbox") {
            return createSelectField(
              fieldName,
              fieldRequired,
              parsedAttrs,
              fieldParams,
              markedSettings["form-delimiter"],
              markedSettings.id,
              markedSettings.localization
            );
          } else if (fieldInputType === "choiceinput" || fieldInputType === "picturechoice") {
            return createChoiceField(
              fieldName,
              fieldInputType === "picturechoice" ? true : false,
              fieldRequired,
              parsedAttrs,
              fieldParams,
              markedSettings["form-delimiter"],
              markedSettings.id,
              markedSettings.localization
            );
          } else if (fieldInputType === "ratinginput") {
            return createRatingField(
              fieldName,
              fieldRequired,
              parsedAttrs,
              fieldParams,
              markedSettings["form-delimiter"],
              markedSettings.id,
              markedSettings.localization
            );
          } else if (fieldInputType === "opinionscale") {
            return createOpinionScaleField(
              fieldName,
              fieldRequired,
              parsedAttrs,
              fieldParams,
              markedSettings["form-delimiter"],
              markedSettings.id,
              markedSettings.localization
            );
          } else if (fieldInputType === "datetimeinput" || fieldInputType === "dateinput" || fieldInputType === "timeinput") {
            return createDatetimeField(
              fieldName,
              fieldInputType.replace("input", ""),
              fieldRequired,
              parsedAttrs,
              fieldParams,
              markedSettings["form-delimiter"],
              markedSettings.id,
              markedSettings.localization
            );
          } else if (fieldInputType === "fileinput") {
            return createFileField(
              fieldName,
              fieldRequired,
              parsedAttrs,
              fieldParams,
              markedSettings["form-delimiter"],
              markedSettings.id,
              markedSettings.localization
            );
          }
        } catch (error) {
          console.warn(error);
        }
      }
      return `${startTag}${text}</p>
`;
    };
    renderer.table = function(header, body) {
      if (body) {
        body = `<tbody>${body}</tbody>`;
      }
      return [
        `<table class="fmd-table">`,
        `	<thead>${header}</thead>`,
        `	${body}`,
        `</table>
`
      ].join("\n");
    };
    exports.renderer = renderer;
  }
});

// node_modules/formsmd/src/spreadsheet-data-parse.js
var require_spreadsheet_data_parse = __commonJS({
  "node_modules/formsmd/src/spreadsheet-data-parse.js"(exports) {
    "use strict";
    var { isNumeric } = require_helpers();
    function splitRow(row, delimiter) {
      const result = [];
      let currentChunk = "";
      let insideQuotes = false;
      for (let i = 0; i < row.length; i++) {
        const char = row[i];
        if (char === '"') {
          insideQuotes = !insideQuotes;
        } else if (char === delimiter && !insideQuotes) {
          result.push(currentChunk.trim());
          currentChunk = "";
        } else {
          currentChunk += char;
        }
      }
      result.push(currentChunk.trim());
      return result;
    }
    function getSpreadsheetColRef(num) {
      const quotient = Math.floor(num / 26);
      const remainder = num % 26;
      const letter = String.fromCharCode(65 + remainder);
      if (quotient > 0) {
        return getSpreadsheetColRef(quotient - 1) + letter;
      } else {
        return letter;
      }
    }
    function parseSpreadsheetData(data, delimiter) {
      const dataSpreadsheet = {};
      const dataNormalized = [];
      const rows = data.split("\n");
      const columnNames = splitRow(rows[0], delimiter);
      for (let i = 0; i < rows.length; i++) {
        const rowNormalized = {};
        const cells = splitRow(rows[i], delimiter);
        for (let j = 0; j < cells.length; j++) {
          let cell = cells[j].trim();
          if (isNumeric(cell)) {
            cell = Number(cell);
          } else if (cell.toLowerCase() === "true") {
            cell = true;
          } else if (cell.toLowerCase() === "false") {
            cell = false;
          }
          let spreadsheetCellRef = getSpreadsheetColRef(j) + String(i + 1);
          dataSpreadsheet[spreadsheetCellRef] = cell;
          rowNormalized[columnNames[j]] = cell;
        }
        if (i > 0) {
          dataNormalized.push(rowNormalized);
        }
      }
      return {
        dataSpreadsheet,
        dataNormalized
      };
    }
    exports.parseSpreadsheetData = parseSpreadsheetData;
  }
});

// node_modules/formsmd/src/div-span-parse.js
var require_div_span_parse = __commonJS({
  "node_modules/formsmd/src/div-span-parse.js"(exports) {
    "use strict";
    var { parseElemAttrs, addReservedClass } = require_attrs_parse();
    function parseDivs(template, cssPrefix) {
      const bindDivTemplates = {};
      let bindDivCount = 0;
      template = template.replace(/:::\s*(.*?)\s*:::/gs, function(match, content) {
        content = content.trim();
        let startTag = "<div>";
        const containsAttrs = content.match(/^\[(.*?)\](.*)/s);
        if (containsAttrs) {
          let [, attrs, rest] = containsAttrs;
          attrs = attrs.replace(/\s\s+/g, " ");
          let bindAttrs = [];
          let bindAttrsStr = "";
          let bindTemplateRefId = "";
          const startBindIndex = attrs.indexOf("{$");
          const endBindIndex = attrs.indexOf("$}");
          if (startBindIndex !== -1 && endBindIndex !== -1 && startBindIndex < endBindIndex) {
            const extracted = attrs.substring(startBindIndex + 2, endBindIndex).split(" ");
            for (let attr of extracted) {
              attr = attr.trim();
              if (attr) {
                bindAttrs.push(`data-fmd-bind-${attr}`);
              }
            }
            attrs = attrs.substring(0, startBindIndex) + attrs.substring(endBindIndex + 2);
          }
          content = `

${rest.trim()}

`;
          if (bindAttrs.length > 0) {
            bindAttrsStr = ` ${bindAttrs.join(" ")} data-fmd-bind-template-ref="${bindDivCount.toString()}"`;
            bindDivTemplates[bindDivCount.toString()] = content;
            bindDivCount += 1;
          }
          attrs = attrs.replace(/\{\$.*?\$\}/g, "");
          startTag = `<div ${parseElemAttrs(attrs, cssPrefix)}${bindAttrsStr}>`;
        } else {
          content = `

${content}

`;
        }
        startTag = addReservedClass(startTag, "fmd-grid");
        return `
${startTag}${content}</div>
`;
      });
      return {
        template,
        bindDivTemplates
      };
    }
    function parseBindSpans(template) {
      return template.replace(
        /\{\$\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\$\}/g,
        "<span data-fmd-bind-$1>{{ $1 }}</span>"
      );
    }
    exports.parseDivs = parseDivs;
    exports.parseBindSpans = parseBindSpans;
  }
});

// node_modules/formsmd/src/slides-parse.js
var require_slides_parse = __commonJS({
  "node_modules/formsmd/src/slides-parse.js"(exports) {
    "use strict";
    var { formFieldPattern } = require_form_field_create();
    var { unescape } = require_helpers();
    var { getTranslation } = require_translations();
    var nunjucks = require_nunjucks();
    var slideTemplate = `
{% if isForm and isFormSlide %}
<form
	method="POST"
	action="javascript:void(0);"
	class="fmd-slide{% if isFirstSlide %} fmd-first-slide{% endif %}"
	{% if jump and not isFirstSlide %}data-fmd-jump="{{ jump }}"{% endif %}
	{% if pageProgress %}data-fmd-page-progress="{{ pageProgress }}"{% endif %}
	{% if disablePrevBtn %}data-fmd-disable-prev-btn{% endif %}
	{% if post %}data-fmd-post{% endif %}
>
	<div class="fmd-grid">
		{{ content }}
		{% if startBtn %}
		<div class="fmd-next-controls fmd-d-flex{% if buttonAlignment %} fmd-justify-content-{{ buttonAlignment }}{% endif %}">
			<button type="submit" class="fmd-submit-btn fmd-btn fmd-btn-accent fmd-d-flex fmd-align-items-center fmd-justify-content-center">
				{{ startBtn }}
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" class="fmd-icon fmd-ms-2 fmd-hide-rtl" aria-hidden="true" focusable="false"><path d="M273 239c9.4 9.4 9.4 24.6 0 33.9L113 433c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l143-143L79 113c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0L273 239z"/></svg>
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" class="fmd-icon fmd-ms-2 fmd-hide-ltr" aria-hidden="true" focusable="false"><path d="M47 239c-9.4 9.4-9.4 24.6 0 33.9L207 433c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9L97.9 256 241 113c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0L47 239z"/></svg>
			</button>
		</div>
		{% else %}
		<div class="fmd-next-controls fmd-d-flex{% if buttonAlignment %} fmd-justify-content-{{ buttonAlignment }}{% endif %}">
			<button type="submit" class="fmd-submit-btn fmd-btn fmd-btn-accent fmd-d-flex fmd-align-items-center fmd-justify-content-center">
				{% if btnSettings.submitBtnText != "" %}
				{{ btnSettings.submitBtnText }}
				{% else %}
				{{ translations.formSubmitBtn }}
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="fmd-icon fmd-ms-2" aria-hidden="true" focusable="false"><path d="M441 103c9.4 9.4 9.4 24.6 0 33.9L177 401c-9.4 9.4-24.6 9.4-33.9 0L7 265c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l119 119L407 103c9.4-9.4 24.6-9.4 33.9 0z"/></svg>
				{% endif %}
			</button>
		</div>
		{% endif %}
	</div>
</form>
{% else %}
<div
	class="fmd-slide{% if isFirstSlide %} fmd-first-slide{% endif %}"
	{% if jump and not isFirstSlide %}data-fmd-jump="{{ jump }}"{% endif %}
	{% if pageProgress %}data-fmd-page-progress="{{ pageProgress }}"{% endif %}
	{% if disablePrevBtn %}data-fmd-disable-prev-btn{% endif %}
>
	<div class="fmd-grid">
		{{ content }}
		{% if startBtn %}
		<div class="fmd-next-controls fmd-d-flex{% if buttonAlignment %} fmd-justify-content-{{ buttonAlignment }}{% endif %}">
			<button type="button" class="fmd-next-btn fmd-btn fmd-btn-accent fmd-d-flex fmd-align-items-center fmd-justify-content-center">
				{{ startBtn }}
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" class="fmd-icon fmd-ms-2 fmd-hide-rtl" aria-hidden="true" focusable="false"><path d="M273 239c9.4 9.4 9.4 24.6 0 33.9L113 433c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l143-143L79 113c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0L273 239z"/></svg>
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" class="fmd-icon fmd-ms-2 fmd-hide-ltr" aria-hidden="true" focusable="false"><path d="M47 239c-9.4 9.4-9.4 24.6 0 33.9L207 433c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9L97.9 256 241 113c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0L47 239z"/></svg>
			</button>
		</div>
		{% else %}
		<div class="fmd-next-controls fmd-d-flex{% if buttonAlignment %} fmd-justify-content-{{ buttonAlignment }}{% endif %}">
			<button type="button" class="fmd-next-btn fmd-btn fmd-btn-accent fmd-d-flex fmd-align-items-center fmd-justify-content-center">
				{{ translations.nextBtn }}
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" class="fmd-icon fmd-ms-2 fmd-hide-rtl" aria-hidden="true" focusable="false"><path d="M273 239c9.4 9.4 9.4 24.6 0 33.9L113 433c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l143-143L79 113c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0L273 239z"/></svg>
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" class="fmd-icon fmd-ms-2 fmd-hide-ltr" aria-hidden="true" focusable="false"><path d="M47 239c-9.4 9.4-9.4 24.6 0 33.9L207 433c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9L97.9 256 241 113c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0L47 239z"/></svg>
			</button>
		</div>
		{% endif %}
	</div>
</div>
{% endif %}
`;
    var endSlideTemplate = `
<div
	class="fmd-slide fmd-end-slide"
	{% if redirect %}data-fmd-redirect="{{ redirect }}"{% endif %}
>
	<div class="fmd-grid">
		{{ content }}
		{% if btnSettings.showRestartBtn %}
		<div class="fmd-next-controls fmd-d-flex fmd-justify-content-center">
			<button type="button" class="fmd-restart-btn fmd-btn fmd-btn-accent fmd-d-flex fmd-align-items-center fmd-justify-content-center">
				{{ translations.restartBtn }}
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="fmd-icon fmd-ms-2" aria-hidden="true" focusable="false"><path d="M472 224c13.3 0 24-10.7 24-24V56c0-13.3-10.7-24-24-24s-24 10.7-24 24v80.1l-20-23.5C387 63.4 325.1 32 256 32C132.3 32 32 132.3 32 256s100.3 224 224 224c50.4 0 97-16.7 134.4-44.8c10.6-8 12.7-23 4.8-33.6s-23-12.7-33.6-4.8C332.2 418.9 295.7 432 256 432c-97.2 0-176-78.8-176-176s78.8-176 176-176c54.3 0 102.9 24.6 135.2 63.4l.1 .2 0 0L418.9 176H328c-13.3 0-24 10.7-24 24s10.7 24 24 24H472z"/></svg>
			</button>
		</div>
		{% endif %}
	</div>
</div>
`;
    function parseSlide(template, isForm, isFirstSlide, btnSettings, localization) {
      const content = [];
      let isFormSlide = false;
      let jump = "";
      let pageProgress = "";
      let disablePrevBtn = false;
      let post = false;
      let buttonAlignment = "";
      let startBtn = "";
      let redirect = "";
      let slideType = "body";
      if (isForm) {
        if (template.match(formFieldPattern)) {
          isFormSlide = true;
        }
      }
      const lines = template.split("\n");
      for (let rawLine of lines) {
        let line = unescape(rawLine);
        if (line.trim().startsWith("->")) {
          line = line.trim();
          line = line.slice(2).trim();
          if (line.toLowerCase() === "start") {
            startBtn = getTranslation(localization, "start-btn");
            slideType = "start";
          } else if (line.match(/^start\s*->(.*)\s*$/i)) {
            startBtn = line.slice(5).trim().slice(2).trim();
            slideType = "start";
          } else if (line.toLowerCase() === "end") {
            slideType = "end";
          } else if (line.match(/^end\s*->(.*)\s*$/i)) {
            redirect = line.slice(3).trim().slice(2).trim();
            slideType = "end";
          } else if (line) {
            jump = line.replace(/"/g, "'");
          }
        } else if (line.trim().startsWith("|>")) {
          line = line.trim();
          line = line.slice(2).trim();
          if (line.match(/^[0-9.]+%$/)) {
            pageProgress = line;
          } else if (line.match(/^[0-9]+\s*\/\s*[0-9]+$/)) {
            pageProgress = `calc(100% * (${line}))`;
          } else {
            console.warn(
              `[SLIDES] "${line}" is not a valid percentage or fraction, acceptable examples: 25%, 33.33%, 75%, 1/4, 1/3, 3/4, etc.`
            );
          }
        } else if (line.trim().startsWith("=|") || line.trim().startsWith("|=")) {
          line = line.trim();
          line = line.slice(2).trim().toLowerCase();
          if (line === "start" || line === "center" || line === "end" || line === "stretch") {
            buttonAlignment = line;
          }
        } else if (line.match(/^\s*<<\s*disable\s*$/i)) {
          disablePrevBtn = true;
        } else if (line.match(/^\s*>>\s*post\s*$/i)) {
          if (isForm && isFormSlide) {
            post = true;
          } else {
            console.warn(
              '[SLIDES] ">> POST" will only work for forms AND on slides with at least one form field.'
            );
          }
        } else {
          content.push(rawLine);
        }
      }
      let parsedTemplate = "";
      nunjucks.configure({ autoescape: false });
      if (slideType === "start") {
        parsedTemplate = nunjucks.renderString(slideTemplate, {
          isForm,
          isFirstSlide,
          content: `
<markdown>

${content.join("\n").trim()}

</markdown>
`,
          isFormSlide,
          jump: "",
          pageProgress,
          buttonAlignment,
          btnSettings,
          disablePrevBtn,
          post,
          startBtn,
          translations: {
            formSubmitBtn: getTranslation(localization, "form-submit-btn"),
            nextBtn: getTranslation(localization, "next-btn")
          }
        });
      } else if (slideType === "body") {
        parsedTemplate = nunjucks.renderString(slideTemplate, {
          isForm,
          isFirstSlide,
          content: `
<markdown>

${content.join("\n").trim()}

</markdown>
`,
          isFormSlide,
          jump,
          pageProgress,
          buttonAlignment,
          btnSettings,
          disablePrevBtn,
          post,
          startBtn: "",
          translations: {
            formSubmitBtn: getTranslation(localization, "form-submit-btn"),
            nextBtn: getTranslation(localization, "next-btn")
          }
        });
      } else if (slideType === "end") {
        parsedTemplate = nunjucks.renderString(endSlideTemplate, {
          content: `
<markdown>

${content.join("\n").trim()}

</markdown>
`,
          redirect,
          btnSettings,
          translations: {
            restartBtn: getTranslation(localization, "restart-btn")
          }
        });
      }
      return {
        template: parsedTemplate,
        slideType
      };
    }
    function parseSlides(template, isForm, btnSettings, localization, slideDelimiter) {
      const startSlides = [];
      const bodySlides = [];
      let containsEndSlide = false;
      let endSlide = "";
      const templateSplit = template.split(slideDelimiter);
      for (let i = 0; i < templateSplit.length; i++) {
        const slide = templateSplit[i];
        const isFirstSlide = i === 0 ? true : false;
        const parsedSlide = parseSlide(
          slide,
          isForm,
          isFirstSlide,
          btnSettings,
          localization
        );
        if (parsedSlide.slideType === "start") {
          startSlides.push(parsedSlide.template);
        } else if (parsedSlide.slideType === "body") {
          bodySlides.push(parsedSlide.template);
        } else if (parsedSlide.slideType === "end") {
          containsEndSlide = true;
          endSlide = parsedSlide.template;
        }
      }
      const slides = startSlides.concat(bodySlides);
      if (!containsEndSlide) {
        nunjucks.configure({ autoescape: false });
        endSlide = nunjucks.renderString(endSlideTemplate, {
          content: isForm ? [
            `<div class="fmd-text-center">`,
            `	<h1 class="fmd-h2 fmd-mb-2">${getTranslation(localization, "form-submitted-title")}</h1>`,
            `	<p class="fmd-fs-lead fmd-mb-1">${getTranslation(localization, "form-submitted-subtitle")}</p>`,
            `</div>
`
          ].join("\n") : [
            `<div class="fmd-text-center">`,
            `	<h1 class="fmd-h2 fmd-mb-2">${getTranslation(localization, "end-slide-title")}</h1>`,
            `	<p class="fmd-fs-lead fmd-mb-1">${getTranslation(localization, "end-slide-subtitle")}</p>`,
            `</div>
`
          ].join("\n"),
          redirect: "",
          btnSettings,
          translations: {
            restartBtn: getTranslation(localization, "restart-btn")
          }
        });
      }
      slides.push(endSlide);
      return slides.join("\n");
    }
    exports.parseSlide = parseSlide;
    exports.parseSlides = parseSlides;
  }
});

// node_modules/dompurify/dist/purify.cjs.js
var require_purify_cjs = __commonJS({
  "node_modules/dompurify/dist/purify.cjs.js"(exports, module) {
    "use strict";
    var {
      entries,
      setPrototypeOf,
      isFrozen,
      getPrototypeOf,
      getOwnPropertyDescriptor
    } = Object;
    var {
      freeze,
      seal,
      create
    } = Object;
    var {
      apply,
      construct
    } = typeof Reflect !== "undefined" && Reflect;
    if (!freeze) {
      freeze = function freeze2(x) {
        return x;
      };
    }
    if (!seal) {
      seal = function seal2(x) {
        return x;
      };
    }
    if (!apply) {
      apply = function apply2(func, thisArg) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return func.apply(thisArg, args);
      };
    }
    if (!construct) {
      construct = function construct2(Func) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        return new Func(...args);
      };
    }
    var arrayForEach = unapply(Array.prototype.forEach);
    var arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
    var arrayPop = unapply(Array.prototype.pop);
    var arrayPush = unapply(Array.prototype.push);
    var arraySplice = unapply(Array.prototype.splice);
    var stringToLowerCase = unapply(String.prototype.toLowerCase);
    var stringToString = unapply(String.prototype.toString);
    var stringMatch = unapply(String.prototype.match);
    var stringReplace = unapply(String.prototype.replace);
    var stringIndexOf = unapply(String.prototype.indexOf);
    var stringTrim = unapply(String.prototype.trim);
    var objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
    var regExpTest = unapply(RegExp.prototype.test);
    var typeErrorCreate = unconstruct(TypeError);
    function unapply(func) {
      return function(thisArg) {
        if (thisArg instanceof RegExp) {
          thisArg.lastIndex = 0;
        }
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        return apply(func, thisArg, args);
      };
    }
    function unconstruct(Func) {
      return function() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return construct(Func, args);
      };
    }
    function addToSet(set, array) {
      let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
      if (setPrototypeOf) {
        setPrototypeOf(set, null);
      }
      let l = array.length;
      while (l--) {
        let element = array[l];
        if (typeof element === "string") {
          const lcElement = transformCaseFunc(element);
          if (lcElement !== element) {
            if (!isFrozen(array)) {
              array[l] = lcElement;
            }
            element = lcElement;
          }
        }
        set[element] = true;
      }
      return set;
    }
    function cleanArray(array) {
      for (let index = 0; index < array.length; index++) {
        const isPropertyExist = objectHasOwnProperty(array, index);
        if (!isPropertyExist) {
          array[index] = null;
        }
      }
      return array;
    }
    function clone(object) {
      const newObject = create(null);
      for (const [property, value] of entries(object)) {
        const isPropertyExist = objectHasOwnProperty(object, property);
        if (isPropertyExist) {
          if (Array.isArray(value)) {
            newObject[property] = cleanArray(value);
          } else if (value && typeof value === "object" && value.constructor === Object) {
            newObject[property] = clone(value);
          } else {
            newObject[property] = value;
          }
        }
      }
      return newObject;
    }
    function lookupGetter(object, prop) {
      while (object !== null) {
        const desc = getOwnPropertyDescriptor(object, prop);
        if (desc) {
          if (desc.get) {
            return unapply(desc.get);
          }
          if (typeof desc.value === "function") {
            return unapply(desc.value);
          }
        }
        object = getPrototypeOf(object);
      }
      function fallbackValue() {
        return null;
      }
      return fallbackValue;
    }
    var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
    var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
    var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
    var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
    var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
    var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
    var text = freeze(["#text"]);
    var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
    var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
    var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
    var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
    var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
    var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
    var TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
    var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
    var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
    var IS_ALLOWED_URI = seal(
      /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
      // eslint-disable-line no-useless-escape
    );
    var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    var ATTR_WHITESPACE = seal(
      /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
      // eslint-disable-line no-control-regex
    );
    var DOCTYPE_NAME = seal(/^html$/i);
    var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
    var EXPRESSIONS = Object.freeze({
      __proto__: null,
      ARIA_ATTR,
      ATTR_WHITESPACE,
      CUSTOM_ELEMENT,
      DATA_ATTR,
      DOCTYPE_NAME,
      ERB_EXPR,
      IS_ALLOWED_URI,
      IS_SCRIPT_OR_DATA,
      MUSTACHE_EXPR,
      TMPLIT_EXPR
    });
    var NODE_TYPE = {
      element: 1,
      attribute: 2,
      text: 3,
      cdataSection: 4,
      entityReference: 5,
      // Deprecated
      entityNode: 6,
      // Deprecated
      progressingInstruction: 7,
      comment: 8,
      document: 9,
      documentType: 10,
      documentFragment: 11,
      notation: 12
      // Deprecated
    };
    var getGlobal = function getGlobal2() {
      return typeof window === "undefined" ? null : window;
    };
    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
      if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
        return null;
      }
      let suffix = null;
      const ATTR_NAME = "data-tt-policy-suffix";
      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
        suffix = purifyHostElement.getAttribute(ATTR_NAME);
      }
      const policyName = "dompurify" + (suffix ? "#" + suffix : "");
      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML(html2) {
            return html2;
          },
          createScriptURL(scriptUrl) {
            return scriptUrl;
          }
        });
      } catch (_) {
        console.warn("TrustedTypes policy " + policyName + " could not be created.");
        return null;
      }
    };
    var _createHooksMap = function _createHooksMap2() {
      return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
      };
    };
    function createDOMPurify() {
      let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
      const DOMPurify = (root) => createDOMPurify(root);
      DOMPurify.version = "3.3.1";
      DOMPurify.removed = [];
      if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
        DOMPurify.isSupported = false;
        return DOMPurify;
      }
      let {
        document: document2
      } = window2;
      const originalDocument = document2;
      const currentScript = originalDocument.currentScript;
      const {
        DocumentFragment,
        HTMLTemplateElement,
        Node,
        Element,
        NodeFilter,
        NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
        HTMLFormElement,
        DOMParser,
        trustedTypes
      } = window2;
      const ElementPrototype = Element.prototype;
      const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
      const remove = lookupGetter(ElementPrototype, "remove");
      const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
      const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
      const getParentNode = lookupGetter(ElementPrototype, "parentNode");
      if (typeof HTMLTemplateElement === "function") {
        const template = document2.createElement("template");
        if (template.content && template.content.ownerDocument) {
          document2 = template.content.ownerDocument;
        }
      }
      let trustedTypesPolicy;
      let emptyHTML = "";
      const {
        implementation,
        createNodeIterator,
        createDocumentFragment,
        getElementsByTagName
      } = document2;
      const {
        importNode
      } = originalDocument;
      let hooks = _createHooksMap();
      DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
      const {
        MUSTACHE_EXPR: MUSTACHE_EXPR2,
        ERB_EXPR: ERB_EXPR2,
        TMPLIT_EXPR: TMPLIT_EXPR2,
        DATA_ATTR: DATA_ATTR2,
        ARIA_ATTR: ARIA_ATTR2,
        IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
        ATTR_WHITESPACE: ATTR_WHITESPACE2,
        CUSTOM_ELEMENT: CUSTOM_ELEMENT2
      } = EXPRESSIONS;
      let {
        IS_ALLOWED_URI: IS_ALLOWED_URI$1
      } = EXPRESSIONS;
      let ALLOWED_TAGS = null;
      const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
      let ALLOWED_ATTR = null;
      const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
      let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
        tagNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: false
        }
      }));
      let FORBID_TAGS = null;
      let FORBID_ATTR = null;
      const EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {
        tagCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        }
      }));
      let ALLOW_ARIA_ATTR = true;
      let ALLOW_DATA_ATTR = true;
      let ALLOW_UNKNOWN_PROTOCOLS = false;
      let ALLOW_SELF_CLOSE_IN_ATTR = true;
      let SAFE_FOR_TEMPLATES = false;
      let SAFE_FOR_XML = true;
      let WHOLE_DOCUMENT = false;
      let SET_CONFIG = false;
      let FORCE_BODY = false;
      let RETURN_DOM = false;
      let RETURN_DOM_FRAGMENT = false;
      let RETURN_TRUSTED_TYPE = false;
      let SANITIZE_DOM = true;
      let SANITIZE_NAMED_PROPS = false;
      const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
      let KEEP_CONTENT = true;
      let IN_PLACE = false;
      let USE_PROFILES = {};
      let FORBID_CONTENTS = null;
      const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
      let DATA_URI_TAGS = null;
      const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
      let URI_SAFE_ATTRIBUTES = null;
      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
      const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
      const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
      const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
      let NAMESPACE = HTML_NAMESPACE;
      let IS_EMPTY_INPUT = false;
      let ALLOWED_NAMESPACES = null;
      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
      let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
      let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
      let PARSER_MEDIA_TYPE = null;
      const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
      const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
      let transformCaseFunc = null;
      let CONFIG = null;
      const formElement = document2.createElement("form");
      const isRegexOrFunction = function isRegexOrFunction2(testValue) {
        return testValue instanceof RegExp || testValue instanceof Function;
      };
      const _parseConfig = function _parseConfig2() {
        let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        if (!cfg || typeof cfg !== "object") {
          cfg = {};
        }
        cfg = clone(cfg);
        PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
        transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
        ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
        FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
        FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
        FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
        USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
        RETURN_DOM = cfg.RETURN_DOM || false;
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
        FORCE_BODY = cfg.FORCE_BODY || false;
        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
        IN_PLACE = cfg.IN_PLACE || false;
        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
        }
        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }
        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, text);
          ALLOWED_ATTR = [];
          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html$1);
            addToSet(ALLOWED_ATTR, html);
          }
          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg$1);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl$1);
            addToSet(ALLOWED_ATTR, mathMl);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        if (cfg.ADD_TAGS) {
          if (typeof cfg.ADD_TAGS === "function") {
            EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;
          } else {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
              ALLOWED_TAGS = clone(ALLOWED_TAGS);
            }
            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
          }
        }
        if (cfg.ADD_ATTR) {
          if (typeof cfg.ADD_ATTR === "function") {
            EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;
          } else {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
              ALLOWED_ATTR = clone(ALLOWED_ATTR);
            }
            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
          }
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
        }
        if (cfg.FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
        }
        if (cfg.ADD_FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc);
        }
        if (KEEP_CONTENT) {
          ALLOWED_TAGS["#text"] = true;
        }
        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
        }
        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ["tbody"]);
          delete FORBID_TAGS.tbody;
        }
        if (cfg.TRUSTED_TYPES_POLICY) {
          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          }
          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          }
          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
          emptyHTML = trustedTypesPolicy.createHTML("");
        } else {
          if (trustedTypesPolicy === void 0) {
            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
          }
          if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
            emptyHTML = trustedTypesPolicy.createHTML("");
          }
        }
        if (freeze) {
          freeze(cfg);
        }
        CONFIG = cfg;
      };
      const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
      const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
      const _checkValidNamespace = function _checkValidNamespace2(element) {
        let parent = getParentNode(element);
        if (!parent || !parent.tagName) {
          parent = {
            namespaceURI: NAMESPACE,
            tagName: "template"
          };
        }
        const tagName = stringToLowerCase(element.tagName);
        const parentTagName = stringToLowerCase(parent.tagName);
        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
          return false;
        }
        if (element.namespaceURI === SVG_NAMESPACE) {
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === "svg";
          }
          if (parent.namespaceURI === MATHML_NAMESPACE) {
            return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
          }
          return Boolean(ALL_SVG_TAGS[tagName]);
        }
        if (element.namespaceURI === MATHML_NAMESPACE) {
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === "math";
          }
          if (parent.namespaceURI === SVG_NAMESPACE) {
            return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
          }
          return Boolean(ALL_MATHML_TAGS[tagName]);
        }
        if (element.namespaceURI === HTML_NAMESPACE) {
          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
        }
        if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
          return true;
        }
        return false;
      };
      const _forceRemove = function _forceRemove2(node) {
        arrayPush(DOMPurify.removed, {
          element: node
        });
        try {
          getParentNode(node).removeChild(node);
        } catch (_) {
          remove(node);
        }
      };
      const _removeAttribute = function _removeAttribute2(name, element) {
        try {
          arrayPush(DOMPurify.removed, {
            attribute: element.getAttributeNode(name),
            from: element
          });
        } catch (_) {
          arrayPush(DOMPurify.removed, {
            attribute: null,
            from: element
          });
        }
        element.removeAttribute(name);
        if (name === "is") {
          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
            try {
              _forceRemove(element);
            } catch (_) {
            }
          } else {
            try {
              element.setAttribute(name, "");
            } catch (_) {
            }
          }
        }
      };
      const _initDocument = function _initDocument2(dirty) {
        let doc = null;
        let leadingWhitespace = null;
        if (FORCE_BODY) {
          dirty = "<remove></remove>" + dirty;
        } else {
          const matches = stringMatch(dirty, /^[\r\n\t ]+/);
          leadingWhitespace = matches && matches[0];
        }
        if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
          dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
        }
        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        if (NAMESPACE === HTML_NAMESPACE) {
          try {
            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
          } catch (_) {
          }
        }
        if (!doc || !doc.documentElement) {
          doc = implementation.createDocument(NAMESPACE, "template", null);
          try {
            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
          } catch (_) {
          }
        }
        const body = doc.body || doc.documentElement;
        if (dirty && leadingWhitespace) {
          body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        if (NAMESPACE === HTML_NAMESPACE) {
          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
        }
        return WHOLE_DOCUMENT ? doc.documentElement : body;
      };
      const _createNodeIterator = function _createNodeIterator2(root) {
        return createNodeIterator.call(
          root.ownerDocument || root,
          root,
          // eslint-disable-next-line no-bitwise
          NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
          null
        );
      };
      const _isClobbered = function _isClobbered2(element) {
        return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
      };
      const _isNode = function _isNode2(value) {
        return typeof Node === "function" && value instanceof Node;
      };
      function _executeHooks(hooks2, currentNode, data) {
        arrayForEach(hooks2, (hook) => {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      }
      const _sanitizeElements = function _sanitizeElements2(currentNode) {
        let content = null;
        _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        const tagName = transformCaseFunc(currentNode.nodeName);
        _executeHooks(hooks.uponSanitizeElement, currentNode, {
          tagName,
          allowedTags: ALLOWED_TAGS
        });
        if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
          _forceRemove(currentNode);
          return true;
        }
        if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
          _forceRemove(currentNode);
          return true;
        }
        if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
          _forceRemove(currentNode);
          return true;
        }
        if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {
          if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
              return false;
            }
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
              return false;
            }
          }
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
            const parentNode = getParentNode(currentNode) || currentNode.parentNode;
            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
            if (childNodes && parentNode) {
              const childCount = childNodes.length;
              for (let i = childCount - 1; i >= 0; --i) {
                const childClone = cloneNode(childNodes[i], true);
                childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                parentNode.insertBefore(childClone, getNextSibling(currentNode));
              }
            }
          }
          _forceRemove(currentNode);
          return true;
        }
        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
          content = currentNode.textContent;
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            content = stringReplace(content, expr, " ");
          });
          if (currentNode.textContent !== content) {
            arrayPush(DOMPurify.removed, {
              element: currentNode.cloneNode()
            });
            currentNode.textContent = content;
          }
        }
        _executeHooks(hooks.afterSanitizeElements, currentNode, null);
        return false;
      };
      const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
        if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
          return false;
        }
        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
        else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ;
        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
          ) ;
          else {
            return false;
          }
        } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
        else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
        else if (value) {
          return false;
        } else ;
        return true;
      };
      const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
        return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
      };
      const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
        _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
        const {
          attributes
        } = currentNode;
        if (!attributes || _isClobbered(currentNode)) {
          return;
        }
        const hookEvent = {
          attrName: "",
          attrValue: "",
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR,
          forceKeepAttr: void 0
        };
        let l = attributes.length;
        while (l--) {
          const attr = attributes[l];
          const {
            name,
            namespaceURI,
            value: attrValue
          } = attr;
          const lcName = transformCaseFunc(name);
          const initValue = attrValue;
          let value = name === "value" ? initValue : stringTrim(initValue);
          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;
          hookEvent.forceKeepAttr = void 0;
          _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
          value = hookEvent.attrValue;
          if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
            _removeAttribute(name, currentNode);
            value = SANITIZE_NAMED_PROPS_PREFIX + value;
          }
          if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (lcName === "attributename" && stringMatch(value, "href")) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (hookEvent.forceKeepAttr) {
            continue;
          }
          if (!hookEvent.keepAttr) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (SAFE_FOR_TEMPLATES) {
            arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
              value = stringReplace(value, expr, " ");
            });
          }
          const lcTag = transformCaseFunc(currentNode.nodeName);
          if (!_isValidAttribute(lcTag, lcName, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
            if (namespaceURI) ;
            else {
              switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                case "TrustedHTML": {
                  value = trustedTypesPolicy.createHTML(value);
                  break;
                }
                case "TrustedScriptURL": {
                  value = trustedTypesPolicy.createScriptURL(value);
                  break;
                }
              }
            }
          }
          if (value !== initValue) {
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                currentNode.setAttribute(name, value);
              }
              if (_isClobbered(currentNode)) {
                _forceRemove(currentNode);
              } else {
                arrayPop(DOMPurify.removed);
              }
            } catch (_) {
              _removeAttribute(name, currentNode);
            }
          }
        }
        _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
      };
      const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
        let shadowNode = null;
        const shadowIterator = _createNodeIterator(fragment);
        _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
        while (shadowNode = shadowIterator.nextNode()) {
          _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
          _sanitizeElements(shadowNode);
          _sanitizeAttributes(shadowNode);
          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM2(shadowNode.content);
          }
        }
        _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
      };
      DOMPurify.sanitize = function(dirty) {
        let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let body = null;
        let importedNode = null;
        let currentNode = null;
        let returnNode = null;
        IS_EMPTY_INPUT = !dirty;
        if (IS_EMPTY_INPUT) {
          dirty = "<!-->";
        }
        if (typeof dirty !== "string" && !_isNode(dirty)) {
          if (typeof dirty.toString === "function") {
            dirty = dirty.toString();
            if (typeof dirty !== "string") {
              throw typeErrorCreate("dirty is not a string, aborting");
            }
          } else {
            throw typeErrorCreate("toString is not a function");
          }
        }
        if (!DOMPurify.isSupported) {
          return dirty;
        }
        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        DOMPurify.removed = [];
        if (typeof dirty === "string") {
          IN_PLACE = false;
        }
        if (IN_PLACE) {
          if (dirty.nodeName) {
            const tagName = transformCaseFunc(dirty.nodeName);
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
            }
          }
        } else if (dirty instanceof Node) {
          body = _initDocument("<!---->");
          importedNode = body.ownerDocument.importNode(dirty, true);
          if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
            body = importedNode;
          } else if (importedNode.nodeName === "HTML") {
            body = importedNode;
          } else {
            body.appendChild(importedNode);
          }
        } else {
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
          dirty.indexOf("<") === -1) {
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          body = _initDocument(dirty);
          if (!body) {
            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
          }
        }
        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
        while (currentNode = nodeIterator.nextNode()) {
          _sanitizeElements(currentNode);
          _sanitizeAttributes(currentNode);
          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
        }
        if (IN_PLACE) {
          return dirty;
        }
        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);
            while (body.firstChild) {
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }
          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
            returnNode = importNode.call(originalDocument, returnNode, true);
          }
          return returnNode;
        }
        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
          serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
        }
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            serializedHTML = stringReplace(serializedHTML, expr, " ");
          });
        }
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      DOMPurify.setConfig = function() {
        let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _parseConfig(cfg);
        SET_CONFIG = true;
      };
      DOMPurify.clearConfig = function() {
        CONFIG = null;
        SET_CONFIG = false;
      };
      DOMPurify.isValidAttribute = function(tag, attr, value) {
        if (!CONFIG) {
          _parseConfig({});
        }
        const lcTag = transformCaseFunc(tag);
        const lcName = transformCaseFunc(attr);
        return _isValidAttribute(lcTag, lcName, value);
      };
      DOMPurify.addHook = function(entryPoint, hookFunction) {
        if (typeof hookFunction !== "function") {
          return;
        }
        arrayPush(hooks[entryPoint], hookFunction);
      };
      DOMPurify.removeHook = function(entryPoint, hookFunction) {
        if (hookFunction !== void 0) {
          const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
          return index === -1 ? void 0 : arraySplice(hooks[entryPoint], index, 1)[0];
        }
        return arrayPop(hooks[entryPoint]);
      };
      DOMPurify.removeHooks = function(entryPoint) {
        hooks[entryPoint] = [];
      };
      DOMPurify.removeAllHooks = function() {
        hooks = _createHooksMap();
      };
      return DOMPurify;
    }
    var purify = createDOMPurify();
    module.exports = purify;
  }
});

// node_modules/formsmd/src/templates-create.js
var require_templates_create = __commonJS({
  "node_modules/formsmd/src/templates-create.js"(exports) {
    "use strict";
    var { addReservedClass } = require_attrs_parse();
    var { parseDivs, parseBindSpans } = require_div_span_parse();
    var { renderer } = require_marked_renderer();
    var { parseSlides } = require_slides_parse();
    var { getTranslation } = require_translations();
    var createDOMPurify = require_purify_cjs();
    var { marked } = require_marked();
    var nunjucks = require_nunjucks();
    function createStyles(settings) {
      const styleBlocks = [];
      if (settings["font-import-url"] !== void 0) {
        styleBlocks.push(`@import url("${settings["font-import-url"]}");`);
      }
      const colorScheme = settings["color-scheme"] === "light" ? "lm" : "dm";
      const altColorScheme = settings["color-scheme"] === "light" ? "dm" : "lm";
      const baseStyles = [];
      if (settings["font-family"] !== void 0) {
        baseStyles.push(`--fmd-body-font-family: ${settings["font-family"]};`);
      }
      if (settings["backdrop-opacity"] !== void 0) {
        baseStyles.push(
          `--fmd-backdrop-opacity-${colorScheme}: ${settings["backdrop-opacity"]};`
        );
      }
      if (settings["backdrop-opacity-alt-scheme"] !== void 0) {
        baseStyles.push(
          `--fmd-backdrop-opacity-${altColorScheme}: ${settings["backdrop-opacity-alt-scheme"]};`
        );
      }
      if (settings["background-image"] !== void 0) {
        baseStyles.push(
          `--fmd-body-bg-img-${colorScheme}: ${settings["background-image"]};`
        );
      }
      if (settings["background-image-alt-scheme"] !== void 0) {
        baseStyles.push(
          `--fmd-body-bg-img-${altColorScheme}: ${settings["background-image-alt-scheme"]};`
        );
      }
      const colorStyles = [];
      const colorStylesAltScheme = [];
      const colorVariablesPrefixMap = {
        "accent": "--fmd-accent-",
        "accent-alt-scheme": "--fmd-accent-",
        "accent-foreground": "--fmd-accent-foreground-",
        "accent-foreground-alt-scheme": "--fmd-accent-foreground-",
        "background-color": "--fmd-body-bg-",
        "background-color-alt-scheme": "--fmd-body-bg-",
        "color": "--fmd-body-color-",
        "color-alt-scheme": "--fmd-body-color-"
      };
      for (const [key, value] of Object.entries(settings)) {
        if (colorVariablesPrefixMap[key] !== void 0) {
          const rgbValues = value.split(",").map(function(item) {
            return item.trim();
          });
          const variablePrefix = colorVariablesPrefixMap[key];
          if (!key.endsWith("-alt-scheme")) {
            colorStyles.push(`${variablePrefix}r: ${rgbValues[0]};`);
            colorStyles.push(`${variablePrefix}g: ${rgbValues[1]};`);
            colorStyles.push(`${variablePrefix}b: ${rgbValues[2]};`);
          } else {
            colorStylesAltScheme.push(`${variablePrefix}r: ${rgbValues[0]};`);
            colorStylesAltScheme.push(`${variablePrefix}g: ${rgbValues[1]};`);
            colorStylesAltScheme.push(`${variablePrefix}b: ${rgbValues[2]};`);
          }
        }
      }
      const selector = settings.id !== "" ? `.fmd-root[data-fmd-id="${settings.id}"]` : ".fmd-root";
      if (baseStyles.length > 0) {
        styleBlocks.push(`${selector} {${baseStyles.join("")}}`);
      }
      if (colorStyles.length > 0) {
        if (settings["color-scheme"] === "light") {
          styleBlocks.push(`${selector} {${colorStyles.join("")}}`);
        } else {
          styleBlocks.push(
            `${selector}[data-fmd-color-scheme="dark"] {${colorStyles.join("")}}`
          );
        }
      }
      if (colorStylesAltScheme.length > 0) {
        if (settings["color-scheme"] === "light") {
          styleBlocks.push(
            `${selector}[data-fmd-color-scheme="dark"] {${colorStylesAltScheme.join("")}}`
          );
        } else {
          styleBlocks.push(`${selector} {${colorStylesAltScheme.join("")}
}`);
        }
      }
      return styleBlocks.join("\n");
    }
    var madeInLoaderTemplate = `
<div class="fmd-backdrop"></div>

<div class="fmd-main">
	<div class="fmd-main-container">
		<div class="fmd-loader-container">
			<div class="fmd-text-center fmd-mb-3">
				{% if settings["formsmd-branding"] != "hide" %}
				{{ translations.madeInLoader | safe }}
				{% else %}
				<div class="fmd-specific-fs-20 fmd-text-emphasis fmd-fw-bold">{{ translations.loading }}...</div>
				{% endif %}
			</div>
			<div class="fmd-loader-progress" role="status" aria-label="{{ translations.loading }}"></div>
		</div>
	</div>
</div>
`;
    var bodyTemplate = `
<div class="fmd-backdrop"></div>

{% if settings["page-progress"] != "hide" %}
<div class="fmd-page-progress">
	<div class="fmd-progress">
		<div class="fmd-progress-bar" style="width: 0%"></div>
	</div>
</div>
{% endif %}

{% if settings["header-render"] %}
<div class="fmd-header">
	<div class="fmd-header-container">
		{% if settings.brand != undefined %}
		{{ settings.brand | safe }}
		{% if settings["brand-alt-scheme"] != undefined %}
		{{ settings["brand-alt-scheme"] | safe }}
		{% endif %}
		{% endif %}
		{% if settings.cta != undefined %}
		{{ settings.cta | safe }}
		{% endif %}
	</div>
</div>
{% endif %}

<div class="fmd-main">
	<div class="fmd-main-container">
		<div class="fmd-loader-container">
			<div class="fmd-text-center fmd-mb-3">
				{% if settings["formsmd-branding"] != "hide" %}
				{{ translations.madeInLoader | safe }}
				{% else %}
				<div class="fmd-specific-fs-20 fmd-text-emphasis fmd-fw-bold">{{ translations.loading }}...</div>
				{% endif %}
			</div>
			<div class="fmd-loader-progress" role="status" aria-label="{{ translations.loading }}"></div>
		</div>
	</div>
</div>

{% if settings["footer-render"] %}
<div class="fmd-footer">
	<div class="fmd-footer-inner">
		{% if settings["color-scheme-toggle"] == "show" %}
		<button type="button" class="fmd-toggle-color-scheme-btn fmd-btn fmd-btn-accent fmd-btn-control fmd-btn-control-square fmd-d-flex fmd-align-items-center fmd-justify-content-center" aria-label="{{ translations.toggleColorSchemeBtn }}">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="fmd-icon" aria-hidden="true" focusable="false"><path fillRule="evenodd" d="M9.528 1.718a.75.75 0 0 1 .162.819A8.97 8.97 0 0 0 9 6a9 9 0 0 0 9 9 8.97 8.97 0 0 0 3.463-.69.75.75 0 0 1 .981.98 10.503 10.503 0 0 1-9.694 6.46c-5.799 0-10.5-4.7-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 0 1 .818.162Z" clipRule="evenodd" /></svg>
		</button>
		{% endif %}
		{% if settings["slide-controls"] != "hide" and settings.page != "single" %}
		<div class="fmd-btn-group" role="group">
			<button type="button" class="fmd-previous-btn fmd-btn fmd-btn-accent fmd-btn-control fmd-btn-control-square fmd-d-flex fmd-align-items-center fmd-justify-content-center" aria-label="{{ translations.previousBtn }}" disabled>
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="fmd-icon" aria-hidden="true" focusable="false"><path d="M201.4 137.4c12.5-12.5 32.8-12.5 45.3 0l160 160c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 205.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l160-160z"/></svg>
			</button>
			<div class="fmd-btn-group-vr"><div class="fmd-btn-group-vr-inner"></div></div>
			<button type="button" class="fmd-next-btn fmd-btn fmd-btn-accent fmd-btn-control fmd-btn-control-square fmd-d-flex fmd-align-items-center fmd-justify-content-center" aria-label="{{ translations.nextBtn }}">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="fmd-icon" aria-hidden="true" focusable="false"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"/></svg>
			</button>
		</div>
		{% endif %}
		{% if settings["formsmd-branding"] != "hide" %}
		<a href="https://forms.md" target="_blank" class="fmd-btn fmd-btn-accent fmd-btn-control">
			{{ translations.madeInBtn | safe }}
		</a>
		{% endif %}
	</div>
</div>
{% endif %}
`;
    function createBodyTemplate(settings) {
      marked.use({
        renderer,
        markedSettings: {
          "css-prefix": settings["css-prefix"],
          "form-delimiter": settings["form-delimiter"],
          "id": settings.id,
          "localization": settings.localization
        }
      });
      if (settings.brand !== void 0) {
        let brand = marked.parseInline(settings.brand);
        brand = addReservedClass(brand, "fmd-header-brand");
        if (settings["brand-alt-scheme"] !== void 0) {
          brand = settings["color-scheme"] === "light" ? addReservedClass(brand, "fmd-hide-dm") : addReservedClass(brand, "fmd-hide-lm");
        }
        settings.brand = brand;
        if (settings["brand-alt-scheme"] !== void 0) {
          let brandAltScheme = marked.parseInline(settings["brand-alt-scheme"]);
          brandAltScheme = addReservedClass(brandAltScheme, "fmd-header-brand");
          brandAltScheme = settings["color-scheme"] === "light" ? addReservedClass(brandAltScheme, "fmd-hide-lm") : addReservedClass(brandAltScheme, "fmd-hide-dm");
          settings["brand-alt-scheme"] = brandAltScheme;
        }
      }
      if (settings.cta !== void 0) {
        let cta = marked.parseInline(settings.cta);
        cta = addReservedClass(cta, "fmd-btn");
        cta = addReservedClass(cta, "fmd-btn-accent");
        cta = addReservedClass(cta, "fmd-btn-control");
        cta = addReservedClass(cta, "fmd-ms-auto");
        settings.cta = cta;
      }
      settings["header-render"] = settings.header !== "hide" && (settings.brand !== void 0 || settings.cta !== void 0);
      settings["footer-render"] = settings.footer !== "hide" && (settings["color-scheme-toggle"] === "show" || settings["slide-controls"] !== "hide" && settings.page !== "single" || settings["formsmd-branding"] !== "hide");
      const localization = settings.localization;
      nunjucks.configure({ autoescape: false });
      const template = nunjucks.renderString(bodyTemplate, {
        settings,
        translations: {
          loading: getTranslation(localization, "loading"),
          madeInBtn: getTranslation(localization, "made-in-btn"),
          madeInLoader: getTranslation(localization, "made-in-loader"),
          nextBtn: getTranslation(localization, "next-btn"),
          previousBtn: getTranslation(localization, "previous-btn"),
          toggleColorSchemeBtn: getTranslation(
            localization,
            "toggle-color-scheme-btn"
          )
        }
      });
      return {
        template,
        settings
      };
    }
    function createContentTemplate(template, settings, data, windowAndSanitize) {
      const parsedTemplateWithDivs = parseDivs(template, settings["css-prefix"]);
      template = parsedTemplateWithDivs.template;
      const bindDivTemplates = parsedTemplateWithDivs.bindDivTemplates;
      template = parseBindSpans(template);
      if (settings.page !== "single") {
        template = parseSlides(
          template,
          settings.page === "form-slides" ? true : false,
          {
            showRestartBtn: settings["restart-button"] === "show" ? true : false,
            submitBtnText: settings["submit-button-text"] !== void 0 ? settings["submit-button-text"] : ""
          },
          settings.localization,
          settings["slide-delimiter"]
        );
      } else {
        template = [
          `<div class="fmd-single">`,
          `	<div class="fmd-grid">`,
          `		<markdown>`,
          `		${template}`,
          `		</markdown>`,
          `	</div>`,
          `</div>`
        ].join("\n");
      }
      nunjucks.configure({ autoescape: false });
      template = nunjucks.renderString(template, data);
      marked.use({
        renderer,
        markedSettings: {
          "css-prefix": settings["css-prefix"],
          "form-delimiter": settings["form-delimiter"],
          "id": settings.id,
          "localization": settings.localization
        }
      });
      template = template.replace(
        /<markdown>(.*?)<\/markdown>/gs,
        function(match, content) {
          if (windowAndSanitize) {
            const DOMPurify = createDOMPurify(window);
            return DOMPurify.sanitize(marked.parse(content));
          } else {
            return marked.parse(content);
          }
        }
      );
      return {
        template,
        bindDivTemplates
      };
    }
    exports.createStyles = createStyles;
    exports.madeInLoaderTemplate = madeInLoaderTemplate;
    exports.createBodyTemplate = createBodyTemplate;
    exports.createContentTemplate = createContentTemplate;
  }
});

// node_modules/highlight.js/lib/core.js
var require_core = __commonJS({
  "node_modules/highlight.js/lib/core.js"(exports, module) {
    function deepFreeze(obj) {
      if (obj instanceof Map) {
        obj.clear = obj.delete = obj.set = function() {
          throw new Error("map is read-only");
        };
      } else if (obj instanceof Set) {
        obj.add = obj.clear = obj.delete = function() {
          throw new Error("set is read-only");
        };
      }
      Object.freeze(obj);
      Object.getOwnPropertyNames(obj).forEach((name) => {
        const prop = obj[name];
        const type = typeof prop;
        if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
          deepFreeze(prop);
        }
      });
      return obj;
    }
    var Response = class {
      /**
       * @param {CompiledMode} mode
       */
      constructor(mode) {
        if (mode.data === void 0) mode.data = {};
        this.data = mode.data;
        this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    };
    function escapeHTML(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    }
    function inherit$1(original, ...objects) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key in original) {
        result[key] = original[key];
      }
      objects.forEach(function(obj) {
        for (const key in obj) {
          result[key] = obj[key];
        }
      });
      return (
        /** @type {T} */
        result
      );
    }
    var SPAN_CLOSE = "</span>";
    var emitsWrappingTags = (node) => {
      return !!node.scope;
    };
    var scopeToCSSClass = (name, { prefix }) => {
      if (name.startsWith("language:")) {
        return name.replace("language:", "language-");
      }
      if (name.includes(".")) {
        const pieces = name.split(".");
        return [
          `${prefix}${pieces.shift()}`,
          ...pieces.map((x, i) => `${x}${"_".repeat(i + 1)}`)
        ].join(" ");
      }
      return `${prefix}${name}`;
    };
    var HTMLRenderer = class {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(parseTree, options) {
        this.buffer = "";
        this.classPrefix = options.classPrefix;
        parseTree.walk(this);
      }
      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(text) {
        this.buffer += escapeHTML(text);
      }
      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(node) {
        if (!emitsWrappingTags(node)) return;
        const className = scopeToCSSClass(
          node.scope,
          { prefix: this.classPrefix }
        );
        this.span(className);
      }
      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(node) {
        if (!emitsWrappingTags(node)) return;
        this.buffer += SPAN_CLOSE;
      }
      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }
      // helpers
      /**
       * Builds a span element
       *
       * @param {string} className */
      span(className) {
        this.buffer += `<span class="${className}">`;
      }
    };
    var newNode = (opts = {}) => {
      const result = { children: [] };
      Object.assign(result, opts);
      return result;
    };
    var TokenTree = class _TokenTree {
      constructor() {
        this.rootNode = newNode();
        this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      /** @param {Node} node */
      add(node) {
        this.top.children.push(node);
      }
      /** @param {string} scope */
      openNode(scope) {
        const node = newNode({ scope });
        this.add(node);
        this.stack.push(node);
      }
      closeNode() {
        if (this.stack.length > 1) {
          return this.stack.pop();
        }
        return void 0;
      }
      closeAllNodes() {
        while (this.closeNode()) ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(builder) {
        return this.constructor._walk(builder, this.rootNode);
      }
      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(builder, node) {
        if (typeof node === "string") {
          builder.addText(node);
        } else if (node.children) {
          builder.openNode(node);
          node.children.forEach((child) => this._walk(builder, child));
          builder.closeNode(node);
        }
        return builder;
      }
      /**
       * @param {Node} node
       */
      static _collapse(node) {
        if (typeof node === "string") return;
        if (!node.children) return;
        if (node.children.every((el) => typeof el === "string")) {
          node.children = [node.children.join("")];
        } else {
          node.children.forEach((child) => {
            _TokenTree._collapse(child);
          });
        }
      }
    };
    var TokenTreeEmitter = class extends TokenTree {
      /**
       * @param {*} options
       */
      constructor(options) {
        super();
        this.options = options;
      }
      /**
       * @param {string} text
       */
      addText(text) {
        if (text === "") {
          return;
        }
        this.add(text);
      }
      /** @param {string} scope */
      startScope(scope) {
        this.openNode(scope);
      }
      endScope() {
        this.closeNode();
      }
      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      __addSublanguage(emitter, name) {
        const node = emitter.root;
        if (name) node.scope = `language:${name}`;
        this.add(node);
      }
      toHTML() {
        const renderer = new HTMLRenderer(this, this.options);
        return renderer.value();
      }
      finalize() {
        this.closeAllNodes();
        return true;
      }
    };
    function source(re) {
      if (!re) return null;
      if (typeof re === "string") return re;
      return re.source;
    }
    function lookahead(re) {
      return concat("(?=", re, ")");
    }
    function anyNumberOfTimes(re) {
      return concat("(?:", re, ")*");
    }
    function optional(re) {
      return concat("(?:", re, ")?");
    }
    function concat(...args) {
      const joined = args.map((x) => source(x)).join("");
      return joined;
    }
    function stripOptionsFromArgs(args) {
      const opts = args[args.length - 1];
      if (typeof opts === "object" && opts.constructor === Object) {
        args.splice(args.length - 1, 1);
        return opts;
      } else {
        return {};
      }
    }
    function either(...args) {
      const opts = stripOptionsFromArgs(args);
      const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source(x)).join("|") + ")";
      return joined;
    }
    function countMatchGroups(re) {
      return new RegExp(re.toString() + "|").exec("").length - 1;
    }
    function startsWith(re, lexeme) {
      const match = re && re.exec(lexeme);
      return match && match.index === 0;
    }
    var BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function _rewriteBackreferences(regexps, { joinWith }) {
      let numCaptures = 0;
      return regexps.map((regex) => {
        numCaptures += 1;
        const offset = numCaptures;
        let re = source(regex);
        let out = "";
        while (re.length > 0) {
          const match = BACKREF_RE.exec(re);
          if (!match) {
            out += re;
            break;
          }
          out += re.substring(0, match.index);
          re = re.substring(match.index + match[0].length);
          if (match[0][0] === "\\" && match[1]) {
            out += "\\" + String(Number(match[1]) + offset);
          } else {
            out += match[0];
            if (match[0] === "(") {
              numCaptures++;
            }
          }
        }
        return out;
      }).map((re) => `(${re})`).join(joinWith);
    }
    var MATCH_NOTHING_RE = /\b\B/;
    var IDENT_RE = "[a-zA-Z]\\w*";
    var UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
    var NUMBER_RE = "\\b\\d+(\\.\\d+)?";
    var C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
    var BINARY_NUMBER_RE = "\\b(0b[01]+)";
    var RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
    var SHEBANG = (opts = {}) => {
      const beginShebang = /^#![ ]*\//;
      if (opts.binary) {
        opts.begin = concat(
          beginShebang,
          /.*\b/,
          opts.binary,
          /\b.*/
        );
      }
      return inherit$1({
        scope: "meta",
        begin: beginShebang,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (m, resp) => {
          if (m.index !== 0) resp.ignoreMatch();
        }
      }, opts);
    };
    var BACKSLASH_ESCAPE = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    };
    var APOS_STRING_MODE = {
      scope: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    var QUOTE_STRING_MODE = {
      scope: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    var PHRASAL_WORDS_MODE = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    };
    var COMMENT = function(begin, end, modeOptions = {}) {
      const mode = inherit$1(
        {
          scope: "comment",
          begin,
          end,
          contains: []
        },
        modeOptions
      );
      mode.contains.push({
        scope: "doctag",
        // hack to avoid the space from being included. the space is necessary to
        // match here to prevent the plain text rule below from gobbling up doctags
        begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
        excludeBegin: true,
        relevance: 0
      });
      const ENGLISH_WORD = either(
        // list of common 1 and 2 letter words in English
        "I",
        "a",
        "is",
        "so",
        "us",
        "to",
        "at",
        "if",
        "in",
        "it",
        "on",
        // note: this is not an exhaustive list of contractions, just popular ones
        /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
        // contractions - can't we'd they're let's, etc
        /[A-Za-z]+[-][a-z]+/,
        // `no-way`, etc.
        /[A-Za-z][a-z]{2,}/
        // allow capitalized words at beginning of sentences
      );
      mode.contains.push(
        {
          // TODO: how to include ", (, ) without breaking grammars that use these for
          // comment delimiters?
          // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
          // ---
          // this tries to find sequences of 3 english words in a row (without any
          // "programming" type syntax) this gives us a strong signal that we've
          // TRULY found a comment - vs perhaps scanning with the wrong language.
          // It's possible to find something that LOOKS like the start of the
          // comment - but then if there is no readable text - good chance it is a
          // false match and not a comment.
          //
          // for a visual example please see:
          // https://github.com/highlightjs/highlight.js/issues/2827
          begin: concat(
            /[ ]+/,
            // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
            "(",
            ENGLISH_WORD,
            /[.]?[:]?([.][ ]|[ ])/,
            "){3}"
          )
          // look for 3 words in a row
        }
      );
      return mode;
    };
    var C_LINE_COMMENT_MODE = COMMENT("//", "$");
    var C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
    var HASH_COMMENT_MODE = COMMENT("#", "$");
    var NUMBER_MODE = {
      scope: "number",
      begin: NUMBER_RE,
      relevance: 0
    };
    var C_NUMBER_MODE = {
      scope: "number",
      begin: C_NUMBER_RE,
      relevance: 0
    };
    var BINARY_NUMBER_MODE = {
      scope: "number",
      begin: BINARY_NUMBER_RE,
      relevance: 0
    };
    var REGEXP_MODE = {
      scope: "regexp",
      begin: /\/(?=[^/\n]*\/)/,
      end: /\/[gimuy]*/,
      contains: [
        BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [BACKSLASH_ESCAPE]
        }
      ]
    };
    var TITLE_MODE = {
      scope: "title",
      begin: IDENT_RE,
      relevance: 0
    };
    var UNDERSCORE_TITLE_MODE = {
      scope: "title",
      begin: UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    var METHOD_GUARD = {
      // excludes method names from keyword processing
      begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    var END_SAME_AS_BEGIN = function(mode) {
      return Object.assign(
        mode,
        {
          /** @type {ModeCallback} */
          "on:begin": (m, resp) => {
            resp.data._beginMatch = m[1];
          },
          /** @type {ModeCallback} */
          "on:end": (m, resp) => {
            if (resp.data._beginMatch !== m[1]) resp.ignoreMatch();
          }
        }
      );
    };
    var MODES = Object.freeze({
      __proto__: null,
      APOS_STRING_MODE,
      BACKSLASH_ESCAPE,
      BINARY_NUMBER_MODE,
      BINARY_NUMBER_RE,
      COMMENT,
      C_BLOCK_COMMENT_MODE,
      C_LINE_COMMENT_MODE,
      C_NUMBER_MODE,
      C_NUMBER_RE,
      END_SAME_AS_BEGIN,
      HASH_COMMENT_MODE,
      IDENT_RE,
      MATCH_NOTHING_RE,
      METHOD_GUARD,
      NUMBER_MODE,
      NUMBER_RE,
      PHRASAL_WORDS_MODE,
      QUOTE_STRING_MODE,
      REGEXP_MODE,
      RE_STARTERS_RE,
      SHEBANG,
      TITLE_MODE,
      UNDERSCORE_IDENT_RE,
      UNDERSCORE_TITLE_MODE
    });
    function skipIfHasPrecedingDot(match, response) {
      const before = match.input[match.index - 1];
      if (before === ".") {
        response.ignoreMatch();
      }
    }
    function scopeClassName(mode, _parent) {
      if (mode.className !== void 0) {
        mode.scope = mode.className;
        delete mode.className;
      }
    }
    function beginKeywords(mode, parent) {
      if (!parent) return;
      if (!mode.beginKeywords) return;
      mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
      mode.__beforeBegin = skipIfHasPrecedingDot;
      mode.keywords = mode.keywords || mode.beginKeywords;
      delete mode.beginKeywords;
      if (mode.relevance === void 0) mode.relevance = 0;
    }
    function compileIllegal(mode, _parent) {
      if (!Array.isArray(mode.illegal)) return;
      mode.illegal = either(...mode.illegal);
    }
    function compileMatch(mode, _parent) {
      if (!mode.match) return;
      if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");
      mode.begin = mode.match;
      delete mode.match;
    }
    function compileRelevance(mode, _parent) {
      if (mode.relevance === void 0) mode.relevance = 1;
    }
    var beforeMatchExt = (mode, parent) => {
      if (!mode.beforeMatch) return;
      if (mode.starts) throw new Error("beforeMatch cannot be used with starts");
      const originalMode = Object.assign({}, mode);
      Object.keys(mode).forEach((key) => {
        delete mode[key];
      });
      mode.keywords = originalMode.keywords;
      mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
      mode.starts = {
        relevance: 0,
        contains: [
          Object.assign(originalMode, { endsParent: true })
        ]
      };
      mode.relevance = 0;
      delete originalMode.beforeMatch;
    };
    var COMMON_KEYWORDS = [
      "of",
      "and",
      "for",
      "in",
      "not",
      "or",
      "if",
      "then",
      "parent",
      // common variable name
      "list",
      // common variable name
      "value"
      // common variable name
    ];
    var DEFAULT_KEYWORD_SCOPE = "keyword";
    function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
      const compiledKeywords = /* @__PURE__ */ Object.create(null);
      if (typeof rawKeywords === "string") {
        compileList(scopeName, rawKeywords.split(" "));
      } else if (Array.isArray(rawKeywords)) {
        compileList(scopeName, rawKeywords);
      } else {
        Object.keys(rawKeywords).forEach(function(scopeName2) {
          Object.assign(
            compiledKeywords,
            compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
          );
        });
      }
      return compiledKeywords;
      function compileList(scopeName2, keywordList) {
        if (caseInsensitive) {
          keywordList = keywordList.map((x) => x.toLowerCase());
        }
        keywordList.forEach(function(keyword) {
          const pair = keyword.split("|");
          compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
        });
      }
    }
    function scoreForKeyword(keyword, providedScore) {
      if (providedScore) {
        return Number(providedScore);
      }
      return commonKeyword(keyword) ? 0 : 1;
    }
    function commonKeyword(keyword) {
      return COMMON_KEYWORDS.includes(keyword.toLowerCase());
    }
    var seenDeprecations = {};
    var error = (message) => {
      console.error(message);
    };
    var warn = (message, ...args) => {
      console.log(`WARN: ${message}`, ...args);
    };
    var deprecated = (version2, message) => {
      if (seenDeprecations[`${version2}/${message}`]) return;
      console.log(`Deprecated as of ${version2}. ${message}`);
      seenDeprecations[`${version2}/${message}`] = true;
    };
    var MultiClassError = new Error();
    function remapScopeNames(mode, regexes, { key }) {
      let offset = 0;
      const scopeNames = mode[key];
      const emit = {};
      const positions = {};
      for (let i = 1; i <= regexes.length; i++) {
        positions[i + offset] = scopeNames[i];
        emit[i + offset] = true;
        offset += countMatchGroups(regexes[i - 1]);
      }
      mode[key] = positions;
      mode[key]._emit = emit;
      mode[key]._multi = true;
    }
    function beginMultiClass(mode) {
      if (!Array.isArray(mode.begin)) return;
      if (mode.skip || mode.excludeBegin || mode.returnBegin) {
        error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
        throw MultiClassError;
      }
      if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
        error("beginScope must be object");
        throw MultiClassError;
      }
      remapScopeNames(mode, mode.begin, { key: "beginScope" });
      mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
    }
    function endMultiClass(mode) {
      if (!Array.isArray(mode.end)) return;
      if (mode.skip || mode.excludeEnd || mode.returnEnd) {
        error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
        throw MultiClassError;
      }
      if (typeof mode.endScope !== "object" || mode.endScope === null) {
        error("endScope must be object");
        throw MultiClassError;
      }
      remapScopeNames(mode, mode.end, { key: "endScope" });
      mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
    }
    function scopeSugar(mode) {
      if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
        mode.beginScope = mode.scope;
        delete mode.scope;
      }
    }
    function MultiClass(mode) {
      scopeSugar(mode);
      if (typeof mode.beginScope === "string") {
        mode.beginScope = { _wrap: mode.beginScope };
      }
      if (typeof mode.endScope === "string") {
        mode.endScope = { _wrap: mode.endScope };
      }
      beginMultiClass(mode);
      endMultiClass(mode);
    }
    function compileLanguage(language) {
      function langRe(value, global) {
        return new RegExp(
          source(value),
          "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global ? "g" : "")
        );
      }
      class MultiRegex {
        constructor() {
          this.matchIndexes = {};
          this.regexes = [];
          this.matchAt = 1;
          this.position = 0;
        }
        // @ts-ignore
        addRule(re, opts) {
          opts.position = this.position++;
          this.matchIndexes[this.matchAt] = opts;
          this.regexes.push([opts, re]);
          this.matchAt += countMatchGroups(re) + 1;
        }
        compile() {
          if (this.regexes.length === 0) {
            this.exec = () => null;
          }
          const terminators = this.regexes.map((el) => el[1]);
          this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
          this.lastIndex = 0;
        }
        /** @param {string} s */
        exec(s) {
          this.matcherRe.lastIndex = this.lastIndex;
          const match = this.matcherRe.exec(s);
          if (!match) {
            return null;
          }
          const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
          const matchData = this.matchIndexes[i];
          match.splice(0, i);
          return Object.assign(match, matchData);
        }
      }
      class ResumableMultiRegex {
        constructor() {
          this.rules = [];
          this.multiRegexes = [];
          this.count = 0;
          this.lastIndex = 0;
          this.regexIndex = 0;
        }
        // @ts-ignore
        getMatcher(index) {
          if (this.multiRegexes[index]) return this.multiRegexes[index];
          const matcher = new MultiRegex();
          this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
          matcher.compile();
          this.multiRegexes[index] = matcher;
          return matcher;
        }
        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }
        considerAll() {
          this.regexIndex = 0;
        }
        // @ts-ignore
        addRule(re, opts) {
          this.rules.push([re, opts]);
          if (opts.type === "begin") this.count++;
        }
        /** @param {string} s */
        exec(s) {
          const m = this.getMatcher(this.regexIndex);
          m.lastIndex = this.lastIndex;
          let result = m.exec(s);
          if (this.resumingScanAtSamePosition()) {
            if (result && result.index === this.lastIndex) ;
            else {
              const m2 = this.getMatcher(0);
              m2.lastIndex = this.lastIndex + 1;
              result = m2.exec(s);
            }
          }
          if (result) {
            this.regexIndex += result.position + 1;
            if (this.regexIndex === this.count) {
              this.considerAll();
            }
          }
          return result;
        }
      }
      function buildModeRegex(mode) {
        const mm = new ResumableMultiRegex();
        mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
        if (mode.terminatorEnd) {
          mm.addRule(mode.terminatorEnd, { type: "end" });
        }
        if (mode.illegal) {
          mm.addRule(mode.illegal, { type: "illegal" });
        }
        return mm;
      }
      function compileMode(mode, parent) {
        const cmode = (
          /** @type CompiledMode */
          mode
        );
        if (mode.isCompiled) return cmode;
        [
          scopeClassName,
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          compileMatch,
          MultiClass,
          beforeMatchExt
        ].forEach((ext) => ext(mode, parent));
        language.compilerExtensions.forEach((ext) => ext(mode, parent));
        mode.__beforeBegin = null;
        [
          beginKeywords,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          compileIllegal,
          // default to 1 relevance if not specified
          compileRelevance
        ].forEach((ext) => ext(mode, parent));
        mode.isCompiled = true;
        let keywordPattern = null;
        if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
          mode.keywords = Object.assign({}, mode.keywords);
          keywordPattern = mode.keywords.$pattern;
          delete mode.keywords.$pattern;
        }
        keywordPattern = keywordPattern || /\w+/;
        if (mode.keywords) {
          mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
        }
        cmode.keywordPatternRe = langRe(keywordPattern, true);
        if (parent) {
          if (!mode.begin) mode.begin = /\B|\b/;
          cmode.beginRe = langRe(cmode.begin);
          if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
          if (mode.end) cmode.endRe = langRe(cmode.end);
          cmode.terminatorEnd = source(cmode.end) || "";
          if (mode.endsWithParent && parent.terminatorEnd) {
            cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
          }
        }
        if (mode.illegal) cmode.illegalRe = langRe(
          /** @type {RegExp | string} */
          mode.illegal
        );
        if (!mode.contains) mode.contains = [];
        mode.contains = [].concat(...mode.contains.map(function(c) {
          return expandOrCloneMode(c === "self" ? mode : c);
        }));
        mode.contains.forEach(function(c) {
          compileMode(
            /** @type Mode */
            c,
            cmode
          );
        });
        if (mode.starts) {
          compileMode(mode.starts, parent);
        }
        cmode.matcher = buildModeRegex(cmode);
        return cmode;
      }
      if (!language.compilerExtensions) language.compilerExtensions = [];
      if (language.contains && language.contains.includes("self")) {
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      }
      language.classNameAliases = inherit$1(language.classNameAliases || {});
      return compileMode(
        /** @type Mode */
        language
      );
    }
    function dependencyOnParent(mode) {
      if (!mode) return false;
      return mode.endsWithParent || dependencyOnParent(mode.starts);
    }
    function expandOrCloneMode(mode) {
      if (mode.variants && !mode.cachedVariants) {
        mode.cachedVariants = mode.variants.map(function(variant) {
          return inherit$1(mode, { variants: null }, variant);
        });
      }
      if (mode.cachedVariants) {
        return mode.cachedVariants;
      }
      if (dependencyOnParent(mode)) {
        return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
      }
      if (Object.isFrozen(mode)) {
        return inherit$1(mode);
      }
      return mode;
    }
    var version = "11.11.1";
    var HTMLInjectionError = class extends Error {
      constructor(reason, html) {
        super(reason);
        this.name = "HTMLInjectionError";
        this.html = html;
      }
    };
    var escape = escapeHTML;
    var inherit = inherit$1;
    var NO_MATCH = Symbol("nomatch");
    var MAX_KEYWORD_HITS = 7;
    var HLJS = function(hljs) {
      const languages = /* @__PURE__ */ Object.create(null);
      const aliases = /* @__PURE__ */ Object.create(null);
      const plugins = [];
      let SAFE_MODE = true;
      const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
      let options = {
        ignoreUnescapedHTML: false,
        throwUnescapedHTML: false,
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        cssSelector: "pre code",
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: TokenTreeEmitter
      };
      function shouldNotHighlight(languageName) {
        return options.noHighlightRe.test(languageName);
      }
      function blockLanguage(block) {
        let classes = block.className + " ";
        classes += block.parentNode ? block.parentNode.className : "";
        const match = options.languageDetectRe.exec(classes);
        if (match) {
          const language = getLanguage(match[1]);
          if (!language) {
            warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
            warn("Falling back to no-highlight mode for this block.", block);
          }
          return language ? match[1] : "no-highlight";
        }
        return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
      }
      function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
        let code = "";
        let languageName = "";
        if (typeof optionsOrCode === "object") {
          code = codeOrLanguageName;
          ignoreIllegals = optionsOrCode.ignoreIllegals;
          languageName = optionsOrCode.language;
        } else {
          deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
          deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
          languageName = codeOrLanguageName;
          code = optionsOrCode;
        }
        if (ignoreIllegals === void 0) {
          ignoreIllegals = true;
        }
        const context = {
          code,
          language: languageName
        };
        fire("before:highlight", context);
        const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
        result.code = context.code;
        fire("after:highlight", result);
        return result;
      }
      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
        const keywordHits = /* @__PURE__ */ Object.create(null);
        function keywordData(mode, matchText) {
          return mode.keywords[matchText];
        }
        function processKeywords() {
          if (!top.keywords) {
            emitter.addText(modeBuffer);
            return;
          }
          let lastIndex = 0;
          top.keywordPatternRe.lastIndex = 0;
          let match = top.keywordPatternRe.exec(modeBuffer);
          let buf = "";
          while (match) {
            buf += modeBuffer.substring(lastIndex, match.index);
            const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
            const data = keywordData(top, word);
            if (data) {
              const [kind, keywordRelevance] = data;
              emitter.addText(buf);
              buf = "";
              keywordHits[word] = (keywordHits[word] || 0) + 1;
              if (keywordHits[word] <= MAX_KEYWORD_HITS) relevance += keywordRelevance;
              if (kind.startsWith("_")) {
                buf += match[0];
              } else {
                const cssClass = language.classNameAliases[kind] || kind;
                emitKeyword(match[0], cssClass);
              }
            } else {
              buf += match[0];
            }
            lastIndex = top.keywordPatternRe.lastIndex;
            match = top.keywordPatternRe.exec(modeBuffer);
          }
          buf += modeBuffer.substring(lastIndex);
          emitter.addText(buf);
        }
        function processSubLanguage() {
          if (modeBuffer === "") return;
          let result2 = null;
          if (typeof top.subLanguage === "string") {
            if (!languages[top.subLanguage]) {
              emitter.addText(modeBuffer);
              return;
            }
            result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
            continuations[top.subLanguage] = /** @type {CompiledMode} */
            result2._top;
          } else {
            result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
          }
          if (top.relevance > 0) {
            relevance += result2.relevance;
          }
          emitter.__addSublanguage(result2._emitter, result2.language);
        }
        function processBuffer() {
          if (top.subLanguage != null) {
            processSubLanguage();
          } else {
            processKeywords();
          }
          modeBuffer = "";
        }
        function emitKeyword(keyword, scope) {
          if (keyword === "") return;
          emitter.startScope(scope);
          emitter.addText(keyword);
          emitter.endScope();
        }
        function emitMultiClass(scope, match) {
          let i = 1;
          const max = match.length - 1;
          while (i <= max) {
            if (!scope._emit[i]) {
              i++;
              continue;
            }
            const klass = language.classNameAliases[scope[i]] || scope[i];
            const text = match[i];
            if (klass) {
              emitKeyword(text, klass);
            } else {
              modeBuffer = text;
              processKeywords();
              modeBuffer = "";
            }
            i++;
          }
        }
        function startNewMode(mode, match) {
          if (mode.scope && typeof mode.scope === "string") {
            emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
          }
          if (mode.beginScope) {
            if (mode.beginScope._wrap) {
              emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
              modeBuffer = "";
            } else if (mode.beginScope._multi) {
              emitMultiClass(mode.beginScope, match);
              modeBuffer = "";
            }
          }
          top = Object.create(mode, { parent: { value: top } });
          return top;
        }
        function endOfMode(mode, match, matchPlusRemainder) {
          let matched = startsWith(mode.endRe, matchPlusRemainder);
          if (matched) {
            if (mode["on:end"]) {
              const resp = new Response(mode);
              mode["on:end"](match, resp);
              if (resp.isMatchIgnored) matched = false;
            }
            if (matched) {
              while (mode.endsParent && mode.parent) {
                mode = mode.parent;
              }
              return mode;
            }
          }
          if (mode.endsWithParent) {
            return endOfMode(mode.parent, match, matchPlusRemainder);
          }
        }
        function doIgnore(lexeme) {
          if (top.matcher.regexIndex === 0) {
            modeBuffer += lexeme[0];
            return 1;
          } else {
            resumeScanAtSamePosition = true;
            return 0;
          }
        }
        function doBeginMatch(match) {
          const lexeme = match[0];
          const newMode = match.rule;
          const resp = new Response(newMode);
          const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
          for (const cb of beforeCallbacks) {
            if (!cb) continue;
            cb(match, resp);
            if (resp.isMatchIgnored) return doIgnore(lexeme);
          }
          if (newMode.skip) {
            modeBuffer += lexeme;
          } else {
            if (newMode.excludeBegin) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (!newMode.returnBegin && !newMode.excludeBegin) {
              modeBuffer = lexeme;
            }
          }
          startNewMode(newMode, match);
          return newMode.returnBegin ? 0 : lexeme.length;
        }
        function doEndMatch(match) {
          const lexeme = match[0];
          const matchPlusRemainder = codeToHighlight.substring(match.index);
          const endMode = endOfMode(top, match, matchPlusRemainder);
          if (!endMode) {
            return NO_MATCH;
          }
          const origin = top;
          if (top.endScope && top.endScope._wrap) {
            processBuffer();
            emitKeyword(lexeme, top.endScope._wrap);
          } else if (top.endScope && top.endScope._multi) {
            processBuffer();
            emitMultiClass(top.endScope, match);
          } else if (origin.skip) {
            modeBuffer += lexeme;
          } else {
            if (!(origin.returnEnd || origin.excludeEnd)) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (origin.excludeEnd) {
              modeBuffer = lexeme;
            }
          }
          do {
            if (top.scope) {
              emitter.closeNode();
            }
            if (!top.skip && !top.subLanguage) {
              relevance += top.relevance;
            }
            top = top.parent;
          } while (top !== endMode.parent);
          if (endMode.starts) {
            startNewMode(endMode.starts, match);
          }
          return origin.returnEnd ? 0 : lexeme.length;
        }
        function processContinuations() {
          const list = [];
          for (let current = top; current !== language; current = current.parent) {
            if (current.scope) {
              list.unshift(current.scope);
            }
          }
          list.forEach((item) => emitter.openNode(item));
        }
        let lastMatch = {};
        function processLexeme(textBeforeMatch, match) {
          const lexeme = match && match[0];
          modeBuffer += textBeforeMatch;
          if (lexeme == null) {
            processBuffer();
            return 0;
          }
          if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
            modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
            if (!SAFE_MODE) {
              const err = new Error(`0 width match regex (${languageName})`);
              err.languageName = languageName;
              err.badRule = lastMatch.rule;
              throw err;
            }
            return 1;
          }
          lastMatch = match;
          if (match.type === "begin") {
            return doBeginMatch(match);
          } else if (match.type === "illegal" && !ignoreIllegals) {
            const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
            err.mode = top;
            throw err;
          } else if (match.type === "end") {
            const processed = doEndMatch(match);
            if (processed !== NO_MATCH) {
              return processed;
            }
          }
          if (match.type === "illegal" && lexeme === "") {
            modeBuffer += "\n";
            return 1;
          }
          if (iterations > 1e5 && iterations > match.index * 3) {
            const err = new Error("potential infinite loop, way more iterations than matches");
            throw err;
          }
          modeBuffer += lexeme;
          return lexeme.length;
        }
        const language = getLanguage(languageName);
        if (!language) {
          error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
          throw new Error('Unknown language: "' + languageName + '"');
        }
        const md = compileLanguage(language);
        let result = "";
        let top = continuation || md;
        const continuations = {};
        const emitter = new options.__emitter(options);
        processContinuations();
        let modeBuffer = "";
        let relevance = 0;
        let index = 0;
        let iterations = 0;
        let resumeScanAtSamePosition = false;
        try {
          if (!language.__emitTokens) {
            top.matcher.considerAll();
            for (; ; ) {
              iterations++;
              if (resumeScanAtSamePosition) {
                resumeScanAtSamePosition = false;
              } else {
                top.matcher.considerAll();
              }
              top.matcher.lastIndex = index;
              const match = top.matcher.exec(codeToHighlight);
              if (!match) break;
              const beforeMatch = codeToHighlight.substring(index, match.index);
              const processedCount = processLexeme(beforeMatch, match);
              index = match.index + processedCount;
            }
            processLexeme(codeToHighlight.substring(index));
          } else {
            language.__emitTokens(codeToHighlight, emitter);
          }
          emitter.finalize();
          result = emitter.toHTML();
          return {
            language: languageName,
            value: result,
            relevance,
            illegal: false,
            _emitter: emitter,
            _top: top
          };
        } catch (err) {
          if (err.message && err.message.includes("Illegal")) {
            return {
              language: languageName,
              value: escape(codeToHighlight),
              illegal: true,
              relevance: 0,
              _illegalBy: {
                message: err.message,
                index,
                context: codeToHighlight.slice(index - 100, index + 100),
                mode: err.mode,
                resultSoFar: result
              },
              _emitter: emitter
            };
          } else if (SAFE_MODE) {
            return {
              language: languageName,
              value: escape(codeToHighlight),
              illegal: false,
              relevance: 0,
              errorRaised: err,
              _emitter: emitter,
              _top: top
            };
          } else {
            throw err;
          }
        }
      }
      function justTextHighlightResult(code) {
        const result = {
          value: escape(code),
          illegal: false,
          relevance: 0,
          _top: PLAINTEXT_LANGUAGE,
          _emitter: new options.__emitter(options)
        };
        result._emitter.addText(code);
        return result;
      }
      function highlightAuto(code, languageSubset) {
        languageSubset = languageSubset || options.languages || Object.keys(languages);
        const plaintext = justTextHighlightResult(code);
        const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
          (name) => _highlight(name, code, false)
        );
        results.unshift(plaintext);
        const sorted = results.sort((a, b) => {
          if (a.relevance !== b.relevance) return b.relevance - a.relevance;
          if (a.language && b.language) {
            if (getLanguage(a.language).supersetOf === b.language) {
              return 1;
            } else if (getLanguage(b.language).supersetOf === a.language) {
              return -1;
            }
          }
          return 0;
        });
        const [best, secondBest] = sorted;
        const result = best;
        result.secondBest = secondBest;
        return result;
      }
      function updateClassName(element, currentLang, resultLang) {
        const language = currentLang && aliases[currentLang] || resultLang;
        element.classList.add("hljs");
        element.classList.add(`language-${language}`);
      }
      function highlightElement(element) {
        let node = null;
        const language = blockLanguage(element);
        if (shouldNotHighlight(language)) return;
        fire(
          "before:highlightElement",
          { el: element, language }
        );
        if (element.dataset.highlighted) {
          console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", element);
          return;
        }
        if (element.children.length > 0) {
          if (!options.ignoreUnescapedHTML) {
            console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
            console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
            console.warn("The element with unescaped HTML:");
            console.warn(element);
          }
          if (options.throwUnescapedHTML) {
            const err = new HTMLInjectionError(
              "One of your code blocks includes unescaped HTML.",
              element.innerHTML
            );
            throw err;
          }
        }
        node = element;
        const text = node.textContent;
        const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
        element.innerHTML = result.value;
        element.dataset.highlighted = "yes";
        updateClassName(element, language, result.language);
        element.result = {
          language: result.language,
          // TODO: remove with version 11.0
          re: result.relevance,
          relevance: result.relevance
        };
        if (result.secondBest) {
          element.secondBest = {
            language: result.secondBest.language,
            relevance: result.secondBest.relevance
          };
        }
        fire("after:highlightElement", { el: element, result, text });
      }
      function configure(userOptions) {
        options = inherit(options, userOptions);
      }
      const initHighlighting = () => {
        highlightAll();
        deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
      };
      function initHighlightingOnLoad() {
        highlightAll();
        deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
      }
      let wantsHighlight = false;
      function highlightAll() {
        function boot() {
          highlightAll();
        }
        if (document.readyState === "loading") {
          if (!wantsHighlight) {
            window.addEventListener("DOMContentLoaded", boot, false);
          }
          wantsHighlight = true;
          return;
        }
        const blocks = document.querySelectorAll(options.cssSelector);
        blocks.forEach(highlightElement);
      }
      function registerLanguage(languageName, languageDefinition) {
        let lang = null;
        try {
          lang = languageDefinition(hljs);
        } catch (error$1) {
          error("Language definition for '{}' could not be registered.".replace("{}", languageName));
          if (!SAFE_MODE) {
            throw error$1;
          } else {
            error(error$1);
          }
          lang = PLAINTEXT_LANGUAGE;
        }
        if (!lang.name) lang.name = languageName;
        languages[languageName] = lang;
        lang.rawDefinition = languageDefinition.bind(null, hljs);
        if (lang.aliases) {
          registerAliases(lang.aliases, { languageName });
        }
      }
      function unregisterLanguage(languageName) {
        delete languages[languageName];
        for (const alias of Object.keys(aliases)) {
          if (aliases[alias] === languageName) {
            delete aliases[alias];
          }
        }
      }
      function listLanguages() {
        return Object.keys(languages);
      }
      function getLanguage(name) {
        name = (name || "").toLowerCase();
        return languages[name] || languages[aliases[name]];
      }
      function registerAliases(aliasList, { languageName }) {
        if (typeof aliasList === "string") {
          aliasList = [aliasList];
        }
        aliasList.forEach((alias) => {
          aliases[alias.toLowerCase()] = languageName;
        });
      }
      function autoDetection(name) {
        const lang = getLanguage(name);
        return lang && !lang.disableAutodetect;
      }
      function upgradePluginAPI(plugin) {
        if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
          plugin["before:highlightElement"] = (data) => {
            plugin["before:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
        if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
          plugin["after:highlightElement"] = (data) => {
            plugin["after:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
      }
      function addPlugin(plugin) {
        upgradePluginAPI(plugin);
        plugins.push(plugin);
      }
      function removePlugin(plugin) {
        const index = plugins.indexOf(plugin);
        if (index !== -1) {
          plugins.splice(index, 1);
        }
      }
      function fire(event, args) {
        const cb = event;
        plugins.forEach(function(plugin) {
          if (plugin[cb]) {
            plugin[cb](args);
          }
        });
      }
      function deprecateHighlightBlock(el) {
        deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
        deprecated("10.7.0", "Please use highlightElement now.");
        return highlightElement(el);
      }
      Object.assign(hljs, {
        highlight: highlight2,
        highlightAuto,
        highlightAll,
        highlightElement,
        // TODO: Remove with v12 API
        highlightBlock: deprecateHighlightBlock,
        configure,
        initHighlighting,
        initHighlightingOnLoad,
        registerLanguage,
        unregisterLanguage,
        listLanguages,
        getLanguage,
        registerAliases,
        autoDetection,
        inherit,
        addPlugin,
        removePlugin
      });
      hljs.debugMode = function() {
        SAFE_MODE = false;
      };
      hljs.safeMode = function() {
        SAFE_MODE = true;
      };
      hljs.versionString = version;
      hljs.regex = {
        concat,
        lookahead,
        either,
        optional,
        anyNumberOfTimes
      };
      for (const key in MODES) {
        if (typeof MODES[key] === "object") {
          deepFreeze(MODES[key]);
        }
      }
      Object.assign(hljs, MODES);
      return hljs;
    };
    var highlight = HLJS({});
    highlight.newInstance = () => HLJS({});
    module.exports = highlight;
    highlight.HighlightJS = highlight;
    highlight.default = highlight;
  }
});

// node_modules/highlight.js/lib/languages/xml.js
var require_xml = __commonJS({
  "node_modules/highlight.js/lib/languages/xml.js"(exports, module) {
    function xml(hljs) {
      const regex = hljs.regex;
      const TAG_NAME_RE = regex.concat(/[\p{L}_]/u, regex.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u);
      const XML_IDENT_RE = /[\p{L}0-9._:-]+/u;
      const XML_ENTITIES = {
        className: "symbol",
        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
      };
      const XML_META_KEYWORDS = {
        begin: /\s/,
        contains: [
          {
            className: "keyword",
            begin: /#?[a-z_][a-z1-9_-]+/,
            illegal: /\n/
          }
        ]
      };
      const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
        begin: /\(/,
        end: /\)/
      });
      const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: "string" });
      const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" });
      const TAG_INTERNALS = {
        endsWithParent: true,
        illegal: /</,
        relevance: 0,
        contains: [
          {
            className: "attr",
            begin: XML_IDENT_RE,
            relevance: 0
          },
          {
            begin: /=\s*/,
            relevance: 0,
            contains: [
              {
                className: "string",
                endsParent: true,
                variants: [
                  {
                    begin: /"/,
                    end: /"/,
                    contains: [XML_ENTITIES]
                  },
                  {
                    begin: /'/,
                    end: /'/,
                    contains: [XML_ENTITIES]
                  },
                  { begin: /[^\s"'=<>`]+/ }
                ]
              }
            ]
          }
        ]
      };
      return {
        name: "HTML, XML",
        aliases: [
          "html",
          "xhtml",
          "rss",
          "atom",
          "xjb",
          "xsd",
          "xsl",
          "plist",
          "wsf",
          "svg"
        ],
        case_insensitive: true,
        unicodeRegex: true,
        contains: [
          {
            className: "meta",
            begin: /<![a-z]/,
            end: />/,
            relevance: 10,
            contains: [
              XML_META_KEYWORDS,
              QUOTE_META_STRING_MODE,
              APOS_META_STRING_MODE,
              XML_META_PAR_KEYWORDS,
              {
                begin: /\[/,
                end: /\]/,
                contains: [
                  {
                    className: "meta",
                    begin: /<![a-z]/,
                    end: />/,
                    contains: [
                      XML_META_KEYWORDS,
                      XML_META_PAR_KEYWORDS,
                      QUOTE_META_STRING_MODE,
                      APOS_META_STRING_MODE
                    ]
                  }
                ]
              }
            ]
          },
          hljs.COMMENT(
            /<!--/,
            /-->/,
            { relevance: 10 }
          ),
          {
            begin: /<!\[CDATA\[/,
            end: /\]\]>/,
            relevance: 10
          },
          XML_ENTITIES,
          // xml processing instructions
          {
            className: "meta",
            end: /\?>/,
            variants: [
              {
                begin: /<\?xml/,
                relevance: 10,
                contains: [
                  QUOTE_META_STRING_MODE
                ]
              },
              {
                begin: /<\?[a-z][a-z0-9]+/
              }
            ]
          },
          {
            className: "tag",
            /*
            The lookahead pattern (?=...) ensures that 'begin' only matches
            '<style' as a single word, followed by a whitespace or an
            ending bracket.
            */
            begin: /<style(?=\s|>)/,
            end: />/,
            keywords: { name: "style" },
            contains: [TAG_INTERNALS],
            starts: {
              end: /<\/style>/,
              returnEnd: true,
              subLanguage: [
                "css",
                "xml"
              ]
            }
          },
          {
            className: "tag",
            // See the comment in the <style tag about the lookahead pattern
            begin: /<script(?=\s|>)/,
            end: />/,
            keywords: { name: "script" },
            contains: [TAG_INTERNALS],
            starts: {
              end: /<\/script>/,
              returnEnd: true,
              subLanguage: [
                "javascript",
                "handlebars",
                "xml"
              ]
            }
          },
          // we need this for now for jSX
          {
            className: "tag",
            begin: /<>|<\/>/
          },
          // open tag
          {
            className: "tag",
            begin: regex.concat(
              /</,
              regex.lookahead(regex.concat(
                TAG_NAME_RE,
                // <tag/>
                // <tag>
                // <tag ...
                regex.either(/\/>/, />/, /\s/)
              ))
            ),
            end: /\/?>/,
            contains: [
              {
                className: "name",
                begin: TAG_NAME_RE,
                relevance: 0,
                starts: TAG_INTERNALS
              }
            ]
          },
          // close tag
          {
            className: "tag",
            begin: regex.concat(
              /<\//,
              regex.lookahead(regex.concat(
                TAG_NAME_RE,
                />/
              ))
            ),
            contains: [
              {
                className: "name",
                begin: TAG_NAME_RE,
                relevance: 0
              },
              {
                begin: />/,
                relevance: 0,
                endsParent: true
              }
            ]
          }
        ]
      };
    }
    module.exports = xml;
  }
});

// node_modules/highlight.js/lib/languages/bash.js
var require_bash = __commonJS({
  "node_modules/highlight.js/lib/languages/bash.js"(exports, module) {
    function bash(hljs) {
      const regex = hljs.regex;
      const VAR = {};
      const BRACED_VAR = {
        begin: /\$\{/,
        end: /\}/,
        contains: [
          "self",
          {
            begin: /:-/,
            contains: [VAR]
          }
          // default values
        ]
      };
      Object.assign(VAR, {
        className: "variable",
        variants: [
          { begin: regex.concat(
            /\$[\w\d#@][\w\d_]*/,
            // negative look-ahead tries to avoid matching patterns that are not
            // Perl at all like $ident$, @ident@, etc.
            `(?![\\w\\d])(?![$])`
          ) },
          BRACED_VAR
        ]
      });
      const SUBST = {
        className: "subst",
        begin: /\$\(/,
        end: /\)/,
        contains: [hljs.BACKSLASH_ESCAPE]
      };
      const COMMENT = hljs.inherit(
        hljs.COMMENT(),
        {
          match: [
            /(^|\s)/,
            /#.*$/
          ],
          scope: {
            2: "comment"
          }
        }
      );
      const HERE_DOC = {
        begin: /<<-?\s*(?=\w+)/,
        starts: { contains: [
          hljs.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: "string"
          })
        ] }
      };
      const QUOTE_STRING = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          VAR,
          SUBST
        ]
      };
      SUBST.contains.push(QUOTE_STRING);
      const ESCAPED_QUOTE = {
        match: /\\"/
      };
      const APOS_STRING = {
        className: "string",
        begin: /'/,
        end: /'/
      };
      const ESCAPED_APOS = {
        match: /\\'/
      };
      const ARITHMETIC = {
        begin: /\$?\(\(/,
        end: /\)\)/,
        contains: [
          {
            begin: /\d+#[0-9a-f]+/,
            className: "number"
          },
          hljs.NUMBER_MODE,
          VAR
        ]
      };
      const SH_LIKE_SHELLS = [
        "fish",
        "bash",
        "zsh",
        "sh",
        "csh",
        "ksh",
        "tcsh",
        "dash",
        "scsh"
      ];
      const KNOWN_SHEBANG = hljs.SHEBANG({
        binary: `(${SH_LIKE_SHELLS.join("|")})`,
        relevance: 10
      });
      const FUNCTION = {
        className: "function",
        begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
        returnBegin: true,
        contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
        relevance: 0
      };
      const KEYWORDS = [
        "if",
        "then",
        "else",
        "elif",
        "fi",
        "time",
        "for",
        "while",
        "until",
        "in",
        "do",
        "done",
        "case",
        "esac",
        "coproc",
        "function",
        "select"
      ];
      const LITERALS = [
        "true",
        "false"
      ];
      const PATH_MODE = { match: /(\/[a-z._-]+)+/ };
      const SHELL_BUILT_INS = [
        "break",
        "cd",
        "continue",
        "eval",
        "exec",
        "exit",
        "export",
        "getopts",
        "hash",
        "pwd",
        "readonly",
        "return",
        "shift",
        "test",
        "times",
        "trap",
        "umask",
        "unset"
      ];
      const BASH_BUILT_INS = [
        "alias",
        "bind",
        "builtin",
        "caller",
        "command",
        "declare",
        "echo",
        "enable",
        "help",
        "let",
        "local",
        "logout",
        "mapfile",
        "printf",
        "read",
        "readarray",
        "source",
        "sudo",
        "type",
        "typeset",
        "ulimit",
        "unalias"
      ];
      const ZSH_BUILT_INS = [
        "autoload",
        "bg",
        "bindkey",
        "bye",
        "cap",
        "chdir",
        "clone",
        "comparguments",
        "compcall",
        "compctl",
        "compdescribe",
        "compfiles",
        "compgroups",
        "compquote",
        "comptags",
        "comptry",
        "compvalues",
        "dirs",
        "disable",
        "disown",
        "echotc",
        "echoti",
        "emulate",
        "fc",
        "fg",
        "float",
        "functions",
        "getcap",
        "getln",
        "history",
        "integer",
        "jobs",
        "kill",
        "limit",
        "log",
        "noglob",
        "popd",
        "print",
        "pushd",
        "pushln",
        "rehash",
        "sched",
        "setcap",
        "setopt",
        "stat",
        "suspend",
        "ttyctl",
        "unfunction",
        "unhash",
        "unlimit",
        "unsetopt",
        "vared",
        "wait",
        "whence",
        "where",
        "which",
        "zcompile",
        "zformat",
        "zftp",
        "zle",
        "zmodload",
        "zparseopts",
        "zprof",
        "zpty",
        "zregexparse",
        "zsocket",
        "zstyle",
        "ztcp"
      ];
      const GNU_CORE_UTILS = [
        "chcon",
        "chgrp",
        "chown",
        "chmod",
        "cp",
        "dd",
        "df",
        "dir",
        "dircolors",
        "ln",
        "ls",
        "mkdir",
        "mkfifo",
        "mknod",
        "mktemp",
        "mv",
        "realpath",
        "rm",
        "rmdir",
        "shred",
        "sync",
        "touch",
        "truncate",
        "vdir",
        "b2sum",
        "base32",
        "base64",
        "cat",
        "cksum",
        "comm",
        "csplit",
        "cut",
        "expand",
        "fmt",
        "fold",
        "head",
        "join",
        "md5sum",
        "nl",
        "numfmt",
        "od",
        "paste",
        "ptx",
        "pr",
        "sha1sum",
        "sha224sum",
        "sha256sum",
        "sha384sum",
        "sha512sum",
        "shuf",
        "sort",
        "split",
        "sum",
        "tac",
        "tail",
        "tr",
        "tsort",
        "unexpand",
        "uniq",
        "wc",
        "arch",
        "basename",
        "chroot",
        "date",
        "dirname",
        "du",
        "echo",
        "env",
        "expr",
        "factor",
        // "false", // keyword literal already
        "groups",
        "hostid",
        "id",
        "link",
        "logname",
        "nice",
        "nohup",
        "nproc",
        "pathchk",
        "pinky",
        "printenv",
        "printf",
        "pwd",
        "readlink",
        "runcon",
        "seq",
        "sleep",
        "stat",
        "stdbuf",
        "stty",
        "tee",
        "test",
        "timeout",
        // "true", // keyword literal already
        "tty",
        "uname",
        "unlink",
        "uptime",
        "users",
        "who",
        "whoami",
        "yes"
      ];
      return {
        name: "Bash",
        aliases: [
          "sh",
          "zsh"
        ],
        keywords: {
          $pattern: /\b[a-z][a-z0-9._-]+\b/,
          keyword: KEYWORDS,
          literal: LITERALS,
          built_in: [
            ...SHELL_BUILT_INS,
            ...BASH_BUILT_INS,
            // Shell modifiers
            "set",
            "shopt",
            ...ZSH_BUILT_INS,
            ...GNU_CORE_UTILS
          ]
        },
        contains: [
          KNOWN_SHEBANG,
          // to catch known shells and boost relevancy
          hljs.SHEBANG(),
          // to catch unknown shells but still highlight the shebang
          FUNCTION,
          ARITHMETIC,
          COMMENT,
          HERE_DOC,
          PATH_MODE,
          QUOTE_STRING,
          ESCAPED_QUOTE,
          APOS_STRING,
          ESCAPED_APOS,
          VAR
        ]
      };
    }
    module.exports = bash;
  }
});

// node_modules/highlight.js/lib/languages/c.js
var require_c = __commonJS({
  "node_modules/highlight.js/lib/languages/c.js"(exports, module) {
    function c(hljs) {
      const regex = hljs.regex;
      const C_LINE_COMMENT_MODE = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] });
      const DECLTYPE_AUTO_RE = "decltype\\(auto\\)";
      const NAMESPACE_RE = "[a-zA-Z_]\\w*::";
      const TEMPLATE_ARGUMENT_RE = "<[^<>]+>";
      const FUNCTION_TYPE_RE = "(" + DECLTYPE_AUTO_RE + "|" + regex.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex.optional(TEMPLATE_ARGUMENT_RE) + ")";
      const TYPES = {
        className: "type",
        variants: [
          { begin: "\\b[a-z\\d_]*_t\\b" },
          { match: /\batomic_[a-z]{3,6}\b/ }
        ]
      };
      const CHARACTER_ESCAPES = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)";
      const STRINGS = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(" + CHARACTER_ESCAPES + "|.)",
            end: "'",
            illegal: "."
          },
          hljs.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      };
      const NUMBERS = {
        className: "number",
        variants: [
          { match: /\b(0b[01']+)/ },
          { match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ },
          { match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ },
          { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }
        ],
        relevance: 0
      };
      const PREPROCESSOR = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          hljs.inherit(STRINGS, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      };
      const TITLE_MODE = {
        className: "title",
        begin: regex.optional(NAMESPACE_RE) + hljs.IDENT_RE,
        relevance: 0
      };
      const FUNCTION_TITLE = regex.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(";
      const C_KEYWORDS = [
        "asm",
        "auto",
        "break",
        "case",
        "continue",
        "default",
        "do",
        "else",
        "enum",
        "extern",
        "for",
        "fortran",
        "goto",
        "if",
        "inline",
        "register",
        "restrict",
        "return",
        "sizeof",
        "typeof",
        "typeof_unqual",
        "struct",
        "switch",
        "typedef",
        "union",
        "volatile",
        "while",
        "_Alignas",
        "_Alignof",
        "_Atomic",
        "_Generic",
        "_Noreturn",
        "_Static_assert",
        "_Thread_local",
        // aliases
        "alignas",
        "alignof",
        "noreturn",
        "static_assert",
        "thread_local",
        // not a C keyword but is, for all intents and purposes, treated exactly like one.
        "_Pragma"
      ];
      const C_TYPES = [
        "float",
        "double",
        "signed",
        "unsigned",
        "int",
        "short",
        "long",
        "char",
        "void",
        "_Bool",
        "_BitInt",
        "_Complex",
        "_Imaginary",
        "_Decimal32",
        "_Decimal64",
        "_Decimal96",
        "_Decimal128",
        "_Decimal64x",
        "_Decimal128x",
        "_Float16",
        "_Float32",
        "_Float64",
        "_Float128",
        "_Float32x",
        "_Float64x",
        "_Float128x",
        // modifiers
        "const",
        "static",
        "constexpr",
        // aliases
        "complex",
        "bool",
        "imaginary"
      ];
      const KEYWORDS = {
        keyword: C_KEYWORDS,
        type: C_TYPES,
        literal: "true false NULL",
        // TODO: apply hinting work similar to what was done in cpp.js
        built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
      };
      const EXPRESSION_CONTAINS = [
        PREPROCESSOR,
        TYPES,
        C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        NUMBERS,
        STRINGS
      ];
      const EXPRESSION_CONTEXT = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: KEYWORDS,
        contains: EXPRESSION_CONTAINS.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: KEYWORDS,
            contains: EXPRESSION_CONTAINS.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      };
      const FUNCTION_DECLARATION = {
        begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: KEYWORDS,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: DECLTYPE_AUTO_RE,
            keywords: KEYWORDS,
            relevance: 0
          },
          {
            begin: FUNCTION_TITLE,
            returnBegin: true,
            contains: [hljs.inherit(TITLE_MODE, { className: "title.function" })],
            relevance: 0
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: KEYWORDS,
            relevance: 0,
            contains: [
              C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE,
              STRINGS,
              NUMBERS,
              TYPES,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  "self",
                  C_LINE_COMMENT_MODE,
                  hljs.C_BLOCK_COMMENT_MODE,
                  STRINGS,
                  NUMBERS,
                  TYPES
                ]
              }
            ]
          },
          TYPES,
          C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          PREPROCESSOR
        ]
      };
      return {
        name: "C",
        aliases: ["h"],
        keywords: KEYWORDS,
        // Until differentiations are added between `c` and `cpp`, `c` will
        // not be auto-detected to avoid auto-detect conflicts between C and C++
        disableAutodetect: true,
        illegal: "</",
        contains: [].concat(
          EXPRESSION_CONTEXT,
          FUNCTION_DECLARATION,
          EXPRESSION_CONTAINS,
          [
            PREPROCESSOR,
            {
              begin: hljs.IDENT_RE + "::",
              keywords: KEYWORDS
            },
            {
              className: "class",
              beginKeywords: "enum class struct union",
              end: /[{;:<>=]/,
              contains: [
                { beginKeywords: "final class struct" },
                hljs.TITLE_MODE
              ]
            }
          ]
        ),
        exports: {
          preprocessor: PREPROCESSOR,
          strings: STRINGS,
          keywords: KEYWORDS
        }
      };
    }
    module.exports = c;
  }
});

// node_modules/highlight.js/lib/languages/cpp.js
var require_cpp = __commonJS({
  "node_modules/highlight.js/lib/languages/cpp.js"(exports, module) {
    function cpp(hljs) {
      const regex = hljs.regex;
      const C_LINE_COMMENT_MODE = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] });
      const DECLTYPE_AUTO_RE = "decltype\\(auto\\)";
      const NAMESPACE_RE = "[a-zA-Z_]\\w*::";
      const TEMPLATE_ARGUMENT_RE = "<[^<>]+>";
      const FUNCTION_TYPE_RE = "(?!struct)(" + DECLTYPE_AUTO_RE + "|" + regex.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex.optional(TEMPLATE_ARGUMENT_RE) + ")";
      const CPP_PRIMITIVE_TYPES = {
        className: "type",
        begin: "\\b[a-z\\d_]*_t\\b"
      };
      const CHARACTER_ESCAPES = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)";
      const STRINGS = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(" + CHARACTER_ESCAPES + "|.)",
            end: "'",
            illegal: "."
          },
          hljs.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      };
      const NUMBERS = {
        className: "number",
        variants: [
          // Floating-point literal.
          {
            begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
          },
          // Integer literal.
          {
            begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
            // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
            // literal highlight actually makes it stand out more.
          }
        ],
        relevance: 0
      };
      const PREPROCESSOR = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          hljs.inherit(STRINGS, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      };
      const TITLE_MODE = {
        className: "title",
        begin: regex.optional(NAMESPACE_RE) + hljs.IDENT_RE,
        relevance: 0
      };
      const FUNCTION_TITLE = regex.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(";
      const RESERVED_KEYWORDS = [
        "alignas",
        "alignof",
        "and",
        "and_eq",
        "asm",
        "atomic_cancel",
        "atomic_commit",
        "atomic_noexcept",
        "auto",
        "bitand",
        "bitor",
        "break",
        "case",
        "catch",
        "class",
        "co_await",
        "co_return",
        "co_yield",
        "compl",
        "concept",
        "const_cast|10",
        "consteval",
        "constexpr",
        "constinit",
        "continue",
        "decltype",
        "default",
        "delete",
        "do",
        "dynamic_cast|10",
        "else",
        "enum",
        "explicit",
        "export",
        "extern",
        "false",
        "final",
        "for",
        "friend",
        "goto",
        "if",
        "import",
        "inline",
        "module",
        "mutable",
        "namespace",
        "new",
        "noexcept",
        "not",
        "not_eq",
        "nullptr",
        "operator",
        "or",
        "or_eq",
        "override",
        "private",
        "protected",
        "public",
        "reflexpr",
        "register",
        "reinterpret_cast|10",
        "requires",
        "return",
        "sizeof",
        "static_assert",
        "static_cast|10",
        "struct",
        "switch",
        "synchronized",
        "template",
        "this",
        "thread_local",
        "throw",
        "transaction_safe",
        "transaction_safe_dynamic",
        "true",
        "try",
        "typedef",
        "typeid",
        "typename",
        "union",
        "using",
        "virtual",
        "volatile",
        "while",
        "xor",
        "xor_eq"
      ];
      const RESERVED_TYPES = [
        "bool",
        "char",
        "char16_t",
        "char32_t",
        "char8_t",
        "double",
        "float",
        "int",
        "long",
        "short",
        "void",
        "wchar_t",
        "unsigned",
        "signed",
        "const",
        "static"
      ];
      const TYPE_HINTS = [
        "any",
        "auto_ptr",
        "barrier",
        "binary_semaphore",
        "bitset",
        "complex",
        "condition_variable",
        "condition_variable_any",
        "counting_semaphore",
        "deque",
        "false_type",
        "flat_map",
        "flat_set",
        "future",
        "imaginary",
        "initializer_list",
        "istringstream",
        "jthread",
        "latch",
        "lock_guard",
        "multimap",
        "multiset",
        "mutex",
        "optional",
        "ostringstream",
        "packaged_task",
        "pair",
        "promise",
        "priority_queue",
        "queue",
        "recursive_mutex",
        "recursive_timed_mutex",
        "scoped_lock",
        "set",
        "shared_future",
        "shared_lock",
        "shared_mutex",
        "shared_timed_mutex",
        "shared_ptr",
        "stack",
        "string_view",
        "stringstream",
        "timed_mutex",
        "thread",
        "true_type",
        "tuple",
        "unique_lock",
        "unique_ptr",
        "unordered_map",
        "unordered_multimap",
        "unordered_multiset",
        "unordered_set",
        "variant",
        "vector",
        "weak_ptr",
        "wstring",
        "wstring_view"
      ];
      const FUNCTION_HINTS = [
        "abort",
        "abs",
        "acos",
        "apply",
        "as_const",
        "asin",
        "atan",
        "atan2",
        "calloc",
        "ceil",
        "cerr",
        "cin",
        "clog",
        "cos",
        "cosh",
        "cout",
        "declval",
        "endl",
        "exchange",
        "exit",
        "exp",
        "fabs",
        "floor",
        "fmod",
        "forward",
        "fprintf",
        "fputs",
        "free",
        "frexp",
        "fscanf",
        "future",
        "invoke",
        "isalnum",
        "isalpha",
        "iscntrl",
        "isdigit",
        "isgraph",
        "islower",
        "isprint",
        "ispunct",
        "isspace",
        "isupper",
        "isxdigit",
        "labs",
        "launder",
        "ldexp",
        "log",
        "log10",
        "make_pair",
        "make_shared",
        "make_shared_for_overwrite",
        "make_tuple",
        "make_unique",
        "malloc",
        "memchr",
        "memcmp",
        "memcpy",
        "memset",
        "modf",
        "move",
        "pow",
        "printf",
        "putchar",
        "puts",
        "realloc",
        "scanf",
        "sin",
        "sinh",
        "snprintf",
        "sprintf",
        "sqrt",
        "sscanf",
        "std",
        "stderr",
        "stdin",
        "stdout",
        "strcat",
        "strchr",
        "strcmp",
        "strcpy",
        "strcspn",
        "strlen",
        "strncat",
        "strncmp",
        "strncpy",
        "strpbrk",
        "strrchr",
        "strspn",
        "strstr",
        "swap",
        "tan",
        "tanh",
        "terminate",
        "to_underlying",
        "tolower",
        "toupper",
        "vfprintf",
        "visit",
        "vprintf",
        "vsprintf"
      ];
      const LITERALS = [
        "NULL",
        "false",
        "nullopt",
        "nullptr",
        "true"
      ];
      const BUILT_IN = ["_Pragma"];
      const CPP_KEYWORDS = {
        type: RESERVED_TYPES,
        keyword: RESERVED_KEYWORDS,
        literal: LITERALS,
        built_in: BUILT_IN,
        _type_hints: TYPE_HINTS
      };
      const FUNCTION_DISPATCH = {
        className: "function.dispatch",
        relevance: 0,
        keywords: {
          // Only for relevance, not highlighting.
          _hint: FUNCTION_HINTS
        },
        begin: regex.concat(
          /\b/,
          /(?!decltype)/,
          /(?!if)/,
          /(?!for)/,
          /(?!switch)/,
          /(?!while)/,
          hljs.IDENT_RE,
          regex.lookahead(/(<[^<>]+>|)\s*\(/)
        )
      };
      const EXPRESSION_CONTAINS = [
        FUNCTION_DISPATCH,
        PREPROCESSOR,
        CPP_PRIMITIVE_TYPES,
        C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        NUMBERS,
        STRINGS
      ];
      const EXPRESSION_CONTEXT = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: CPP_KEYWORDS,
        contains: EXPRESSION_CONTAINS.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: CPP_KEYWORDS,
            contains: EXPRESSION_CONTAINS.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      };
      const FUNCTION_DECLARATION = {
        className: "function",
        begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: CPP_KEYWORDS,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: DECLTYPE_AUTO_RE,
            keywords: CPP_KEYWORDS,
            relevance: 0
          },
          {
            begin: FUNCTION_TITLE,
            returnBegin: true,
            contains: [TITLE_MODE],
            relevance: 0
          },
          // needed because we do not have look-behind on the below rule
          // to prevent it from grabbing the final : in a :: pair
          {
            begin: /::/,
            relevance: 0
          },
          // initializers
          {
            begin: /:/,
            endsWithParent: true,
            contains: [
              STRINGS,
              NUMBERS
            ]
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: CPP_KEYWORDS,
            relevance: 0,
            contains: [
              C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE,
              STRINGS,
              NUMBERS,
              CPP_PRIMITIVE_TYPES,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: CPP_KEYWORDS,
                relevance: 0,
                contains: [
                  "self",
                  C_LINE_COMMENT_MODE,
                  hljs.C_BLOCK_COMMENT_MODE,
                  STRINGS,
                  NUMBERS,
                  CPP_PRIMITIVE_TYPES
                ]
              }
            ]
          },
          CPP_PRIMITIVE_TYPES,
          C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          PREPROCESSOR
        ]
      };
      return {
        name: "C++",
        aliases: [
          "cc",
          "c++",
          "h++",
          "hpp",
          "hh",
          "hxx",
          "cxx"
        ],
        keywords: CPP_KEYWORDS,
        illegal: "</",
        classNameAliases: { "function.dispatch": "built_in" },
        contains: [].concat(
          EXPRESSION_CONTEXT,
          FUNCTION_DECLARATION,
          FUNCTION_DISPATCH,
          EXPRESSION_CONTAINS,
          [
            PREPROCESSOR,
            {
              // containers: ie, `vector <int> rooms (9);`
              begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
              end: ">",
              keywords: CPP_KEYWORDS,
              contains: [
                "self",
                CPP_PRIMITIVE_TYPES
              ]
            },
            {
              begin: hljs.IDENT_RE + "::",
              keywords: CPP_KEYWORDS
            },
            {
              match: [
                // extra complexity to deal with `enum class` and `enum struct`
                /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
                /\s+/,
                /\w+/
              ],
              className: {
                1: "keyword",
                3: "title.class"
              }
            }
          ]
        )
      };
    }
    module.exports = cpp;
  }
});

// node_modules/highlight.js/lib/languages/csharp.js
var require_csharp = __commonJS({
  "node_modules/highlight.js/lib/languages/csharp.js"(exports, module) {
    function csharp(hljs) {
      const BUILT_IN_KEYWORDS = [
        "bool",
        "byte",
        "char",
        "decimal",
        "delegate",
        "double",
        "dynamic",
        "enum",
        "float",
        "int",
        "long",
        "nint",
        "nuint",
        "object",
        "sbyte",
        "short",
        "string",
        "ulong",
        "uint",
        "ushort"
      ];
      const FUNCTION_MODIFIERS = [
        "public",
        "private",
        "protected",
        "static",
        "internal",
        "protected",
        "abstract",
        "async",
        "extern",
        "override",
        "unsafe",
        "virtual",
        "new",
        "sealed",
        "partial"
      ];
      const LITERAL_KEYWORDS = [
        "default",
        "false",
        "null",
        "true"
      ];
      const NORMAL_KEYWORDS = [
        "abstract",
        "as",
        "base",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "do",
        "else",
        "event",
        "explicit",
        "extern",
        "finally",
        "fixed",
        "for",
        "foreach",
        "goto",
        "if",
        "implicit",
        "in",
        "interface",
        "internal",
        "is",
        "lock",
        "namespace",
        "new",
        "operator",
        "out",
        "override",
        "params",
        "private",
        "protected",
        "public",
        "readonly",
        "record",
        "ref",
        "return",
        "scoped",
        "sealed",
        "sizeof",
        "stackalloc",
        "static",
        "struct",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "unchecked",
        "unsafe",
        "using",
        "virtual",
        "void",
        "volatile",
        "while"
      ];
      const CONTEXTUAL_KEYWORDS = [
        "add",
        "alias",
        "and",
        "ascending",
        "args",
        "async",
        "await",
        "by",
        "descending",
        "dynamic",
        "equals",
        "file",
        "from",
        "get",
        "global",
        "group",
        "init",
        "into",
        "join",
        "let",
        "nameof",
        "not",
        "notnull",
        "on",
        "or",
        "orderby",
        "partial",
        "record",
        "remove",
        "required",
        "scoped",
        "select",
        "set",
        "unmanaged",
        "value|0",
        "var",
        "when",
        "where",
        "with",
        "yield"
      ];
      const KEYWORDS = {
        keyword: NORMAL_KEYWORDS.concat(CONTEXTUAL_KEYWORDS),
        built_in: BUILT_IN_KEYWORDS,
        literal: LITERAL_KEYWORDS
      };
      const TITLE_MODE = hljs.inherit(hljs.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" });
      const NUMBERS = {
        className: "number",
        variants: [
          { begin: "\\b(0b[01']+)" },
          { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
          { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
        ],
        relevance: 0
      };
      const RAW_STRING = {
        className: "string",
        begin: /"""("*)(?!")(.|\n)*?"""\1/,
        relevance: 1
      };
      const VERBATIM_STRING = {
        className: "string",
        begin: '@"',
        end: '"',
        contains: [{ begin: '""' }]
      };
      const VERBATIM_STRING_NO_LF = hljs.inherit(VERBATIM_STRING, { illegal: /\n/ });
      const SUBST = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS
      };
      const SUBST_NO_LF = hljs.inherit(SUBST, { illegal: /\n/ });
      const INTERPOLATED_STRING = {
        className: "string",
        begin: /\$"/,
        end: '"',
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          hljs.BACKSLASH_ESCAPE,
          SUBST_NO_LF
        ]
      };
      const INTERPOLATED_VERBATIM_STRING = {
        className: "string",
        begin: /\$@"/,
        end: '"',
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          SUBST
        ]
      };
      const INTERPOLATED_VERBATIM_STRING_NO_LF = hljs.inherit(INTERPOLATED_VERBATIM_STRING, {
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          SUBST_NO_LF
        ]
      });
      SUBST.contains = [
        INTERPOLATED_VERBATIM_STRING,
        INTERPOLATED_STRING,
        VERBATIM_STRING,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        NUMBERS,
        hljs.C_BLOCK_COMMENT_MODE
      ];
      SUBST_NO_LF.contains = [
        INTERPOLATED_VERBATIM_STRING_NO_LF,
        INTERPOLATED_STRING,
        VERBATIM_STRING_NO_LF,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        NUMBERS,
        hljs.inherit(hljs.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
      ];
      const STRING = { variants: [
        RAW_STRING,
        INTERPOLATED_VERBATIM_STRING,
        INTERPOLATED_STRING,
        VERBATIM_STRING,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ] };
      const GENERIC_MODIFIER = {
        begin: "<",
        end: ">",
        contains: [
          { beginKeywords: "in out" },
          TITLE_MODE
        ]
      };
      const TYPE_IDENT_RE = hljs.IDENT_RE + "(<" + hljs.IDENT_RE + "(\\s*,\\s*" + hljs.IDENT_RE + ")*>)?(\\[\\])?";
      const AT_IDENTIFIER = {
        // prevents expressions like `@class` from incorrect flagging
        // `class` as a keyword
        begin: "@" + hljs.IDENT_RE,
        relevance: 0
      };
      return {
        name: "C#",
        aliases: [
          "cs",
          "c#"
        ],
        keywords: KEYWORDS,
        illegal: /::/,
        contains: [
          hljs.COMMENT(
            "///",
            "$",
            {
              returnBegin: true,
              contains: [
                {
                  className: "doctag",
                  variants: [
                    {
                      begin: "///",
                      relevance: 0
                    },
                    { begin: "<!--|-->" },
                    {
                      begin: "</?",
                      end: ">"
                    }
                  ]
                }
              ]
            }
          ),
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            className: "meta",
            begin: "#",
            end: "$",
            keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
          },
          STRING,
          NUMBERS,
          {
            beginKeywords: "class interface",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:,]/,
            contains: [
              { beginKeywords: "where class" },
              TITLE_MODE,
              GENERIC_MODIFIER,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              TITLE_MODE,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "record",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              TITLE_MODE,
              GENERIC_MODIFIER,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // [Attributes("")]
            className: "meta",
            begin: "^\\s*\\[(?=[\\w])",
            excludeBegin: true,
            end: "\\]",
            excludeEnd: true,
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/
              }
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: "new return throw await else",
            relevance: 0
          },
          {
            className: "function",
            begin: "(" + TYPE_IDENT_RE + "\\s+)+" + hljs.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: true,
            end: /\s*[{;=]/,
            excludeEnd: true,
            keywords: KEYWORDS,
            contains: [
              // prevents these from being highlighted `title`
              {
                beginKeywords: FUNCTION_MODIFIERS.join(" "),
                relevance: 0
              },
              {
                begin: hljs.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                returnBegin: true,
                contains: [
                  hljs.TITLE_MODE,
                  GENERIC_MODIFIER
                ],
                relevance: 0
              },
              { match: /\(\)/ },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                excludeBegin: true,
                excludeEnd: true,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  STRING,
                  NUMBERS,
                  hljs.C_BLOCK_COMMENT_MODE
                ]
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          AT_IDENTIFIER
        ]
      };
    }
    module.exports = csharp;
  }
});

// node_modules/highlight.js/lib/languages/css.js
var require_css = __commonJS({
  "node_modules/highlight.js/lib/languages/css.js"(exports, module) {
    var MODES = (hljs) => {
      return {
        IMPORTANT: {
          scope: "meta",
          begin: "!important"
        },
        BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: {
          scope: "number",
          begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
        },
        FUNCTION_DISPATCH: {
          className: "built_in",
          begin: /[\w-]+(?=\()/
        },
        ATTRIBUTE_SELECTOR_MODE: {
          scope: "selector-attr",
          begin: /\[/,
          end: /\]/,
          illegal: "$",
          contains: [
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE
          ]
        },
        CSS_NUMBER_MODE: {
          scope: "number",
          begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
          relevance: 0
        },
        CSS_VARIABLE: {
          className: "attr",
          begin: /--[A-Za-z_][A-Za-z0-9_-]*/
        }
      };
    };
    var HTML_TAGS = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ];
    var SVG_TAGS = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ];
    var TAGS = [
      ...HTML_TAGS,
      ...SVG_TAGS
    ];
    var MEDIA_FEATURES = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse();
    var PSEUDO_CLASSES = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse();
    var PSEUDO_ELEMENTS = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse();
    var ATTRIBUTES = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    function css(hljs) {
      const regex = hljs.regex;
      const modes = MODES(hljs);
      const VENDOR_PREFIX = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ };
      const AT_MODIFIERS = "and or not only";
      const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
      const IDENT_RE = "[a-zA-Z-][a-zA-Z0-9_-]*";
      const STRINGS = [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ];
      return {
        name: "CSS",
        case_insensitive: true,
        illegal: /[=|'\$]/,
        keywords: { keyframePosition: "from to" },
        classNameAliases: {
          // for visual continuity with `tag {}` and because we
          // don't have a great class for this?
          keyframePosition: "selector-tag"
        },
        contains: [
          modes.BLOCK_COMMENT,
          VENDOR_PREFIX,
          // to recognize keyframe 40% etc which are outside the scope of our
          // attribute value mode
          modes.CSS_NUMBER_MODE,
          {
            className: "selector-id",
            begin: /#[A-Za-z0-9_-]+/,
            relevance: 0
          },
          {
            className: "selector-class",
            begin: "\\." + IDENT_RE,
            relevance: 0
          },
          modes.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-pseudo",
            variants: [
              { begin: ":(" + PSEUDO_CLASSES.join("|") + ")" },
              { begin: ":(:)?(" + PSEUDO_ELEMENTS.join("|") + ")" }
            ]
          },
          // we may actually need this (12/2020)
          // { // pseudo-selector params
          //   begin: /\(/,
          //   end: /\)/,
          //   contains: [ hljs.CSS_NUMBER_MODE ]
          // },
          modes.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
          },
          // attribute values
          {
            begin: /:/,
            end: /[;}{]/,
            contains: [
              modes.BLOCK_COMMENT,
              modes.HEXCOLOR,
              modes.IMPORTANT,
              modes.CSS_NUMBER_MODE,
              ...STRINGS,
              // needed to highlight these as strings and to avoid issues with
              // illegal characters that might be inside urls that would tigger the
              // languages illegal stack
              {
                begin: /(url|data-uri)\(/,
                end: /\)/,
                relevance: 0,
                // from keywords
                keywords: { built_in: "url data-uri" },
                contains: [
                  ...STRINGS,
                  {
                    className: "string",
                    // any character other than `)` as in `url()` will be the start
                    // of a string, which ends with `)` (from the parent mode)
                    begin: /[^)]/,
                    endsWithParent: true,
                    excludeEnd: true
                  }
                ]
              },
              modes.FUNCTION_DISPATCH
            ]
          },
          {
            begin: regex.lookahead(/@/),
            end: "[{;]",
            relevance: 0,
            illegal: /:/,
            // break on Less variables @var: ...
            contains: [
              {
                className: "keyword",
                begin: AT_PROPERTY_RE
              },
              {
                begin: /\s/,
                endsWithParent: true,
                excludeEnd: true,
                relevance: 0,
                keywords: {
                  $pattern: /[a-z-]+/,
                  keyword: AT_MODIFIERS,
                  attribute: MEDIA_FEATURES.join(" ")
                },
                contains: [
                  {
                    begin: /[a-z-]+(?=:)/,
                    className: "attribute"
                  },
                  ...STRINGS,
                  modes.CSS_NUMBER_MODE
                ]
              }
            ]
          },
          {
            className: "selector-tag",
            begin: "\\b(" + TAGS.join("|") + ")\\b"
          }
        ]
      };
    }
    module.exports = css;
  }
});

// node_modules/highlight.js/lib/languages/markdown.js
var require_markdown = __commonJS({
  "node_modules/highlight.js/lib/languages/markdown.js"(exports, module) {
    function markdown(hljs) {
      const regex = hljs.regex;
      const INLINE_HTML = {
        begin: /<\/?[A-Za-z_]/,
        end: ">",
        subLanguage: "xml",
        relevance: 0
      };
      const HORIZONTAL_RULE = {
        begin: "^[-\\*]{3,}",
        end: "$"
      };
      const CODE = {
        className: "code",
        variants: [
          // TODO: fix to allow these to work with sublanguage also
          { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
          { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
          // needed to allow markdown as a sublanguage to work
          {
            begin: "```",
            end: "```+[ ]*$"
          },
          {
            begin: "~~~",
            end: "~~~+[ ]*$"
          },
          { begin: "`.+?`" },
          {
            begin: "(?=^( {4}|\\t))",
            // use contains to gobble up multiple lines to allow the block to be whatever size
            // but only have a single open/close tag vs one per line
            contains: [
              {
                begin: "^( {4}|\\t)",
                end: "(\\n)$"
              }
            ],
            relevance: 0
          }
        ]
      };
      const LIST = {
        className: "bullet",
        begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
        end: "\\s+",
        excludeEnd: true
      };
      const LINK_REFERENCE = {
        begin: /^\[[^\n]+\]:/,
        returnBegin: true,
        contains: [
          {
            className: "symbol",
            begin: /\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "link",
            begin: /:\s*/,
            end: /$/,
            excludeBegin: true
          }
        ]
      };
      const URL_SCHEME = /[A-Za-z][A-Za-z0-9+.-]*/;
      const LINK = {
        variants: [
          // too much like nested array access in so many languages
          // to have any real relevance
          {
            begin: /\[.+?\]\[.*?\]/,
            relevance: 0
          },
          // popular internet URLs
          {
            begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
            relevance: 2
          },
          {
            begin: regex.concat(/\[.+?\]\(/, URL_SCHEME, /:\/\/.*?\)/),
            relevance: 2
          },
          // relative urls
          {
            begin: /\[.+?\]\([./?&#].*?\)/,
            relevance: 1
          },
          // whatever else, lower relevance (might not be a link at all)
          {
            begin: /\[.*?\]\(.*?\)/,
            relevance: 0
          }
        ],
        returnBegin: true,
        contains: [
          {
            // empty strings for alt or link text
            match: /\[(?=\])/
          },
          {
            className: "string",
            relevance: 0,
            begin: "\\[",
            end: "\\]",
            excludeBegin: true,
            returnEnd: true
          },
          {
            className: "link",
            relevance: 0,
            begin: "\\]\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "symbol",
            relevance: 0,
            begin: "\\]\\[",
            end: "\\]",
            excludeBegin: true,
            excludeEnd: true
          }
        ]
      };
      const BOLD = {
        className: "strong",
        contains: [],
        // defined later
        variants: [
          {
            begin: /_{2}(?!\s)/,
            end: /_{2}/
          },
          {
            begin: /\*{2}(?!\s)/,
            end: /\*{2}/
          }
        ]
      };
      const ITALIC = {
        className: "emphasis",
        contains: [],
        // defined later
        variants: [
          {
            begin: /\*(?![*\s])/,
            end: /\*/
          },
          {
            begin: /_(?![_\s])/,
            end: /_/,
            relevance: 0
          }
        ]
      };
      const BOLD_WITHOUT_ITALIC = hljs.inherit(BOLD, { contains: [] });
      const ITALIC_WITHOUT_BOLD = hljs.inherit(ITALIC, { contains: [] });
      BOLD.contains.push(ITALIC_WITHOUT_BOLD);
      ITALIC.contains.push(BOLD_WITHOUT_ITALIC);
      let CONTAINABLE = [
        INLINE_HTML,
        LINK
      ];
      [
        BOLD,
        ITALIC,
        BOLD_WITHOUT_ITALIC,
        ITALIC_WITHOUT_BOLD
      ].forEach((m) => {
        m.contains = m.contains.concat(CONTAINABLE);
      });
      CONTAINABLE = CONTAINABLE.concat(BOLD, ITALIC);
      const HEADER = {
        className: "section",
        variants: [
          {
            begin: "^#{1,6}",
            end: "$",
            contains: CONTAINABLE
          },
          {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [
              { begin: "^[=-]*$" },
              {
                begin: "^",
                end: "\\n",
                contains: CONTAINABLE
              }
            ]
          }
        ]
      };
      const BLOCKQUOTE = {
        className: "quote",
        begin: "^>\\s+",
        contains: CONTAINABLE,
        end: "$"
      };
      const ENTITY = {
        //https://spec.commonmark.org/0.31.2/#entity-references
        scope: "literal",
        match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
      };
      return {
        name: "Markdown",
        aliases: [
          "md",
          "mkdown",
          "mkd"
        ],
        contains: [
          HEADER,
          INLINE_HTML,
          LIST,
          BOLD,
          ITALIC,
          BLOCKQUOTE,
          CODE,
          HORIZONTAL_RULE,
          LINK,
          LINK_REFERENCE,
          ENTITY
        ]
      };
    }
    module.exports = markdown;
  }
});

// node_modules/highlight.js/lib/languages/diff.js
var require_diff = __commonJS({
  "node_modules/highlight.js/lib/languages/diff.js"(exports, module) {
    function diff(hljs) {
      const regex = hljs.regex;
      return {
        name: "Diff",
        aliases: ["patch"],
        contains: [
          {
            className: "meta",
            relevance: 10,
            match: regex.either(
              /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
              /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
              /^--- +\d+,\d+ +----$/
            )
          },
          {
            className: "comment",
            variants: [
              {
                begin: regex.either(
                  /Index: /,
                  /^index/,
                  /={3,}/,
                  /^-{3}/,
                  /^\*{3} /,
                  /^\+{3}/,
                  /^diff --git/
                ),
                end: /$/
              },
              { match: /^\*{15}$/ }
            ]
          },
          {
            className: "addition",
            begin: /^\+/,
            end: /$/
          },
          {
            className: "deletion",
            begin: /^-/,
            end: /$/
          },
          {
            className: "addition",
            begin: /^!/,
            end: /$/
          }
        ]
      };
    }
    module.exports = diff;
  }
});

// node_modules/highlight.js/lib/languages/ruby.js
var require_ruby = __commonJS({
  "node_modules/highlight.js/lib/languages/ruby.js"(exports, module) {
    function ruby(hljs) {
      const regex = hljs.regex;
      const RUBY_METHOD_RE = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)";
      const CLASS_NAME_RE = regex.either(
        /\b([A-Z]+[a-z0-9]+)+/,
        // ends in caps
        /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
      );
      const CLASS_NAME_WITH_NAMESPACE_RE = regex.concat(CLASS_NAME_RE, /(::\w+)*/);
      const PSEUDO_KWS = [
        "include",
        "extend",
        "prepend",
        "public",
        "private",
        "protected",
        "raise",
        "throw"
      ];
      const RUBY_KEYWORDS = {
        "variable.constant": [
          "__FILE__",
          "__LINE__",
          "__ENCODING__"
        ],
        "variable.language": [
          "self",
          "super"
        ],
        keyword: [
          "alias",
          "and",
          "begin",
          "BEGIN",
          "break",
          "case",
          "class",
          "defined",
          "do",
          "else",
          "elsif",
          "end",
          "END",
          "ensure",
          "for",
          "if",
          "in",
          "module",
          "next",
          "not",
          "or",
          "redo",
          "require",
          "rescue",
          "retry",
          "return",
          "then",
          "undef",
          "unless",
          "until",
          "when",
          "while",
          "yield",
          ...PSEUDO_KWS
        ],
        built_in: [
          "proc",
          "lambda",
          "attr_accessor",
          "attr_reader",
          "attr_writer",
          "define_method",
          "private_constant",
          "module_function"
        ],
        literal: [
          "true",
          "false",
          "nil"
        ]
      };
      const YARDOCTAG = {
        className: "doctag",
        begin: "@[A-Za-z]+"
      };
      const IRB_OBJECT = {
        begin: "#<",
        end: ">"
      };
      const COMMENT_MODES = [
        hljs.COMMENT(
          "#",
          "$",
          { contains: [YARDOCTAG] }
        ),
        hljs.COMMENT(
          "^=begin",
          "^=end",
          {
            contains: [YARDOCTAG],
            relevance: 10
          }
        ),
        hljs.COMMENT("^__END__", hljs.MATCH_NOTHING_RE)
      ];
      const SUBST = {
        className: "subst",
        begin: /#\{/,
        end: /\}/,
        keywords: RUBY_KEYWORDS
      };
      const STRING = {
        className: "string",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        variants: [
          {
            begin: /'/,
            end: /'/
          },
          {
            begin: /"/,
            end: /"/
          },
          {
            begin: /`/,
            end: /`/
          },
          {
            begin: /%[qQwWx]?\(/,
            end: /\)/
          },
          {
            begin: /%[qQwWx]?\[/,
            end: /\]/
          },
          {
            begin: /%[qQwWx]?\{/,
            end: /\}/
          },
          {
            begin: /%[qQwWx]?</,
            end: />/
          },
          {
            begin: /%[qQwWx]?\//,
            end: /\//
          },
          {
            begin: /%[qQwWx]?%/,
            end: /%/
          },
          {
            begin: /%[qQwWx]?-/,
            end: /-/
          },
          {
            begin: /%[qQwWx]?\|/,
            end: /\|/
          },
          // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
          // where ? is the last character of a preceding identifier, as in: `func?4`
          { begin: /\B\?(\\\d{1,3})/ },
          { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
          { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
          { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
          { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
          { begin: /\B\?\\?\S/ },
          // heredocs
          {
            // this guard makes sure that we have an entire heredoc and not a false
            // positive (auto-detect, etc.)
            begin: regex.concat(
              /<<[-~]?'?/,
              regex.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
            ),
            contains: [
              hljs.END_SAME_AS_BEGIN({
                begin: /(\w+)/,
                end: /(\w+)/,
                contains: [
                  hljs.BACKSLASH_ESCAPE,
                  SUBST
                ]
              })
            ]
          }
        ]
      };
      const decimal = "[1-9](_?[0-9])*|0";
      const digits = "[0-9](_?[0-9])*";
      const NUMBER = {
        className: "number",
        relevance: 0,
        variants: [
          // decimal integer/float, optionally exponential or rational, optionally imaginary
          { begin: `\\b(${decimal})(\\.(${digits}))?([eE][+-]?(${digits})|r)?i?\\b` },
          // explicit decimal/binary/octal/hexadecimal integer,
          // optionally rational and/or imaginary
          { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
          // 0-prefixed implicit octal integer, optionally rational and/or imaginary
          { begin: "\\b0(_?[0-7])+r?i?\\b" }
        ]
      };
      const PARAMS = {
        variants: [
          {
            match: /\(\)/
          },
          {
            className: "params",
            begin: /\(/,
            end: /(?=\))/,
            excludeBegin: true,
            endsParent: true,
            keywords: RUBY_KEYWORDS
          }
        ]
      };
      const INCLUDE_EXTEND = {
        match: [
          /(include|extend)\s+/,
          CLASS_NAME_WITH_NAMESPACE_RE
        ],
        scope: {
          2: "title.class"
        },
        keywords: RUBY_KEYWORDS
      };
      const CLASS_DEFINITION = {
        variants: [
          {
            match: [
              /class\s+/,
              CLASS_NAME_WITH_NAMESPACE_RE,
              /\s+<\s+/,
              CLASS_NAME_WITH_NAMESPACE_RE
            ]
          },
          {
            match: [
              /\b(class|module)\s+/,
              CLASS_NAME_WITH_NAMESPACE_RE
            ]
          }
        ],
        scope: {
          2: "title.class",
          4: "title.class.inherited"
        },
        keywords: RUBY_KEYWORDS
      };
      const UPPER_CASE_CONSTANT = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      const METHOD_DEFINITION = {
        match: [
          /def/,
          /\s+/,
          RUBY_METHOD_RE
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          PARAMS
        ]
      };
      const OBJECT_CREATION = {
        relevance: 0,
        match: [
          CLASS_NAME_WITH_NAMESPACE_RE,
          /\.new[. (]/
        ],
        scope: {
          1: "title.class"
        }
      };
      const CLASS_REFERENCE = {
        relevance: 0,
        match: CLASS_NAME_RE,
        scope: "title.class"
      };
      const RUBY_DEFAULT_CONTAINS = [
        STRING,
        CLASS_DEFINITION,
        INCLUDE_EXTEND,
        OBJECT_CREATION,
        UPPER_CASE_CONSTANT,
        CLASS_REFERENCE,
        METHOD_DEFINITION,
        {
          // swallow namespace qualifiers before symbols
          begin: hljs.IDENT_RE + "::"
        },
        {
          className: "symbol",
          begin: hljs.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
          relevance: 0
        },
        {
          className: "symbol",
          begin: ":(?!\\s)",
          contains: [
            STRING,
            { begin: RUBY_METHOD_RE }
          ],
          relevance: 0
        },
        NUMBER,
        {
          // negative-look forward attempts to prevent false matches like:
          // @ident@ or $ident$ that might indicate this is not ruby at all
          className: "variable",
          begin: `(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])`
        },
        {
          className: "params",
          begin: /\|(?!=)/,
          end: /\|/,
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0,
          // this could be a lot of things (in other languages) other than params
          keywords: RUBY_KEYWORDS
        },
        {
          // regexp container
          begin: "(" + hljs.RE_STARTERS_RE + "|unless)\\s*",
          keywords: "unless",
          contains: [
            {
              className: "regexp",
              contains: [
                hljs.BACKSLASH_ESCAPE,
                SUBST
              ],
              illegal: /\n/,
              variants: [
                {
                  begin: "/",
                  end: "/[a-z]*"
                },
                {
                  begin: /%r\{/,
                  end: /\}[a-z]*/
                },
                {
                  begin: "%r\\(",
                  end: "\\)[a-z]*"
                },
                {
                  begin: "%r!",
                  end: "![a-z]*"
                },
                {
                  begin: "%r\\[",
                  end: "\\][a-z]*"
                }
              ]
            }
          ].concat(IRB_OBJECT, COMMENT_MODES),
          relevance: 0
        }
      ].concat(IRB_OBJECT, COMMENT_MODES);
      SUBST.contains = RUBY_DEFAULT_CONTAINS;
      PARAMS.contains = RUBY_DEFAULT_CONTAINS;
      const SIMPLE_PROMPT = "[>?]>";
      const DEFAULT_PROMPT = "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]";
      const RVM_PROMPT = "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>";
      const IRB_DEFAULT = [
        {
          begin: /^\s*=>/,
          starts: {
            end: "$",
            contains: RUBY_DEFAULT_CONTAINS
          }
        },
        {
          className: "meta.prompt",
          begin: "^(" + SIMPLE_PROMPT + "|" + DEFAULT_PROMPT + "|" + RVM_PROMPT + ")(?=[ ])",
          starts: {
            end: "$",
            keywords: RUBY_KEYWORDS,
            contains: RUBY_DEFAULT_CONTAINS
          }
        }
      ];
      COMMENT_MODES.unshift(IRB_OBJECT);
      return {
        name: "Ruby",
        aliases: [
          "rb",
          "gemspec",
          "podspec",
          "thor",
          "irb"
        ],
        keywords: RUBY_KEYWORDS,
        illegal: /\/\*/,
        contains: [hljs.SHEBANG({ binary: "ruby" })].concat(IRB_DEFAULT).concat(COMMENT_MODES).concat(RUBY_DEFAULT_CONTAINS)
      };
    }
    module.exports = ruby;
  }
});

// node_modules/highlight.js/lib/languages/go.js
var require_go = __commonJS({
  "node_modules/highlight.js/lib/languages/go.js"(exports, module) {
    function go(hljs) {
      const LITERALS = [
        "true",
        "false",
        "iota",
        "nil"
      ];
      const BUILT_INS = [
        "append",
        "cap",
        "close",
        "complex",
        "copy",
        "imag",
        "len",
        "make",
        "new",
        "panic",
        "print",
        "println",
        "real",
        "recover",
        "delete"
      ];
      const TYPES = [
        "bool",
        "byte",
        "complex64",
        "complex128",
        "error",
        "float32",
        "float64",
        "int8",
        "int16",
        "int32",
        "int64",
        "string",
        "uint8",
        "uint16",
        "uint32",
        "uint64",
        "int",
        "uint",
        "uintptr",
        "rune"
      ];
      const KWS = [
        "break",
        "case",
        "chan",
        "const",
        "continue",
        "default",
        "defer",
        "else",
        "fallthrough",
        "for",
        "func",
        "go",
        "goto",
        "if",
        "import",
        "interface",
        "map",
        "package",
        "range",
        "return",
        "select",
        "struct",
        "switch",
        "type",
        "var"
      ];
      const KEYWORDS = {
        keyword: KWS,
        type: TYPES,
        literal: LITERALS,
        built_in: BUILT_INS
      };
      return {
        name: "Go",
        aliases: ["golang"],
        keywords: KEYWORDS,
        illegal: "</",
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            className: "string",
            variants: [
              hljs.QUOTE_STRING_MODE,
              hljs.APOS_STRING_MODE,
              {
                begin: "`",
                end: "`"
              }
            ]
          },
          {
            className: "number",
            variants: [
              {
                match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
                // hex without a present digit before . (making a digit afterwards required)
                relevance: 0
              },
              {
                match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
                // hex with a present digit before . (making a digit afterwards optional)
                relevance: 0
              },
              {
                match: /-?\b0[oO](_?[0-7])*i?/,
                // leading 0o octal
                relevance: 0
              },
              {
                match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
                // decimal without a present digit before . (making a digit afterwards required)
                relevance: 0
              },
              {
                match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
                // decimal with a present digit before . (making a digit afterwards optional)
                relevance: 0
              }
            ]
          },
          {
            begin: /:=/
            // relevance booster
          },
          {
            className: "function",
            beginKeywords: "func",
            end: "\\s*(\\{|$)",
            excludeEnd: true,
            contains: [
              hljs.TITLE_MODE,
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: KEYWORDS,
                illegal: /["']/
              }
            ]
          }
        ]
      };
    }
    module.exports = go;
  }
});

// node_modules/highlight.js/lib/languages/graphql.js
var require_graphql = __commonJS({
  "node_modules/highlight.js/lib/languages/graphql.js"(exports, module) {
    function graphql(hljs) {
      const regex = hljs.regex;
      const GQL_NAME = /[_A-Za-z][_0-9A-Za-z]*/;
      return {
        name: "GraphQL",
        aliases: ["gql"],
        case_insensitive: true,
        disableAutodetect: false,
        keywords: {
          keyword: [
            "query",
            "mutation",
            "subscription",
            "type",
            "input",
            "schema",
            "directive",
            "interface",
            "union",
            "scalar",
            "fragment",
            "enum",
            "on"
          ],
          literal: [
            "true",
            "false",
            "null"
          ]
        },
        contains: [
          hljs.HASH_COMMENT_MODE,
          hljs.QUOTE_STRING_MODE,
          hljs.NUMBER_MODE,
          {
            scope: "punctuation",
            match: /[.]{3}/,
            relevance: 0
          },
          {
            scope: "punctuation",
            begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
            relevance: 0
          },
          {
            scope: "variable",
            begin: /\$/,
            end: /\W/,
            excludeEnd: true,
            relevance: 0
          },
          {
            scope: "meta",
            match: /@\w+/,
            excludeEnd: true
          },
          {
            scope: "symbol",
            begin: regex.concat(GQL_NAME, regex.lookahead(/\s*:/)),
            relevance: 0
          }
        ],
        illegal: [
          /[;<']/,
          /BEGIN/
        ]
      };
    }
    module.exports = graphql;
  }
});

// node_modules/highlight.js/lib/languages/ini.js
var require_ini = __commonJS({
  "node_modules/highlight.js/lib/languages/ini.js"(exports, module) {
    function ini(hljs) {
      const regex = hljs.regex;
      const NUMBERS = {
        className: "number",
        relevance: 0,
        variants: [
          { begin: /([+-]+)?[\d]+_[\d_]+/ },
          { begin: hljs.NUMBER_RE }
        ]
      };
      const COMMENTS = hljs.COMMENT();
      COMMENTS.variants = [
        {
          begin: /;/,
          end: /$/
        },
        {
          begin: /#/,
          end: /$/
        }
      ];
      const VARIABLES = {
        className: "variable",
        variants: [
          { begin: /\$[\w\d"][\w\d_]*/ },
          { begin: /\$\{(.*?)\}/ }
        ]
      };
      const LITERALS = {
        className: "literal",
        begin: /\bon|off|true|false|yes|no\b/
      };
      const STRINGS = {
        className: "string",
        contains: [hljs.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: "'''",
            end: "'''",
            relevance: 10
          },
          {
            begin: '"""',
            end: '"""',
            relevance: 10
          },
          {
            begin: '"',
            end: '"'
          },
          {
            begin: "'",
            end: "'"
          }
        ]
      };
      const ARRAY = {
        begin: /\[/,
        end: /\]/,
        contains: [
          COMMENTS,
          LITERALS,
          VARIABLES,
          STRINGS,
          NUMBERS,
          "self"
        ],
        relevance: 0
      };
      const BARE_KEY = /[A-Za-z0-9_-]+/;
      const QUOTED_KEY_DOUBLE_QUOTE = /"(\\"|[^"])*"/;
      const QUOTED_KEY_SINGLE_QUOTE = /'[^']*'/;
      const ANY_KEY = regex.either(
        BARE_KEY,
        QUOTED_KEY_DOUBLE_QUOTE,
        QUOTED_KEY_SINGLE_QUOTE
      );
      const DOTTED_KEY = regex.concat(
        ANY_KEY,
        "(\\s*\\.\\s*",
        ANY_KEY,
        ")*",
        regex.lookahead(/\s*=\s*[^#\s]/)
      );
      return {
        name: "TOML, also INI",
        aliases: ["toml"],
        case_insensitive: true,
        illegal: /\S/,
        contains: [
          COMMENTS,
          {
            className: "section",
            begin: /\[+/,
            end: /\]+/
          },
          {
            begin: DOTTED_KEY,
            className: "attr",
            starts: {
              end: /$/,
              contains: [
                COMMENTS,
                ARRAY,
                LITERALS,
                VARIABLES,
                STRINGS,
                NUMBERS
              ]
            }
          }
        ]
      };
    }
    module.exports = ini;
  }
});

// node_modules/highlight.js/lib/languages/java.js
var require_java = __commonJS({
  "node_modules/highlight.js/lib/languages/java.js"(exports, module) {
    var decimalDigits = "[0-9](_*[0-9])*";
    var frac = `\\.(${decimalDigits})`;
    var hexDigits = "[0-9a-fA-F](_*[0-9a-fA-F])*";
    var NUMERIC = {
      className: "number",
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${frac})[fFdD]?\\b` },
        { begin: `\\b(${decimalDigits})[fFdD]\\b` },
        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))[pP][+-]?(${decimalDigits})[fFdD]?\\b` },
        // DecimalIntegerLiteral
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        // HexIntegerLiteral
        { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },
        // OctalIntegerLiteral
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        // BinaryIntegerLiteral
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function recurRegex(re, substitution, depth) {
      if (depth === -1) return "";
      return re.replace(substitution, (_) => {
        return recurRegex(re, substitution, depth - 1);
      });
    }
    function java(hljs) {
      const regex = hljs.regex;
      const JAVA_IDENT_RE = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*";
      const GENERIC_IDENT_RE = JAVA_IDENT_RE + recurRegex("(?:<" + JAVA_IDENT_RE + "~~~(?:\\s*,\\s*" + JAVA_IDENT_RE + "~~~)*>)?", /~~~/g, 2);
      const MAIN_KEYWORDS = [
        "synchronized",
        "abstract",
        "private",
        "var",
        "static",
        "if",
        "const ",
        "for",
        "while",
        "strictfp",
        "finally",
        "protected",
        "import",
        "native",
        "final",
        "void",
        "enum",
        "else",
        "break",
        "transient",
        "catch",
        "instanceof",
        "volatile",
        "case",
        "assert",
        "package",
        "default",
        "public",
        "try",
        "switch",
        "continue",
        "throws",
        "protected",
        "public",
        "private",
        "module",
        "requires",
        "exports",
        "do",
        "sealed",
        "yield",
        "permits",
        "goto",
        "when"
      ];
      const BUILT_INS = [
        "super",
        "this"
      ];
      const LITERALS = [
        "false",
        "true",
        "null"
      ];
      const TYPES = [
        "char",
        "boolean",
        "long",
        "float",
        "int",
        "byte",
        "short",
        "double"
      ];
      const KEYWORDS = {
        keyword: MAIN_KEYWORDS,
        literal: LITERALS,
        type: TYPES,
        built_in: BUILT_INS
      };
      const ANNOTATION = {
        className: "meta",
        begin: "@" + JAVA_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: ["self"]
            // allow nested () inside our annotation
          }
        ]
      };
      const PARAMS = {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS,
        relevance: 0,
        contains: [hljs.C_BLOCK_COMMENT_MODE],
        endsParent: true
      };
      return {
        name: "Java",
        aliases: ["jsp"],
        keywords: KEYWORDS,
        illegal: /<\/|#/,
        contains: [
          hljs.COMMENT(
            "/\\*\\*",
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  // eat up @'s in emails to prevent them to be recognized as doctags
                  begin: /\w+@/,
                  relevance: 0
                },
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                }
              ]
            }
          ),
          // relevance boost
          {
            begin: /import java\.[a-z]+\./,
            keywords: "import",
            relevance: 2
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            begin: /"""/,
            end: /"""/,
            className: "string",
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          {
            match: [
              /\b(?:class|interface|enum|extends|implements|new)/,
              /\s+/,
              JAVA_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            // Exceptions for hyphenated keywords
            match: /non-sealed/,
            scope: "keyword"
          },
          {
            begin: [
              regex.concat(/(?!else)/, JAVA_IDENT_RE),
              /\s+/,
              JAVA_IDENT_RE,
              /\s+/,
              /=(?!=)/
            ],
            className: {
              1: "type",
              3: "variable",
              5: "operator"
            }
          },
          {
            begin: [
              /record/,
              /\s+/,
              JAVA_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "title.class"
            },
            contains: [
              PARAMS,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: "new throw return else",
            relevance: 0
          },
          {
            begin: [
              "(?:" + GENERIC_IDENT_RE + "\\s+)",
              hljs.UNDERSCORE_IDENT_RE,
              /\s*(?=\()/
            ],
            className: { 2: "title.function" },
            keywords: KEYWORDS,
            contains: [
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  ANNOTATION,
                  hljs.APOS_STRING_MODE,
                  hljs.QUOTE_STRING_MODE,
                  NUMERIC,
                  hljs.C_BLOCK_COMMENT_MODE
                ]
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          NUMERIC,
          ANNOTATION
        ]
      };
    }
    module.exports = java;
  }
});

// node_modules/highlight.js/lib/languages/javascript.js
var require_javascript = __commonJS({
  "node_modules/highlight.js/lib/languages/javascript.js"(exports, module) {
    var IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
    var KEYWORDS = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      // It's reached stage 3, which is "recommended for implementation":
      "using"
    ];
    var LITERALS = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ];
    var TYPES = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ];
    var ERROR_TYPES = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ];
    var BUILT_IN_GLOBALS = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ];
    var BUILT_IN_VARIABLES = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ];
    var BUILT_INS = [].concat(
      BUILT_IN_GLOBALS,
      TYPES,
      ERROR_TYPES
    );
    function javascript(hljs) {
      const regex = hljs.regex;
      const hasClosingTag = (match, { after }) => {
        const tag = "</" + match[0].slice(1);
        const pos = match.input.indexOf(tag, after);
        return pos !== -1;
      };
      const IDENT_RE$1 = IDENT_RE;
      const FRAGMENT = {
        begin: "<>",
        end: "</>"
      };
      const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
      const XML_TAG = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (match, response) => {
          const afterMatchIndex = match[0].length + match.index;
          const nextChar = match.input[afterMatchIndex];
          if (
            // HTML should not include another raw `<` inside a tag
            // nested type?
            // `<Array<Array<number>>`, etc.
            nextChar === "<" || // the , gives away that this is not HTML
            // `<T, A extends keyof T, V>`
            nextChar === ","
          ) {
            response.ignoreMatch();
            return;
          }
          if (nextChar === ">") {
            if (!hasClosingTag(match, { after: afterMatchIndex })) {
              response.ignoreMatch();
            }
          }
          let m;
          const afterMatch = match.input.substring(afterMatchIndex);
          if (m = afterMatch.match(/^\s*=/)) {
            response.ignoreMatch();
            return;
          }
          if (m = afterMatch.match(/^\s+extends\s+/)) {
            if (m.index === 0) {
              response.ignoreMatch();
              return;
            }
          }
        }
      };
      const KEYWORDS$1 = {
        $pattern: IDENT_RE,
        keyword: KEYWORDS,
        literal: LITERALS,
        built_in: BUILT_INS,
        "variable.language": BUILT_IN_VARIABLES
      };
      const decimalDigits = "[0-9](_?[0-9])*";
      const frac = `\\.(${decimalDigits})`;
      const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
      const NUMBER = {
        className: "number",
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
          { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
          // DecimalBigIntegerLiteral
          { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      };
      const SUBST = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: KEYWORDS$1,
        contains: []
        // defined later
      };
      const HTML_TEMPLATE = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "xml"
        }
      };
      const CSS_TEMPLATE = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "css"
        }
      };
      const GRAPHQL_TEMPLATE = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "graphql"
        }
      };
      const TEMPLATE_STRING = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ]
      };
      const JSDOC_COMMENT = hljs.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: true,
                  excludeBegin: true,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
                  endsParent: true,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      );
      const COMMENT = {
        className: "comment",
        variants: [
          JSDOC_COMMENT,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.C_LINE_COMMENT_MODE
        ]
      };
      const SUBST_INTERNALS = [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        GRAPHQL_TEMPLATE,
        TEMPLATE_STRING,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        NUMBER
        // This is intentional:
        // See https://github.com/highlightjs/highlight.js/issues/3288
        // hljs.REGEXP_MODE
      ];
      SUBST.contains = SUBST_INTERNALS.concat({
        // we need to pair up {} inside our subst to prevent
        // it from ending too early by matching another }
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS$1,
        contains: [
          "self"
        ].concat(SUBST_INTERNALS)
      });
      const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
      const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
        // eat recursive parens in sub expressions
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: KEYWORDS$1,
          contains: ["self"].concat(SUBST_AND_COMMENTS)
        }
      ]);
      const PARAMS = {
        className: "params",
        // convert this to negative lookbehind in v12
        begin: /(\s*)\(/,
        // to match the parms with
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS$1,
        contains: PARAMS_CONTAINS
      };
      const CLASS_OR_EXTENDS = {
        variants: [
          // class Car extends vehicle
          {
            match: [
              /class/,
              /\s+/,
              IDENT_RE$1,
              /\s+/,
              /extends/,
              /\s+/,
              regex.concat(IDENT_RE$1, "(", regex.concat(/\./, IDENT_RE$1), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          // class Car
          {
            match: [
              /class/,
              /\s+/,
              IDENT_RE$1
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      };
      const CLASS_REFERENCE = {
        relevance: 0,
        match: regex.either(
          // Hard coded exceptions
          /\bJSON/,
          // Float32Array, OutT
          /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
          // CSSFactory, CSSFactoryT
          /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
          // FPs, FPsT
          /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
          // P
          // single letters are not highlighted
          // BLAH
          // this will be flagged as a UPPER_CASE_CONSTANT instead
        ),
        className: "title.class",
        keywords: {
          _: [
            // se we still get relevance credit for JS library classes
            ...TYPES,
            ...ERROR_TYPES
          ]
        }
      };
      const USE_STRICT = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      };
      const FUNCTION_DEFINITION = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              IDENT_RE$1,
              /(?=\s*\()/
            ]
          },
          // anonymous function
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [PARAMS],
        illegal: /%/
      };
      const UPPER_CASE_CONSTANT = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function noneOf(list) {
        return regex.concat("(?!", list.join("|"), ")");
      }
      const FUNCTION_CALL = {
        match: regex.concat(
          /\b/,
          noneOf([
            ...BUILT_IN_GLOBALS,
            "super",
            "import"
          ].map((x) => `${x}\\s*\\(`)),
          IDENT_RE$1,
          regex.lookahead(/\s*\(/)
        ),
        className: "title.function",
        relevance: 0
      };
      const PROPERTY_ACCESS = {
        begin: regex.concat(/\./, regex.lookahead(
          regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)
        )),
        end: IDENT_RE$1,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      };
      const GETTER_OR_SETTER = {
        match: [
          /get|set/,
          /\s+/,
          IDENT_RE$1,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            // eat to avoid empty params
            begin: /\(\)/
          },
          PARAMS
        ]
      };
      const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
      const FUNCTION_VARIABLE = {
        match: [
          /const|var|let/,
          /\s+/,
          IDENT_RE$1,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          // async is optional
          regex.lookahead(FUNC_LEAD_IN_RE)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          PARAMS
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: KEYWORDS$1,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
        illegal: /#(?![$_A-z])/,
        contains: [
          hljs.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          USE_STRICT,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          HTML_TEMPLATE,
          CSS_TEMPLATE,
          GRAPHQL_TEMPLATE,
          TEMPLATE_STRING,
          COMMENT,
          // Skip numbers when they are part of a variable name
          { match: /\$\d+/ },
          NUMBER,
          CLASS_REFERENCE,
          {
            scope: "attr",
            match: IDENT_RE$1 + regex.lookahead(":"),
            relevance: 0
          },
          FUNCTION_VARIABLE,
          {
            // "value" container
            begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              COMMENT,
              hljs.REGEXP_MODE,
              {
                className: "function",
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: FUNC_LEAD_IN_RE,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: hljs.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: KEYWORDS$1,
                        contains: PARAMS_CONTAINS
                      }
                    ]
                  }
                ]
              },
              {
                // could be a comma delimited list of params to a function call
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                // JSX
                variants: [
                  { begin: FRAGMENT.begin, end: FRAGMENT.end },
                  { match: XML_SELF_CLOSING },
                  {
                    begin: XML_TAG.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    "on:begin": XML_TAG.isTrulyOpeningTag,
                    end: XML_TAG.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: XML_TAG.begin,
                    end: XML_TAG.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          FUNCTION_DEFINITION,
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            // end parens
            returnBegin: true,
            label: "func.def",
            contains: [
              PARAMS,
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })
            ]
          },
          // catch ... so it won't trigger the property rule below
          {
            match: /\.\.\./,
            relevance: 0
          },
          PROPERTY_ACCESS,
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            match: "\\$" + IDENT_RE$1,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [PARAMS]
          },
          FUNCTION_CALL,
          UPPER_CASE_CONSTANT,
          CLASS_OR_EXTENDS,
          GETTER_OR_SETTER,
          {
            match: /\$[(.]/
            // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }
    module.exports = javascript;
  }
});

// node_modules/highlight.js/lib/languages/json.js
var require_json = __commonJS({
  "node_modules/highlight.js/lib/languages/json.js"(exports, module) {
    function json(hljs) {
      const ATTRIBUTE = {
        className: "attr",
        begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
        relevance: 1.01
      };
      const PUNCTUATION = {
        match: /[{}[\],:]/,
        className: "punctuation",
        relevance: 0
      };
      const LITERALS = [
        "true",
        "false",
        "null"
      ];
      const LITERALS_MODE = {
        scope: "literal",
        beginKeywords: LITERALS.join(" ")
      };
      return {
        name: "JSON",
        aliases: ["jsonc"],
        keywords: {
          literal: LITERALS
        },
        contains: [
          ATTRIBUTE,
          PUNCTUATION,
          hljs.QUOTE_STRING_MODE,
          LITERALS_MODE,
          hljs.C_NUMBER_MODE,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ],
        illegal: "\\S"
      };
    }
    module.exports = json;
  }
});

// node_modules/highlight.js/lib/languages/kotlin.js
var require_kotlin = __commonJS({
  "node_modules/highlight.js/lib/languages/kotlin.js"(exports, module) {
    var decimalDigits = "[0-9](_*[0-9])*";
    var frac = `\\.(${decimalDigits})`;
    var hexDigits = "[0-9a-fA-F](_*[0-9a-fA-F])*";
    var NUMERIC = {
      className: "number",
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${frac})[fFdD]?\\b` },
        { begin: `\\b(${decimalDigits})[fFdD]\\b` },
        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))[pP][+-]?(${decimalDigits})[fFdD]?\\b` },
        // DecimalIntegerLiteral
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        // HexIntegerLiteral
        { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },
        // OctalIntegerLiteral
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        // BinaryIntegerLiteral
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function kotlin(hljs) {
      const KEYWORDS = {
        keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
        built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
        literal: "true false null"
      };
      const KEYWORDS_WITH_LABEL = {
        className: "keyword",
        begin: /\b(break|continue|return|this)\b/,
        starts: { contains: [
          {
            className: "symbol",
            begin: /@\w+/
          }
        ] }
      };
      const LABEL = {
        className: "symbol",
        begin: hljs.UNDERSCORE_IDENT_RE + "@"
      };
      const SUBST = {
        className: "subst",
        begin: /\$\{/,
        end: /\}/,
        contains: [hljs.C_NUMBER_MODE]
      };
      const VARIABLE = {
        className: "variable",
        begin: "\\$" + hljs.UNDERSCORE_IDENT_RE
      };
      const STRING = {
        className: "string",
        variants: [
          {
            begin: '"""',
            end: '"""(?=[^"])',
            contains: [
              VARIABLE,
              SUBST
            ]
          },
          // Can't use built-in modes easily, as we want to use STRING in the meta
          // context as 'meta-string' and there's no syntax to remove explicitly set
          // classNames in built-in modes.
          {
            begin: "'",
            end: "'",
            illegal: /\n/,
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          {
            begin: '"',
            end: '"',
            illegal: /\n/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              VARIABLE,
              SUBST
            ]
          }
        ]
      };
      SUBST.contains.push(STRING);
      const ANNOTATION_USE_SITE = {
        className: "meta",
        begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + hljs.UNDERSCORE_IDENT_RE + ")?"
      };
      const ANNOTATION = {
        className: "meta",
        begin: "@" + hljs.UNDERSCORE_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              hljs.inherit(STRING, { className: "string" }),
              "self"
            ]
          }
        ]
      };
      const KOTLIN_NUMBER_MODE = NUMERIC;
      const KOTLIN_NESTED_COMMENT = hljs.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [hljs.C_BLOCK_COMMENT_MODE] }
      );
      const KOTLIN_PAREN_TYPE = { variants: [
        {
          className: "type",
          begin: hljs.UNDERSCORE_IDENT_RE
        },
        {
          begin: /\(/,
          end: /\)/,
          contains: []
          // defined later
        }
      ] };
      const KOTLIN_PAREN_TYPE2 = KOTLIN_PAREN_TYPE;
      KOTLIN_PAREN_TYPE2.variants[1].contains = [KOTLIN_PAREN_TYPE];
      KOTLIN_PAREN_TYPE.variants[1].contains = [KOTLIN_PAREN_TYPE2];
      return {
        name: "Kotlin",
        aliases: [
          "kt",
          "kts"
        ],
        keywords: KEYWORDS,
        contains: [
          hljs.COMMENT(
            "/\\*\\*",
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                }
              ]
            }
          ),
          hljs.C_LINE_COMMENT_MODE,
          KOTLIN_NESTED_COMMENT,
          KEYWORDS_WITH_LABEL,
          LABEL,
          ANNOTATION_USE_SITE,
          ANNOTATION,
          {
            className: "function",
            beginKeywords: "fun",
            end: "[(]|$",
            returnBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS,
            relevance: 5,
            contains: [
              {
                begin: hljs.UNDERSCORE_IDENT_RE + "\\s*\\(",
                returnBegin: true,
                relevance: 0,
                contains: [hljs.UNDERSCORE_TITLE_MODE]
              },
              {
                className: "type",
                begin: /</,
                end: />/,
                keywords: "reified",
                relevance: 0
              },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  {
                    begin: /:/,
                    end: /[=,\/]/,
                    endsWithParent: true,
                    contains: [
                      KOTLIN_PAREN_TYPE,
                      hljs.C_LINE_COMMENT_MODE,
                      KOTLIN_NESTED_COMMENT
                    ],
                    relevance: 0
                  },
                  hljs.C_LINE_COMMENT_MODE,
                  KOTLIN_NESTED_COMMENT,
                  ANNOTATION_USE_SITE,
                  ANNOTATION,
                  STRING,
                  hljs.C_NUMBER_MODE
                ]
              },
              KOTLIN_NESTED_COMMENT
            ]
          },
          {
            begin: [
              /class|interface|trait/,
              /\s+/,
              hljs.UNDERSCORE_IDENT_RE
            ],
            beginScope: {
              3: "title.class"
            },
            keywords: "class interface trait",
            end: /[:\{(]|$/,
            excludeEnd: true,
            illegal: "extends implements",
            contains: [
              { beginKeywords: "public protected internal private constructor" },
              hljs.UNDERSCORE_TITLE_MODE,
              {
                className: "type",
                begin: /</,
                end: />/,
                excludeBegin: true,
                excludeEnd: true,
                relevance: 0
              },
              {
                className: "type",
                begin: /[,:]\s*/,
                end: /[<\(,){\s]|$/,
                excludeBegin: true,
                returnEnd: true
              },
              ANNOTATION_USE_SITE,
              ANNOTATION
            ]
          },
          STRING,
          {
            className: "meta",
            begin: "^#!/usr/bin/env",
            end: "$",
            illegal: "\n"
          },
          KOTLIN_NUMBER_MODE
        ]
      };
    }
    module.exports = kotlin;
  }
});

// node_modules/highlight.js/lib/languages/less.js
var require_less = __commonJS({
  "node_modules/highlight.js/lib/languages/less.js"(exports, module) {
    var MODES = (hljs) => {
      return {
        IMPORTANT: {
          scope: "meta",
          begin: "!important"
        },
        BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: {
          scope: "number",
          begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
        },
        FUNCTION_DISPATCH: {
          className: "built_in",
          begin: /[\w-]+(?=\()/
        },
        ATTRIBUTE_SELECTOR_MODE: {
          scope: "selector-attr",
          begin: /\[/,
          end: /\]/,
          illegal: "$",
          contains: [
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE
          ]
        },
        CSS_NUMBER_MODE: {
          scope: "number",
          begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
          relevance: 0
        },
        CSS_VARIABLE: {
          className: "attr",
          begin: /--[A-Za-z_][A-Za-z0-9_-]*/
        }
      };
    };
    var HTML_TAGS = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ];
    var SVG_TAGS = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ];
    var TAGS = [
      ...HTML_TAGS,
      ...SVG_TAGS
    ];
    var MEDIA_FEATURES = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse();
    var PSEUDO_CLASSES = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse();
    var PSEUDO_ELEMENTS = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse();
    var ATTRIBUTES = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    var PSEUDO_SELECTORS = PSEUDO_CLASSES.concat(PSEUDO_ELEMENTS).sort().reverse();
    function less(hljs) {
      const modes = MODES(hljs);
      const PSEUDO_SELECTORS$1 = PSEUDO_SELECTORS;
      const AT_MODIFIERS = "and or not only";
      const IDENT_RE = "[\\w-]+";
      const INTERP_IDENT_RE = "(" + IDENT_RE + "|@\\{" + IDENT_RE + "\\})";
      const RULES = [];
      const VALUE_MODES = [];
      const STRING_MODE = function(c) {
        return {
          // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
          className: "string",
          begin: "~?" + c + ".*?" + c
        };
      };
      const IDENT_MODE = function(name, begin, relevance) {
        return {
          className: name,
          begin,
          relevance
        };
      };
      const AT_KEYWORDS = {
        $pattern: /[a-z-]+/,
        keyword: AT_MODIFIERS,
        attribute: MEDIA_FEATURES.join(" ")
      };
      const PARENS_MODE = {
        // used only to properly balance nested parens inside mixin call, def. arg list
        begin: "\\(",
        end: "\\)",
        contains: VALUE_MODES,
        keywords: AT_KEYWORDS,
        relevance: 0
      };
      VALUE_MODES.push(
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        STRING_MODE("'"),
        STRING_MODE('"'),
        modes.CSS_NUMBER_MODE,
        // fixme: it does not include dot for numbers like .5em :(
        {
          begin: "(url|data-uri)\\(",
          starts: {
            className: "string",
            end: "[\\)\\n]",
            excludeEnd: true
          }
        },
        modes.HEXCOLOR,
        PARENS_MODE,
        IDENT_MODE("variable", "@@?" + IDENT_RE, 10),
        IDENT_MODE("variable", "@\\{" + IDENT_RE + "\\}"),
        IDENT_MODE("built_in", "~?`[^`]*?`"),
        // inline javascript (or whatever host language) *multiline* string
        {
          // @media features (it’s here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
          className: "attribute",
          begin: IDENT_RE + "\\s*:",
          end: ":",
          returnBegin: true,
          excludeEnd: true
        },
        modes.IMPORTANT,
        { beginKeywords: "and not" },
        modes.FUNCTION_DISPATCH
      );
      const VALUE_WITH_RULESETS = VALUE_MODES.concat({
        begin: /\{/,
        end: /\}/,
        contains: RULES
      });
      const MIXIN_GUARD_MODE = {
        beginKeywords: "when",
        endsWithParent: true,
        contains: [{ beginKeywords: "and not" }].concat(VALUE_MODES)
        // using this form to override VALUE’s 'function' match
      };
      const RULE_MODE = {
        begin: INTERP_IDENT_RE + "\\s*:",
        returnBegin: true,
        end: /[;}]/,
        relevance: 0,
        contains: [
          { begin: /-(webkit|moz|ms|o)-/ },
          modes.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b",
            end: /(?=:)/,
            starts: {
              endsWithParent: true,
              illegal: "[<=$]",
              relevance: 0,
              contains: VALUE_MODES
            }
          }
        ]
      };
      const AT_RULE_MODE = {
        className: "keyword",
        begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
        starts: {
          end: "[;{}]",
          keywords: AT_KEYWORDS,
          returnEnd: true,
          contains: VALUE_MODES,
          relevance: 0
        }
      };
      const VAR_RULE_MODE = {
        className: "variable",
        variants: [
          // using more strict pattern for higher relevance to increase chances of Less detection.
          // this is *the only* Less specific statement used in most of the sources, so...
          // (we’ll still often loose to the css-parser unless there's '//' comment,
          // simply because 1 variable just can't beat 99 properties :)
          {
            begin: "@" + IDENT_RE + "\\s*:",
            relevance: 15
          },
          { begin: "@" + IDENT_RE }
        ],
        starts: {
          end: "[;}]",
          returnEnd: true,
          contains: VALUE_WITH_RULESETS
        }
      };
      const SELECTOR_MODE = {
        // first parse unambiguous selectors (i.e. those not starting with tag)
        // then fall into the scary lookahead-discriminator variant.
        // this mode also handles mixin definitions and calls
        variants: [
          {
            begin: "[\\.#:&\\[>]",
            end: "[;{}]"
            // mixin calls end with ';'
          },
          {
            begin: INTERP_IDENT_RE,
            end: /\{/
          }
        ],
        returnBegin: true,
        returnEnd: true,
        illegal: `[<='$"]`,
        relevance: 0,
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          MIXIN_GUARD_MODE,
          IDENT_MODE("keyword", "all\\b"),
          IDENT_MODE("variable", "@\\{" + IDENT_RE + "\\}"),
          // otherwise it’s identified as tag
          {
            begin: "\\b(" + TAGS.join("|") + ")\\b",
            className: "selector-tag"
          },
          modes.CSS_NUMBER_MODE,
          IDENT_MODE("selector-tag", INTERP_IDENT_RE, 0),
          IDENT_MODE("selector-id", "#" + INTERP_IDENT_RE),
          IDENT_MODE("selector-class", "\\." + INTERP_IDENT_RE, 0),
          IDENT_MODE("selector-tag", "&", 0),
          modes.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-pseudo",
            begin: ":(" + PSEUDO_CLASSES.join("|") + ")"
          },
          {
            className: "selector-pseudo",
            begin: ":(:)?(" + PSEUDO_ELEMENTS.join("|") + ")"
          },
          {
            begin: /\(/,
            end: /\)/,
            relevance: 0,
            contains: VALUE_WITH_RULESETS
          },
          // argument list of parametric mixins
          { begin: "!important" },
          // eat !important after mixin call or it will be colored as tag
          modes.FUNCTION_DISPATCH
        ]
      };
      const PSEUDO_SELECTOR_MODE = {
        begin: IDENT_RE + `:(:)?(${PSEUDO_SELECTORS$1.join("|")})`,
        returnBegin: true,
        contains: [SELECTOR_MODE]
      };
      RULES.push(
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        AT_RULE_MODE,
        VAR_RULE_MODE,
        PSEUDO_SELECTOR_MODE,
        RULE_MODE,
        SELECTOR_MODE,
        MIXIN_GUARD_MODE,
        modes.FUNCTION_DISPATCH
      );
      return {
        name: "Less",
        case_insensitive: true,
        illegal: `[=>'/<($"]`,
        contains: RULES
      };
    }
    module.exports = less;
  }
});

// node_modules/highlight.js/lib/languages/lua.js
var require_lua = __commonJS({
  "node_modules/highlight.js/lib/languages/lua.js"(exports, module) {
    function lua(hljs) {
      const OPENING_LONG_BRACKET = "\\[=*\\[";
      const CLOSING_LONG_BRACKET = "\\]=*\\]";
      const LONG_BRACKETS = {
        begin: OPENING_LONG_BRACKET,
        end: CLOSING_LONG_BRACKET,
        contains: ["self"]
      };
      const COMMENTS = [
        hljs.COMMENT("--(?!" + OPENING_LONG_BRACKET + ")", "$"),
        hljs.COMMENT(
          "--" + OPENING_LONG_BRACKET,
          CLOSING_LONG_BRACKET,
          {
            contains: [LONG_BRACKETS],
            relevance: 10
          }
        )
      ];
      return {
        name: "Lua",
        aliases: ["pluto"],
        keywords: {
          $pattern: hljs.UNDERSCORE_IDENT_RE,
          literal: "true false nil",
          keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
          built_in: (
            // Metatags and globals:
            "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
          )
        },
        contains: COMMENTS.concat([
          {
            className: "function",
            beginKeywords: "function",
            end: "\\)",
            contains: [
              hljs.inherit(hljs.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
              {
                className: "params",
                begin: "\\(",
                endsWithParent: true,
                contains: COMMENTS
              }
            ].concat(COMMENTS)
          },
          hljs.C_NUMBER_MODE,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          {
            className: "string",
            begin: OPENING_LONG_BRACKET,
            end: CLOSING_LONG_BRACKET,
            contains: [LONG_BRACKETS],
            relevance: 5
          }
        ])
      };
    }
    module.exports = lua;
  }
});

// node_modules/highlight.js/lib/languages/makefile.js
var require_makefile = __commonJS({
  "node_modules/highlight.js/lib/languages/makefile.js"(exports, module) {
    function makefile(hljs) {
      const VARIABLE = {
        className: "variable",
        variants: [
          {
            begin: "\\$\\(" + hljs.UNDERSCORE_IDENT_RE + "\\)",
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          { begin: /\$[@%<?\^\+\*]/ }
        ]
      };
      const QUOTE_STRING = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          VARIABLE
        ]
      };
      const FUNC = {
        className: "variable",
        begin: /\$\([\w-]+\s/,
        end: /\)/,
        keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
        contains: [
          VARIABLE,
          QUOTE_STRING
          // Added QUOTE_STRING as they can be a part of functions
        ]
      };
      const ASSIGNMENT = { begin: "^" + hljs.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" };
      const META = {
        className: "meta",
        begin: /^\.PHONY:/,
        end: /$/,
        keywords: {
          $pattern: /[\.\w]+/,
          keyword: ".PHONY"
        }
      };
      const TARGET = {
        className: "section",
        begin: /^[^\s]+:/,
        end: /$/,
        contains: [VARIABLE]
      };
      return {
        name: "Makefile",
        aliases: [
          "mk",
          "mak",
          "make"
        ],
        keywords: {
          $pattern: /[\w-]+/,
          keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
        },
        contains: [
          hljs.HASH_COMMENT_MODE,
          VARIABLE,
          QUOTE_STRING,
          FUNC,
          ASSIGNMENT,
          META,
          TARGET
        ]
      };
    }
    module.exports = makefile;
  }
});

// node_modules/highlight.js/lib/languages/perl.js
var require_perl = __commonJS({
  "node_modules/highlight.js/lib/languages/perl.js"(exports, module) {
    function perl(hljs) {
      const regex = hljs.regex;
      const KEYWORDS = [
        "abs",
        "accept",
        "alarm",
        "and",
        "atan2",
        "bind",
        "binmode",
        "bless",
        "break",
        "caller",
        "chdir",
        "chmod",
        "chomp",
        "chop",
        "chown",
        "chr",
        "chroot",
        "class",
        "close",
        "closedir",
        "connect",
        "continue",
        "cos",
        "crypt",
        "dbmclose",
        "dbmopen",
        "defined",
        "delete",
        "die",
        "do",
        "dump",
        "each",
        "else",
        "elsif",
        "endgrent",
        "endhostent",
        "endnetent",
        "endprotoent",
        "endpwent",
        "endservent",
        "eof",
        "eval",
        "exec",
        "exists",
        "exit",
        "exp",
        "fcntl",
        "field",
        "fileno",
        "flock",
        "for",
        "foreach",
        "fork",
        "format",
        "formline",
        "getc",
        "getgrent",
        "getgrgid",
        "getgrnam",
        "gethostbyaddr",
        "gethostbyname",
        "gethostent",
        "getlogin",
        "getnetbyaddr",
        "getnetbyname",
        "getnetent",
        "getpeername",
        "getpgrp",
        "getpriority",
        "getprotobyname",
        "getprotobynumber",
        "getprotoent",
        "getpwent",
        "getpwnam",
        "getpwuid",
        "getservbyname",
        "getservbyport",
        "getservent",
        "getsockname",
        "getsockopt",
        "given",
        "glob",
        "gmtime",
        "goto",
        "grep",
        "gt",
        "hex",
        "if",
        "index",
        "int",
        "ioctl",
        "join",
        "keys",
        "kill",
        "last",
        "lc",
        "lcfirst",
        "length",
        "link",
        "listen",
        "local",
        "localtime",
        "log",
        "lstat",
        "lt",
        "ma",
        "map",
        "method",
        "mkdir",
        "msgctl",
        "msgget",
        "msgrcv",
        "msgsnd",
        "my",
        "ne",
        "next",
        "no",
        "not",
        "oct",
        "open",
        "opendir",
        "or",
        "ord",
        "our",
        "pack",
        "package",
        "pipe",
        "pop",
        "pos",
        "print",
        "printf",
        "prototype",
        "push",
        "q|0",
        "qq",
        "quotemeta",
        "qw",
        "qx",
        "rand",
        "read",
        "readdir",
        "readline",
        "readlink",
        "readpipe",
        "recv",
        "redo",
        "ref",
        "rename",
        "require",
        "reset",
        "return",
        "reverse",
        "rewinddir",
        "rindex",
        "rmdir",
        "say",
        "scalar",
        "seek",
        "seekdir",
        "select",
        "semctl",
        "semget",
        "semop",
        "send",
        "setgrent",
        "sethostent",
        "setnetent",
        "setpgrp",
        "setpriority",
        "setprotoent",
        "setpwent",
        "setservent",
        "setsockopt",
        "shift",
        "shmctl",
        "shmget",
        "shmread",
        "shmwrite",
        "shutdown",
        "sin",
        "sleep",
        "socket",
        "socketpair",
        "sort",
        "splice",
        "split",
        "sprintf",
        "sqrt",
        "srand",
        "stat",
        "state",
        "study",
        "sub",
        "substr",
        "symlink",
        "syscall",
        "sysopen",
        "sysread",
        "sysseek",
        "system",
        "syswrite",
        "tell",
        "telldir",
        "tie",
        "tied",
        "time",
        "times",
        "tr",
        "truncate",
        "uc",
        "ucfirst",
        "umask",
        "undef",
        "unless",
        "unlink",
        "unpack",
        "unshift",
        "untie",
        "until",
        "use",
        "utime",
        "values",
        "vec",
        "wait",
        "waitpid",
        "wantarray",
        "warn",
        "when",
        "while",
        "write",
        "x|0",
        "xor",
        "y|0"
      ];
      const REGEX_MODIFIERS = /[dualxmsipngr]{0,12}/;
      const PERL_KEYWORDS = {
        $pattern: /[\w.]+/,
        keyword: KEYWORDS.join(" ")
      };
      const SUBST = {
        className: "subst",
        begin: "[$@]\\{",
        end: "\\}",
        keywords: PERL_KEYWORDS
      };
      const METHOD = {
        begin: /->\{/,
        end: /\}/
        // contains defined later
      };
      const ATTR = {
        scope: "attr",
        match: /\s+:\s*\w+(\s*\(.*?\))?/
      };
      const VAR = {
        scope: "variable",
        variants: [
          { begin: /\$\d/ },
          {
            begin: regex.concat(
              /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
              // negative look-ahead tries to avoid matching patterns that are not
              // Perl at all like $ident$, @ident@, etc.
              `(?![A-Za-z])(?![@$%])`
            )
          },
          {
            // Only $= is a special Perl variable and one can't declare @= or %=.
            begin: /[$%@](?!")[^\s\w{=]|\$=/,
            relevance: 0
          }
        ],
        contains: [ATTR]
      };
      const NUMBER = {
        className: "number",
        variants: [
          // decimal numbers:
          // include the case where a number starts with a dot (eg. .9), and
          // the leading 0? avoids mixing the first and second match on 0.x cases
          { match: /0?\.[0-9][0-9_]+\b/ },
          // include the special versioned number (eg. v5.38)
          { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
          // non-decimal numbers:
          { match: /\b0[0-7][0-7_]*\b/ },
          { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
          { match: /\b0b[0-1][0-1_]*\b/ }
        ],
        relevance: 0
      };
      const STRING_CONTAINS = [
        hljs.BACKSLASH_ESCAPE,
        SUBST,
        VAR
      ];
      const REGEX_DELIMS = [
        /!/,
        /\//,
        /\|/,
        /\?/,
        /'/,
        /"/,
        // valid but infrequent and weird
        /#/
        // valid but infrequent and weird
      ];
      const PAIRED_DOUBLE_RE = (prefix, open, close = "\\1") => {
        const middle = close === "\\1" ? close : regex.concat(close, open);
        return regex.concat(
          regex.concat("(?:", prefix, ")"),
          open,
          /(?:\\.|[^\\\/])*?/,
          middle,
          /(?:\\.|[^\\\/])*?/,
          close,
          REGEX_MODIFIERS
        );
      };
      const PAIRED_RE = (prefix, open, close) => {
        return regex.concat(
          regex.concat("(?:", prefix, ")"),
          open,
          /(?:\\.|[^\\\/])*?/,
          close,
          REGEX_MODIFIERS
        );
      };
      const PERL_DEFAULT_CONTAINS = [
        VAR,
        hljs.HASH_COMMENT_MODE,
        hljs.COMMENT(
          /^=\w/,
          /=cut/,
          { endsWithParent: true }
        ),
        METHOD,
        {
          className: "string",
          contains: STRING_CONTAINS,
          variants: [
            {
              begin: "q[qwxr]?\\s*\\(",
              end: "\\)",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\[",
              end: "\\]",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\{",
              end: "\\}",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\|",
              end: "\\|",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*<",
              end: ">",
              relevance: 5
            },
            {
              begin: "qw\\s+q",
              end: "q",
              relevance: 5
            },
            {
              begin: "'",
              end: "'",
              contains: [hljs.BACKSLASH_ESCAPE]
            },
            {
              begin: '"',
              end: '"'
            },
            {
              begin: "`",
              end: "`",
              contains: [hljs.BACKSLASH_ESCAPE]
            },
            {
              begin: /\{\w+\}/,
              relevance: 0
            },
            {
              begin: "-?\\w+\\s*=>",
              relevance: 0
            }
          ]
        },
        NUMBER,
        {
          // regexp container
          begin: "(\\/\\/|" + hljs.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
          keywords: "split return print reverse grep",
          relevance: 0,
          contains: [
            hljs.HASH_COMMENT_MODE,
            {
              className: "regexp",
              variants: [
                // allow matching common delimiters
                { begin: PAIRED_DOUBLE_RE("s|tr|y", regex.either(...REGEX_DELIMS, { capture: true })) },
                // and then paired delmis
                { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\(", "\\)") },
                { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\[", "\\]") },
                { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\{", "\\}") }
              ],
              relevance: 2
            },
            {
              className: "regexp",
              variants: [
                {
                  // could be a comment in many languages so do not count
                  // as relevant
                  begin: /(m|qr)\/\//,
                  relevance: 0
                },
                // prefix is optional with /regex/
                { begin: PAIRED_RE("(?:m|qr)?", /\//, /\//) },
                // allow matching common delimiters
                { begin: PAIRED_RE("m|qr", regex.either(...REGEX_DELIMS, { capture: true }), /\1/) },
                // allow common paired delmins
                { begin: PAIRED_RE("m|qr", /\(/, /\)/) },
                { begin: PAIRED_RE("m|qr", /\[/, /\]/) },
                { begin: PAIRED_RE("m|qr", /\{/, /\}/) }
              ]
            }
          ]
        },
        {
          className: "function",
          beginKeywords: "sub method",
          end: "(\\s*\\(.*?\\))?[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [hljs.TITLE_MODE, ATTR]
        },
        {
          className: "class",
          beginKeywords: "class",
          end: "[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [hljs.TITLE_MODE, ATTR, NUMBER]
        },
        {
          begin: "-\\w\\b",
          relevance: 0
        },
        {
          begin: "^__DATA__$",
          end: "^__END__$",
          subLanguage: "mojolicious",
          contains: [
            {
              begin: "^@@.*",
              end: "$",
              className: "comment"
            }
          ]
        }
      ];
      SUBST.contains = PERL_DEFAULT_CONTAINS;
      METHOD.contains = PERL_DEFAULT_CONTAINS;
      return {
        name: "Perl",
        aliases: [
          "pl",
          "pm"
        ],
        keywords: PERL_KEYWORDS,
        contains: PERL_DEFAULT_CONTAINS
      };
    }
    module.exports = perl;
  }
});

// node_modules/highlight.js/lib/languages/objectivec.js
var require_objectivec = __commonJS({
  "node_modules/highlight.js/lib/languages/objectivec.js"(exports, module) {
    function objectivec(hljs) {
      const API_CLASS = {
        className: "built_in",
        begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
      };
      const IDENTIFIER_RE = /[a-zA-Z@][a-zA-Z0-9_]*/;
      const TYPES = [
        "int",
        "float",
        "char",
        "unsigned",
        "signed",
        "short",
        "long",
        "double",
        "wchar_t",
        "unichar",
        "void",
        "bool",
        "BOOL",
        "id|0",
        "_Bool"
      ];
      const KWS = [
        "while",
        "export",
        "sizeof",
        "typedef",
        "const",
        "struct",
        "for",
        "union",
        "volatile",
        "static",
        "mutable",
        "if",
        "do",
        "return",
        "goto",
        "enum",
        "else",
        "break",
        "extern",
        "asm",
        "case",
        "default",
        "register",
        "explicit",
        "typename",
        "switch",
        "continue",
        "inline",
        "readonly",
        "assign",
        "readwrite",
        "self",
        "@synchronized",
        "id",
        "typeof",
        "nonatomic",
        "IBOutlet",
        "IBAction",
        "strong",
        "weak",
        "copy",
        "in",
        "out",
        "inout",
        "bycopy",
        "byref",
        "oneway",
        "__strong",
        "__weak",
        "__block",
        "__autoreleasing",
        "@private",
        "@protected",
        "@public",
        "@try",
        "@property",
        "@end",
        "@throw",
        "@catch",
        "@finally",
        "@autoreleasepool",
        "@synthesize",
        "@dynamic",
        "@selector",
        "@optional",
        "@required",
        "@encode",
        "@package",
        "@import",
        "@defs",
        "@compatibility_alias",
        "__bridge",
        "__bridge_transfer",
        "__bridge_retained",
        "__bridge_retain",
        "__covariant",
        "__contravariant",
        "__kindof",
        "_Nonnull",
        "_Nullable",
        "_Null_unspecified",
        "__FUNCTION__",
        "__PRETTY_FUNCTION__",
        "__attribute__",
        "getter",
        "setter",
        "retain",
        "unsafe_unretained",
        "nonnull",
        "nullable",
        "null_unspecified",
        "null_resettable",
        "class",
        "instancetype",
        "NS_DESIGNATED_INITIALIZER",
        "NS_UNAVAILABLE",
        "NS_REQUIRES_SUPER",
        "NS_RETURNS_INNER_POINTER",
        "NS_INLINE",
        "NS_AVAILABLE",
        "NS_DEPRECATED",
        "NS_ENUM",
        "NS_OPTIONS",
        "NS_SWIFT_UNAVAILABLE",
        "NS_ASSUME_NONNULL_BEGIN",
        "NS_ASSUME_NONNULL_END",
        "NS_REFINED_FOR_SWIFT",
        "NS_SWIFT_NAME",
        "NS_SWIFT_NOTHROW",
        "NS_DURING",
        "NS_HANDLER",
        "NS_ENDHANDLER",
        "NS_VALUERETURN",
        "NS_VOIDRETURN"
      ];
      const LITERALS = [
        "false",
        "true",
        "FALSE",
        "TRUE",
        "nil",
        "YES",
        "NO",
        "NULL"
      ];
      const BUILT_INS = [
        "dispatch_once_t",
        "dispatch_queue_t",
        "dispatch_sync",
        "dispatch_async",
        "dispatch_once"
      ];
      const KEYWORDS = {
        "variable.language": [
          "this",
          "super"
        ],
        $pattern: IDENTIFIER_RE,
        keyword: KWS,
        literal: LITERALS,
        built_in: BUILT_INS,
        type: TYPES
      };
      const CLASS_KEYWORDS = {
        $pattern: IDENTIFIER_RE,
        keyword: [
          "@interface",
          "@class",
          "@protocol",
          "@implementation"
        ]
      };
      return {
        name: "Objective-C",
        aliases: [
          "mm",
          "objc",
          "obj-c",
          "obj-c++",
          "objective-c++"
        ],
        keywords: KEYWORDS,
        illegal: "</",
        contains: [
          API_CLASS,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.C_NUMBER_MODE,
          hljs.QUOTE_STRING_MODE,
          hljs.APOS_STRING_MODE,
          {
            className: "string",
            variants: [
              {
                begin: '@"',
                end: '"',
                illegal: "\\n",
                contains: [hljs.BACKSLASH_ESCAPE]
              }
            ]
          },
          {
            className: "meta",
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
            contains: [
              {
                begin: /\\\n/,
                relevance: 0
              },
              hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" }),
              {
                className: "string",
                begin: /<.*?>/,
                end: /$/,
                illegal: "\\n"
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            className: "class",
            begin: "(" + CLASS_KEYWORDS.keyword.join("|") + ")\\b",
            end: /(\{|$)/,
            excludeEnd: true,
            keywords: CLASS_KEYWORDS,
            contains: [hljs.UNDERSCORE_TITLE_MODE]
          },
          {
            begin: "\\." + hljs.UNDERSCORE_IDENT_RE,
            relevance: 0
          }
        ]
      };
    }
    module.exports = objectivec;
  }
});

// node_modules/highlight.js/lib/languages/php.js
var require_php = __commonJS({
  "node_modules/highlight.js/lib/languages/php.js"(exports, module) {
    function php(hljs) {
      const regex = hljs.regex;
      const NOT_PERL_ETC = /(?![A-Za-z0-9])(?![$])/;
      const IDENT_RE = regex.concat(
        /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
        NOT_PERL_ETC
      );
      const PASCAL_CASE_CLASS_NAME_RE = regex.concat(
        /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
        NOT_PERL_ETC
      );
      const UPCASE_NAME_RE = regex.concat(
        /[A-Z]+/,
        NOT_PERL_ETC
      );
      const VARIABLE = {
        scope: "variable",
        match: "\\$+" + IDENT_RE
      };
      const PREPROCESSOR = {
        scope: "meta",
        variants: [
          { begin: /<\?php/, relevance: 10 },
          // boost for obvious PHP
          { begin: /<\?=/ },
          // less relevant per PSR-1 which says not to use short-tags
          { begin: /<\?/, relevance: 0.1 },
          { begin: /\?>/ }
          // end php tag
        ]
      };
      const SUBST = {
        scope: "subst",
        variants: [
          { begin: /\$\w+/ },
          {
            begin: /\{\$/,
            end: /\}/
          }
        ]
      };
      const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, { illegal: null });
      const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
        illegal: null,
        contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
      });
      const HEREDOC = {
        begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
        end: /[ \t]*(\w+)\b/,
        contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
        "on:begin": (m, resp) => {
          resp.data._beginMatch = m[1] || m[2];
        },
        "on:end": (m, resp) => {
          if (resp.data._beginMatch !== m[1]) resp.ignoreMatch();
        }
      };
      const NOWDOC = hljs.END_SAME_AS_BEGIN({
        begin: /<<<[ \t]*'(\w+)'\n/,
        end: /[ \t]*(\w+)\b/
      });
      const WHITESPACE = "[ 	\n]";
      const STRING = {
        scope: "string",
        variants: [
          DOUBLE_QUOTED,
          SINGLE_QUOTED,
          HEREDOC,
          NOWDOC
        ]
      };
      const NUMBER = {
        scope: "number",
        variants: [
          { begin: `\\b0[bB][01]+(?:_[01]+)*\\b` },
          // Binary w/ underscore support
          { begin: `\\b0[oO][0-7]+(?:_[0-7]+)*\\b` },
          // Octals w/ underscore support
          { begin: `\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b` },
          // Hex w/ underscore support
          // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
          { begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?` }
        ],
        relevance: 0
      };
      const LITERALS = [
        "false",
        "null",
        "true"
      ];
      const KWS = [
        // Magic constants:
        // <https://www.php.net/manual/en/language.constants.predefined.php>
        "__CLASS__",
        "__DIR__",
        "__FILE__",
        "__FUNCTION__",
        "__COMPILER_HALT_OFFSET__",
        "__LINE__",
        "__METHOD__",
        "__NAMESPACE__",
        "__TRAIT__",
        // Function that look like language construct or language construct that look like function:
        // List of keywords that may not require parenthesis
        "die",
        "echo",
        "exit",
        "include",
        "include_once",
        "print",
        "require",
        "require_once",
        // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
        // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
        // Other keywords:
        // <https://www.php.net/manual/en/reserved.php>
        // <https://www.php.net/manual/en/language.types.type-juggling.php>
        "array",
        "abstract",
        "and",
        "as",
        "binary",
        "bool",
        "boolean",
        "break",
        "callable",
        "case",
        "catch",
        "class",
        "clone",
        "const",
        "continue",
        "declare",
        "default",
        "do",
        "double",
        "else",
        "elseif",
        "empty",
        "enddeclare",
        "endfor",
        "endforeach",
        "endif",
        "endswitch",
        "endwhile",
        "enum",
        "eval",
        "extends",
        "final",
        "finally",
        "float",
        "for",
        "foreach",
        "from",
        "global",
        "goto",
        "if",
        "implements",
        "instanceof",
        "insteadof",
        "int",
        "integer",
        "interface",
        "isset",
        "iterable",
        "list",
        "match|0",
        "mixed",
        "new",
        "never",
        "object",
        "or",
        "private",
        "protected",
        "public",
        "readonly",
        "real",
        "return",
        "string",
        "switch",
        "throw",
        "trait",
        "try",
        "unset",
        "use",
        "var",
        "void",
        "while",
        "xor",
        "yield"
      ];
      const BUILT_INS = [
        // Standard PHP library:
        // <https://www.php.net/manual/en/book.spl.php>
        "Error|0",
        "AppendIterator",
        "ArgumentCountError",
        "ArithmeticError",
        "ArrayIterator",
        "ArrayObject",
        "AssertionError",
        "BadFunctionCallException",
        "BadMethodCallException",
        "CachingIterator",
        "CallbackFilterIterator",
        "CompileError",
        "Countable",
        "DirectoryIterator",
        "DivisionByZeroError",
        "DomainException",
        "EmptyIterator",
        "ErrorException",
        "Exception",
        "FilesystemIterator",
        "FilterIterator",
        "GlobIterator",
        "InfiniteIterator",
        "InvalidArgumentException",
        "IteratorIterator",
        "LengthException",
        "LimitIterator",
        "LogicException",
        "MultipleIterator",
        "NoRewindIterator",
        "OutOfBoundsException",
        "OutOfRangeException",
        "OuterIterator",
        "OverflowException",
        "ParentIterator",
        "ParseError",
        "RangeException",
        "RecursiveArrayIterator",
        "RecursiveCachingIterator",
        "RecursiveCallbackFilterIterator",
        "RecursiveDirectoryIterator",
        "RecursiveFilterIterator",
        "RecursiveIterator",
        "RecursiveIteratorIterator",
        "RecursiveRegexIterator",
        "RecursiveTreeIterator",
        "RegexIterator",
        "RuntimeException",
        "SeekableIterator",
        "SplDoublyLinkedList",
        "SplFileInfo",
        "SplFileObject",
        "SplFixedArray",
        "SplHeap",
        "SplMaxHeap",
        "SplMinHeap",
        "SplObjectStorage",
        "SplObserver",
        "SplPriorityQueue",
        "SplQueue",
        "SplStack",
        "SplSubject",
        "SplTempFileObject",
        "TypeError",
        "UnderflowException",
        "UnexpectedValueException",
        "UnhandledMatchError",
        // Reserved interfaces:
        // <https://www.php.net/manual/en/reserved.interfaces.php>
        "ArrayAccess",
        "BackedEnum",
        "Closure",
        "Fiber",
        "Generator",
        "Iterator",
        "IteratorAggregate",
        "Serializable",
        "Stringable",
        "Throwable",
        "Traversable",
        "UnitEnum",
        "WeakReference",
        "WeakMap",
        // Reserved classes:
        // <https://www.php.net/manual/en/reserved.classes.php>
        "Directory",
        "__PHP_Incomplete_Class",
        "parent",
        "php_user_filter",
        "self",
        "static",
        "stdClass"
      ];
      const dualCase = (items) => {
        const result = [];
        items.forEach((item) => {
          result.push(item);
          if (item.toLowerCase() === item) {
            result.push(item.toUpperCase());
          } else {
            result.push(item.toLowerCase());
          }
        });
        return result;
      };
      const KEYWORDS = {
        keyword: KWS,
        literal: dualCase(LITERALS),
        built_in: BUILT_INS
      };
      const normalizeKeywords = (items) => {
        return items.map((item) => {
          return item.replace(/\|\d+$/, "");
        });
      };
      const CONSTRUCTOR_CALL = { variants: [
        {
          match: [
            /new/,
            regex.concat(WHITESPACE, "+"),
            // to prevent built ins from being confused as the class constructor call
            regex.concat("(?!", normalizeKeywords(BUILT_INS).join("\\b|"), "\\b)"),
            PASCAL_CASE_CLASS_NAME_RE
          ],
          scope: {
            1: "keyword",
            4: "title.class"
          }
        }
      ] };
      const CONSTANT_REFERENCE = regex.concat(IDENT_RE, "\\b(?!\\()");
      const LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON = { variants: [
        {
          match: [
            regex.concat(
              /::/,
              regex.lookahead(/(?!class\b)/)
            ),
            CONSTANT_REFERENCE
          ],
          scope: { 2: "variable.constant" }
        },
        {
          match: [
            /::/,
            /class/
          ],
          scope: { 2: "variable.language" }
        },
        {
          match: [
            PASCAL_CASE_CLASS_NAME_RE,
            regex.concat(
              /::/,
              regex.lookahead(/(?!class\b)/)
            ),
            CONSTANT_REFERENCE
          ],
          scope: {
            1: "title.class",
            3: "variable.constant"
          }
        },
        {
          match: [
            PASCAL_CASE_CLASS_NAME_RE,
            regex.concat(
              "::",
              regex.lookahead(/(?!class\b)/)
            )
          ],
          scope: { 1: "title.class" }
        },
        {
          match: [
            PASCAL_CASE_CLASS_NAME_RE,
            /::/,
            /class/
          ],
          scope: {
            1: "title.class",
            3: "variable.language"
          }
        }
      ] };
      const NAMED_ARGUMENT = {
        scope: "attr",
        match: regex.concat(IDENT_RE, regex.lookahead(":"), regex.lookahead(/(?!::)/))
      };
      const PARAMS_MODE = {
        relevance: 0,
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS,
        contains: [
          NAMED_ARGUMENT,
          VARIABLE,
          LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
          hljs.C_BLOCK_COMMENT_MODE,
          STRING,
          NUMBER,
          CONSTRUCTOR_CALL
        ]
      };
      const FUNCTION_INVOKE = {
        relevance: 0,
        match: [
          /\b/,
          // to prevent keywords from being confused as the function title
          regex.concat("(?!fn\\b|function\\b|", normalizeKeywords(KWS).join("\\b|"), "|", normalizeKeywords(BUILT_INS).join("\\b|"), "\\b)"),
          IDENT_RE,
          regex.concat(WHITESPACE, "*"),
          regex.lookahead(/(?=\()/)
        ],
        scope: { 3: "title.function.invoke" },
        contains: [PARAMS_MODE]
      };
      PARAMS_MODE.contains.push(FUNCTION_INVOKE);
      const ATTRIBUTE_CONTAINS = [
        NAMED_ARGUMENT,
        LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
        hljs.C_BLOCK_COMMENT_MODE,
        STRING,
        NUMBER,
        CONSTRUCTOR_CALL
      ];
      const ATTRIBUTES = {
        begin: regex.concat(
          /#\[\s*\\?/,
          regex.either(
            PASCAL_CASE_CLASS_NAME_RE,
            UPCASE_NAME_RE
          )
        ),
        beginScope: "meta",
        end: /]/,
        endScope: "meta",
        keywords: {
          literal: LITERALS,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          {
            begin: /\[/,
            end: /]/,
            keywords: {
              literal: LITERALS,
              keyword: [
                "new",
                "array"
              ]
            },
            contains: [
              "self",
              ...ATTRIBUTE_CONTAINS
            ]
          },
          ...ATTRIBUTE_CONTAINS,
          {
            scope: "meta",
            variants: [
              { match: PASCAL_CASE_CLASS_NAME_RE },
              { match: UPCASE_NAME_RE }
            ]
          }
        ]
      };
      return {
        case_insensitive: false,
        keywords: KEYWORDS,
        contains: [
          ATTRIBUTES,
          hljs.HASH_COMMENT_MODE,
          hljs.COMMENT("//", "$"),
          hljs.COMMENT(
            "/\\*",
            "\\*/",
            { contains: [
              {
                scope: "doctag",
                match: "@[A-Za-z]+"
              }
            ] }
          ),
          {
            match: /__halt_compiler\(\);/,
            keywords: "__halt_compiler",
            starts: {
              scope: "comment",
              end: hljs.MATCH_NOTHING_RE,
              contains: [
                {
                  match: /\?>/,
                  scope: "meta",
                  endsParent: true
                }
              ]
            }
          },
          PREPROCESSOR,
          {
            scope: "variable.language",
            match: /\$this\b/
          },
          VARIABLE,
          FUNCTION_INVOKE,
          LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
          {
            match: [
              /const/,
              /\s/,
              IDENT_RE
            ],
            scope: {
              1: "keyword",
              3: "variable.constant"
            }
          },
          CONSTRUCTOR_CALL,
          {
            scope: "function",
            relevance: 0,
            beginKeywords: "fn function",
            end: /[;{]/,
            excludeEnd: true,
            illegal: "[$%\\[]",
            contains: [
              { beginKeywords: "use" },
              hljs.UNDERSCORE_TITLE_MODE,
              {
                begin: "=>",
                // No markup, just a relevance booster
                endsParent: true
              },
              {
                scope: "params",
                begin: "\\(",
                end: "\\)",
                excludeBegin: true,
                excludeEnd: true,
                keywords: KEYWORDS,
                contains: [
                  "self",
                  ATTRIBUTES,
                  VARIABLE,
                  LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
                  hljs.C_BLOCK_COMMENT_MODE,
                  STRING,
                  NUMBER
                ]
              }
            ]
          },
          {
            scope: "class",
            variants: [
              {
                beginKeywords: "enum",
                illegal: /[($"]/
              },
              {
                beginKeywords: "class interface trait",
                illegal: /[:($"]/
              }
            ],
            relevance: 0,
            end: /\{/,
            excludeEnd: true,
            contains: [
              { beginKeywords: "extends implements" },
              hljs.UNDERSCORE_TITLE_MODE
            ]
          },
          // both use and namespace still use "old style" rules (vs multi-match)
          // because the namespace name can include `\` and we still want each
          // element to be treated as its own *individual* title
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: ";",
            illegal: /[.']/,
            contains: [hljs.inherit(hljs.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
          },
          {
            beginKeywords: "use",
            relevance: 0,
            end: ";",
            contains: [
              // TODO: title.function vs title.class
              {
                match: /\b(as|const|function)\b/,
                scope: "keyword"
              },
              // TODO: could be title.class or title.function
              hljs.UNDERSCORE_TITLE_MODE
            ]
          },
          STRING,
          NUMBER
        ]
      };
    }
    module.exports = php;
  }
});

// node_modules/highlight.js/lib/languages/php-template.js
var require_php_template = __commonJS({
  "node_modules/highlight.js/lib/languages/php-template.js"(exports, module) {
    function phpTemplate(hljs) {
      return {
        name: "PHP template",
        subLanguage: "xml",
        contains: [
          {
            begin: /<\?(php|=)?/,
            end: /\?>/,
            subLanguage: "php",
            contains: [
              // We don't want the php closing tag ?> to close the PHP block when
              // inside any of the following blocks:
              {
                begin: "/\\*",
                end: "\\*/",
                skip: true
              },
              {
                begin: 'b"',
                end: '"',
                skip: true
              },
              {
                begin: "b'",
                end: "'",
                skip: true
              },
              hljs.inherit(hljs.APOS_STRING_MODE, {
                illegal: null,
                className: null,
                contains: null,
                skip: true
              }),
              hljs.inherit(hljs.QUOTE_STRING_MODE, {
                illegal: null,
                className: null,
                contains: null,
                skip: true
              })
            ]
          }
        ]
      };
    }
    module.exports = phpTemplate;
  }
});

// node_modules/highlight.js/lib/languages/plaintext.js
var require_plaintext = __commonJS({
  "node_modules/highlight.js/lib/languages/plaintext.js"(exports, module) {
    function plaintext(hljs) {
      return {
        name: "Plain text",
        aliases: [
          "text",
          "txt"
        ],
        disableAutodetect: true
      };
    }
    module.exports = plaintext;
  }
});

// node_modules/highlight.js/lib/languages/python.js
var require_python = __commonJS({
  "node_modules/highlight.js/lib/languages/python.js"(exports, module) {
    function python(hljs) {
      const regex = hljs.regex;
      const IDENT_RE = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u");
      const RESERVED_WORDS = [
        "and",
        "as",
        "assert",
        "async",
        "await",
        "break",
        "case",
        "class",
        "continue",
        "def",
        "del",
        "elif",
        "else",
        "except",
        "finally",
        "for",
        "from",
        "global",
        "if",
        "import",
        "in",
        "is",
        "lambda",
        "match",
        "nonlocal|10",
        "not",
        "or",
        "pass",
        "raise",
        "return",
        "try",
        "while",
        "with",
        "yield"
      ];
      const BUILT_INS = [
        "__import__",
        "abs",
        "all",
        "any",
        "ascii",
        "bin",
        "bool",
        "breakpoint",
        "bytearray",
        "bytes",
        "callable",
        "chr",
        "classmethod",
        "compile",
        "complex",
        "delattr",
        "dict",
        "dir",
        "divmod",
        "enumerate",
        "eval",
        "exec",
        "filter",
        "float",
        "format",
        "frozenset",
        "getattr",
        "globals",
        "hasattr",
        "hash",
        "help",
        "hex",
        "id",
        "input",
        "int",
        "isinstance",
        "issubclass",
        "iter",
        "len",
        "list",
        "locals",
        "map",
        "max",
        "memoryview",
        "min",
        "next",
        "object",
        "oct",
        "open",
        "ord",
        "pow",
        "print",
        "property",
        "range",
        "repr",
        "reversed",
        "round",
        "set",
        "setattr",
        "slice",
        "sorted",
        "staticmethod",
        "str",
        "sum",
        "super",
        "tuple",
        "type",
        "vars",
        "zip"
      ];
      const LITERALS = [
        "__debug__",
        "Ellipsis",
        "False",
        "None",
        "NotImplemented",
        "True"
      ];
      const TYPES = [
        "Any",
        "Callable",
        "Coroutine",
        "Dict",
        "List",
        "Literal",
        "Generic",
        "Optional",
        "Sequence",
        "Set",
        "Tuple",
        "Type",
        "Union"
      ];
      const KEYWORDS = {
        $pattern: /[A-Za-z]\w+|__\w+__/,
        keyword: RESERVED_WORDS,
        built_in: BUILT_INS,
        literal: LITERALS,
        type: TYPES
      };
      const PROMPT = {
        className: "meta",
        begin: /^(>>>|\.\.\.) /
      };
      const SUBST = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS,
        illegal: /#/
      };
      const LITERAL_BRACKET = {
        begin: /\{\{/,
        relevance: 0
      };
      const STRING = {
        className: "string",
        contains: [hljs.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
            end: /'''/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              PROMPT
            ],
            relevance: 10
          },
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
            end: /"""/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              PROMPT
            ],
            relevance: 10
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'''/,
            end: /'''/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              PROMPT,
              LITERAL_BRACKET,
              SUBST
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"""/,
            end: /"""/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              PROMPT,
              LITERAL_BRACKET,
              SUBST
            ]
          },
          {
            begin: /([uU]|[rR])'/,
            end: /'/,
            relevance: 10
          },
          {
            begin: /([uU]|[rR])"/,
            end: /"/,
            relevance: 10
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])'/,
            end: /'/
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])"/,
            end: /"/
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'/,
            end: /'/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              LITERAL_BRACKET,
              SUBST
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"/,
            end: /"/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              LITERAL_BRACKET,
              SUBST
            ]
          },
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE
        ]
      };
      const digitpart = "[0-9](_?[0-9])*";
      const pointfloat = `(\\b(${digitpart}))?\\.(${digitpart})|\\b(${digitpart})\\.`;
      const lookahead = `\\b|${RESERVED_WORDS.join("|")}`;
      const NUMBER = {
        className: "number",
        relevance: 0,
        variants: [
          // exponentfloat, pointfloat
          // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
          // optionally imaginary
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          // Note: no leading \b because floats can start with a decimal point
          // and we don't want to mishandle e.g. `fn(.5)`,
          // no trailing \b for pointfloat because it can end with a decimal point
          // and we don't want to mishandle e.g. `0..hex()`; this should be safe
          // because both MUST contain a decimal point and so cannot be confused with
          // the interior part of an identifier
          {
            begin: `(\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?(?=${lookahead})`
          },
          {
            begin: `(${pointfloat})[jJ]?`
          },
          // decinteger, bininteger, octinteger, hexinteger
          // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
          // optionally "long" in Python 2
          // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
          // decinteger is optionally imaginary
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          {
            begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${lookahead})`
          },
          {
            begin: `\\b0[bB](_?[01])+[lL]?(?=${lookahead})`
          },
          {
            begin: `\\b0[oO](_?[0-7])+[lL]?(?=${lookahead})`
          },
          {
            begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${lookahead})`
          },
          // imagnumber (digitpart-based)
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          {
            begin: `\\b(${digitpart})[jJ](?=${lookahead})`
          }
        ]
      };
      const COMMENT_TYPE = {
        className: "comment",
        begin: regex.lookahead(/# type:/),
        end: /$/,
        keywords: KEYWORDS,
        contains: [
          {
            // prevent keywords from coloring `type`
            begin: /# type:/
          },
          // comment within a datatype comment includes no keywords
          {
            begin: /#/,
            end: /\b\B/,
            endsWithParent: true
          }
        ]
      };
      const PARAMS = {
        className: "params",
        variants: [
          // Exclude params in functions without params
          {
            className: "",
            begin: /\(\s*\)/,
            skip: true
          },
          {
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS,
            contains: [
              "self",
              PROMPT,
              NUMBER,
              STRING,
              hljs.HASH_COMMENT_MODE
            ]
          }
        ]
      };
      SUBST.contains = [
        STRING,
        NUMBER,
        PROMPT
      ];
      return {
        name: "Python",
        aliases: [
          "py",
          "gyp",
          "ipython"
        ],
        unicodeRegex: true,
        keywords: KEYWORDS,
        illegal: /(<\/|\?)|=>/,
        contains: [
          PROMPT,
          NUMBER,
          {
            // very common convention
            scope: "variable.language",
            match: /\bself\b/
          },
          {
            // eat "if" prior to string so that it won't accidentally be
            // labeled as an f-string
            beginKeywords: "if",
            relevance: 0
          },
          { match: /\bor\b/, scope: "keyword" },
          STRING,
          COMMENT_TYPE,
          hljs.HASH_COMMENT_MODE,
          {
            match: [
              /\bdef/,
              /\s+/,
              IDENT_RE
            ],
            scope: {
              1: "keyword",
              3: "title.function"
            },
            contains: [PARAMS]
          },
          {
            variants: [
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  IDENT_RE,
                  /\s*/,
                  /\(\s*/,
                  IDENT_RE,
                  /\s*\)/
                ]
              },
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  IDENT_RE
                ]
              }
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              6: "title.class.inherited"
            }
          },
          {
            className: "meta",
            begin: /^[\t ]*@/,
            end: /(?=#)|$/,
            contains: [
              NUMBER,
              PARAMS,
              STRING
            ]
          }
        ]
      };
    }
    module.exports = python;
  }
});

// node_modules/highlight.js/lib/languages/python-repl.js
var require_python_repl = __commonJS({
  "node_modules/highlight.js/lib/languages/python-repl.js"(exports, module) {
    function pythonRepl(hljs) {
      return {
        aliases: ["pycon"],
        contains: [
          {
            className: "meta.prompt",
            starts: {
              // a space separates the REPL prefix from the actual code
              // this is purely for cleaner HTML output
              end: / |$/,
              starts: {
                end: "$",
                subLanguage: "python"
              }
            },
            variants: [
              { begin: /^>>>(?=[ ]|$)/ },
              { begin: /^\.\.\.(?=[ ]|$)/ }
            ]
          }
        ]
      };
    }
    module.exports = pythonRepl;
  }
});

// node_modules/highlight.js/lib/languages/r.js
var require_r = __commonJS({
  "node_modules/highlight.js/lib/languages/r.js"(exports, module) {
    function r(hljs) {
      const regex = hljs.regex;
      const IDENT_RE = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/;
      const NUMBER_TYPES_RE = regex.either(
        // Special case: only hexadecimal binary powers can contain fractions
        /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
        // Hexadecimal numbers without fraction and optional binary power
        /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
        // Decimal numbers
        /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
      );
      const OPERATORS_RE = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/;
      const PUNCTUATION_RE = regex.either(
        /[()]/,
        /[{}]/,
        /\[\[/,
        /[[\]]/,
        /\\/,
        /,/
      );
      return {
        name: "R",
        keywords: {
          $pattern: IDENT_RE,
          keyword: "function if in break next repeat else for while",
          literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
          built_in: (
            // Builtin constants
            "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
          )
        },
        contains: [
          // Roxygen comments
          hljs.COMMENT(
            /#'/,
            /$/,
            { contains: [
              {
                // Handle `@examples` separately to cause all subsequent code
                // until the next `@`-tag on its own line to be kept as-is,
                // preventing highlighting. This code is example R code, so nested
                // doctags shouldn’t be treated as such. See
                // `test/markup/r/roxygen.txt` for an example.
                scope: "doctag",
                match: /@examples/,
                starts: {
                  end: regex.lookahead(regex.either(
                    // end if another doc comment
                    /\n^#'\s*(?=@[a-zA-Z]+)/,
                    // or a line with no comment
                    /\n^(?!#')/
                  )),
                  endsParent: true
                }
              },
              {
                // Handle `@param` to highlight the parameter name following
                // after.
                scope: "doctag",
                begin: "@param",
                end: /$/,
                contains: [
                  {
                    scope: "variable",
                    variants: [
                      { match: IDENT_RE },
                      { match: /`(?:\\.|[^`\\])+`/ }
                    ],
                    endsParent: true
                  }
                ]
              },
              {
                scope: "doctag",
                match: /@[a-zA-Z]+/
              },
              {
                scope: "keyword",
                match: /\\[a-zA-Z]+/
              }
            ] }
          ),
          hljs.HASH_COMMENT_MODE,
          {
            scope: "string",
            contains: [hljs.BACKSLASH_ESCAPE],
            variants: [
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\(/,
                end: /\)(-*)"/
              }),
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\{/,
                end: /\}(-*)"/
              }),
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\[/,
                end: /\](-*)"/
              }),
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\(/,
                end: /\)(-*)'/
              }),
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\{/,
                end: /\}(-*)'/
              }),
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\[/,
                end: /\](-*)'/
              }),
              {
                begin: '"',
                end: '"',
                relevance: 0
              },
              {
                begin: "'",
                end: "'",
                relevance: 0
              }
            ]
          },
          // Matching numbers immediately following punctuation and operators is
          // tricky since we need to look at the character ahead of a number to
          // ensure the number is not part of an identifier, and we cannot use
          // negative look-behind assertions. So instead we explicitly handle all
          // possible combinations of (operator|punctuation), number.
          // TODO: replace with negative look-behind when available
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
          // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
          {
            relevance: 0,
            variants: [
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  OPERATORS_RE,
                  NUMBER_TYPES_RE
                ]
              },
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  /%[^%]*%/,
                  NUMBER_TYPES_RE
                ]
              },
              {
                scope: {
                  1: "punctuation",
                  2: "number"
                },
                match: [
                  PUNCTUATION_RE,
                  NUMBER_TYPES_RE
                ]
              },
              {
                scope: { 2: "number" },
                match: [
                  /[^a-zA-Z0-9._]|^/,
                  // not part of an identifier, or start of document
                  NUMBER_TYPES_RE
                ]
              }
            ]
          },
          // Operators/punctuation when they're not directly followed by numbers
          {
            // Relevance boost for the most common assignment form.
            scope: { 3: "operator" },
            match: [
              IDENT_RE,
              /\s+/,
              /<-/,
              /\s+/
            ]
          },
          {
            scope: "operator",
            relevance: 0,
            variants: [
              { match: OPERATORS_RE },
              { match: /%[^%]*%/ }
            ]
          },
          {
            scope: "punctuation",
            relevance: 0,
            match: PUNCTUATION_RE
          },
          {
            // Escaped identifier
            begin: "`",
            end: "`",
            contains: [{ begin: /\\./ }]
          }
        ]
      };
    }
    module.exports = r;
  }
});

// node_modules/highlight.js/lib/languages/rust.js
var require_rust = __commonJS({
  "node_modules/highlight.js/lib/languages/rust.js"(exports, module) {
    function rust(hljs) {
      const regex = hljs.regex;
      const RAW_IDENTIFIER = /(r#)?/;
      const UNDERSCORE_IDENT_RE = regex.concat(RAW_IDENTIFIER, hljs.UNDERSCORE_IDENT_RE);
      const IDENT_RE = regex.concat(RAW_IDENTIFIER, hljs.IDENT_RE);
      const FUNCTION_INVOKE = {
        className: "title.function.invoke",
        relevance: 0,
        begin: regex.concat(
          /\b/,
          /(?!let|for|while|if|else|match\b)/,
          IDENT_RE,
          regex.lookahead(/\s*\(/)
        )
      };
      const NUMBER_SUFFIX = "([ui](8|16|32|64|128|size)|f(32|64))?";
      const KEYWORDS = [
        "abstract",
        "as",
        "async",
        "await",
        "become",
        "box",
        "break",
        "const",
        "continue",
        "crate",
        "do",
        "dyn",
        "else",
        "enum",
        "extern",
        "false",
        "final",
        "fn",
        "for",
        "if",
        "impl",
        "in",
        "let",
        "loop",
        "macro",
        "match",
        "mod",
        "move",
        "mut",
        "override",
        "priv",
        "pub",
        "ref",
        "return",
        "self",
        "Self",
        "static",
        "struct",
        "super",
        "trait",
        "true",
        "try",
        "type",
        "typeof",
        "union",
        "unsafe",
        "unsized",
        "use",
        "virtual",
        "where",
        "while",
        "yield"
      ];
      const LITERALS = [
        "true",
        "false",
        "Some",
        "None",
        "Ok",
        "Err"
      ];
      const BUILTINS = [
        // functions
        "drop ",
        // traits
        "Copy",
        "Send",
        "Sized",
        "Sync",
        "Drop",
        "Fn",
        "FnMut",
        "FnOnce",
        "ToOwned",
        "Clone",
        "Debug",
        "PartialEq",
        "PartialOrd",
        "Eq",
        "Ord",
        "AsRef",
        "AsMut",
        "Into",
        "From",
        "Default",
        "Iterator",
        "Extend",
        "IntoIterator",
        "DoubleEndedIterator",
        "ExactSizeIterator",
        "SliceConcatExt",
        "ToString",
        // macros
        "assert!",
        "assert_eq!",
        "bitflags!",
        "bytes!",
        "cfg!",
        "col!",
        "concat!",
        "concat_idents!",
        "debug_assert!",
        "debug_assert_eq!",
        "env!",
        "eprintln!",
        "panic!",
        "file!",
        "format!",
        "format_args!",
        "include_bytes!",
        "include_str!",
        "line!",
        "local_data_key!",
        "module_path!",
        "option_env!",
        "print!",
        "println!",
        "select!",
        "stringify!",
        "try!",
        "unimplemented!",
        "unreachable!",
        "vec!",
        "write!",
        "writeln!",
        "macro_rules!",
        "assert_ne!",
        "debug_assert_ne!"
      ];
      const TYPES = [
        "i8",
        "i16",
        "i32",
        "i64",
        "i128",
        "isize",
        "u8",
        "u16",
        "u32",
        "u64",
        "u128",
        "usize",
        "f32",
        "f64",
        "str",
        "char",
        "bool",
        "Box",
        "Option",
        "Result",
        "String",
        "Vec"
      ];
      return {
        name: "Rust",
        aliases: ["rs"],
        keywords: {
          $pattern: hljs.IDENT_RE + "!?",
          type: TYPES,
          keyword: KEYWORDS,
          literal: LITERALS,
          built_in: BUILTINS
        },
        illegal: "</",
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
          hljs.inherit(hljs.QUOTE_STRING_MODE, {
            begin: /b?"/,
            illegal: null
          }),
          {
            className: "symbol",
            // negative lookahead to avoid matching `'`
            begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
          },
          {
            scope: "string",
            variants: [
              { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
              {
                begin: /b?'/,
                end: /'/,
                contains: [
                  {
                    scope: "char.escape",
                    match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
                  }
                ]
              }
            ]
          },
          {
            className: "number",
            variants: [
              { begin: "\\b0b([01_]+)" + NUMBER_SUFFIX },
              { begin: "\\b0o([0-7_]+)" + NUMBER_SUFFIX },
              { begin: "\\b0x([A-Fa-f0-9_]+)" + NUMBER_SUFFIX },
              { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + NUMBER_SUFFIX }
            ],
            relevance: 0
          },
          {
            begin: [
              /fn/,
              /\s+/,
              UNDERSCORE_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "title.function"
            }
          },
          {
            className: "meta",
            begin: "#!?\\[",
            end: "\\]",
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/,
                contains: [
                  hljs.BACKSLASH_ESCAPE
                ]
              }
            ]
          },
          {
            begin: [
              /let/,
              /\s+/,
              /(?:mut\s+)?/,
              UNDERSCORE_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "keyword",
              4: "variable"
            }
          },
          // must come before impl/for rule later
          {
            begin: [
              /for/,
              /\s+/,
              UNDERSCORE_IDENT_RE,
              /\s+/,
              /in/
            ],
            className: {
              1: "keyword",
              3: "variable",
              5: "keyword"
            }
          },
          {
            begin: [
              /type/,
              /\s+/,
              UNDERSCORE_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: [
              /(?:trait|enum|struct|union|impl|for)/,
              /\s+/,
              UNDERSCORE_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: hljs.IDENT_RE + "::",
            keywords: {
              keyword: "Self",
              built_in: BUILTINS,
              type: TYPES
            }
          },
          {
            className: "punctuation",
            begin: "->"
          },
          FUNCTION_INVOKE
        ]
      };
    }
    module.exports = rust;
  }
});

// node_modules/highlight.js/lib/languages/scss.js
var require_scss = __commonJS({
  "node_modules/highlight.js/lib/languages/scss.js"(exports, module) {
    var MODES = (hljs) => {
      return {
        IMPORTANT: {
          scope: "meta",
          begin: "!important"
        },
        BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: {
          scope: "number",
          begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
        },
        FUNCTION_DISPATCH: {
          className: "built_in",
          begin: /[\w-]+(?=\()/
        },
        ATTRIBUTE_SELECTOR_MODE: {
          scope: "selector-attr",
          begin: /\[/,
          end: /\]/,
          illegal: "$",
          contains: [
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE
          ]
        },
        CSS_NUMBER_MODE: {
          scope: "number",
          begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
          relevance: 0
        },
        CSS_VARIABLE: {
          className: "attr",
          begin: /--[A-Za-z_][A-Za-z0-9_-]*/
        }
      };
    };
    var HTML_TAGS = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ];
    var SVG_TAGS = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ];
    var TAGS = [
      ...HTML_TAGS,
      ...SVG_TAGS
    ];
    var MEDIA_FEATURES = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse();
    var PSEUDO_CLASSES = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse();
    var PSEUDO_ELEMENTS = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse();
    var ATTRIBUTES = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    function scss(hljs) {
      const modes = MODES(hljs);
      const PSEUDO_ELEMENTS$1 = PSEUDO_ELEMENTS;
      const PSEUDO_CLASSES$1 = PSEUDO_CLASSES;
      const AT_IDENTIFIER = "@[a-z-]+";
      const AT_MODIFIERS = "and or not only";
      const IDENT_RE = "[a-zA-Z-][a-zA-Z0-9_-]*";
      const VARIABLE = {
        className: "variable",
        begin: "(\\$" + IDENT_RE + ")\\b",
        relevance: 0
      };
      return {
        name: "SCSS",
        case_insensitive: true,
        illegal: "[=/|']",
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          // to recognize keyframe 40% etc which are outside the scope of our
          // attribute value mode
          modes.CSS_NUMBER_MODE,
          {
            className: "selector-id",
            begin: "#[A-Za-z0-9_-]+",
            relevance: 0
          },
          {
            className: "selector-class",
            begin: "\\.[A-Za-z0-9_-]+",
            relevance: 0
          },
          modes.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-tag",
            begin: "\\b(" + TAGS.join("|") + ")\\b",
            // was there, before, but why?
            relevance: 0
          },
          {
            className: "selector-pseudo",
            begin: ":(" + PSEUDO_CLASSES$1.join("|") + ")"
          },
          {
            className: "selector-pseudo",
            begin: ":(:)?(" + PSEUDO_ELEMENTS$1.join("|") + ")"
          },
          VARIABLE,
          {
            // pseudo-selector params
            begin: /\(/,
            end: /\)/,
            contains: [modes.CSS_NUMBER_MODE]
          },
          modes.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
          },
          { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
          {
            begin: /:/,
            end: /[;}{]/,
            relevance: 0,
            contains: [
              modes.BLOCK_COMMENT,
              VARIABLE,
              modes.HEXCOLOR,
              modes.CSS_NUMBER_MODE,
              hljs.QUOTE_STRING_MODE,
              hljs.APOS_STRING_MODE,
              modes.IMPORTANT,
              modes.FUNCTION_DISPATCH
            ]
          },
          // matching these here allows us to treat them more like regular CSS
          // rules so everything between the {} gets regular rule highlighting,
          // which is what we want for page and font-face
          {
            begin: "@(page|font-face)",
            keywords: {
              $pattern: AT_IDENTIFIER,
              keyword: "@page @font-face"
            }
          },
          {
            begin: "@",
            end: "[{;]",
            returnBegin: true,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: AT_MODIFIERS,
              attribute: MEDIA_FEATURES.join(" ")
            },
            contains: [
              {
                begin: AT_IDENTIFIER,
                className: "keyword"
              },
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              VARIABLE,
              hljs.QUOTE_STRING_MODE,
              hljs.APOS_STRING_MODE,
              modes.HEXCOLOR,
              modes.CSS_NUMBER_MODE
            ]
          },
          modes.FUNCTION_DISPATCH
        ]
      };
    }
    module.exports = scss;
  }
});

// node_modules/highlight.js/lib/languages/shell.js
var require_shell = __commonJS({
  "node_modules/highlight.js/lib/languages/shell.js"(exports, module) {
    function shell(hljs) {
      return {
        name: "Shell Session",
        aliases: [
          "console",
          "shellsession"
        ],
        contains: [
          {
            className: "meta.prompt",
            // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
            // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
            // echo /path/to/home > t.exe
            begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
            starts: {
              end: /[^\\](?=\s*$)/,
              subLanguage: "bash"
            }
          }
        ]
      };
    }
    module.exports = shell;
  }
});

// node_modules/highlight.js/lib/languages/sql.js
var require_sql = __commonJS({
  "node_modules/highlight.js/lib/languages/sql.js"(exports, module) {
    function sql(hljs) {
      const regex = hljs.regex;
      const COMMENT_MODE = hljs.COMMENT("--", "$");
      const STRING = {
        scope: "string",
        variants: [
          {
            begin: /'/,
            end: /'/,
            contains: [{ match: /''/ }]
          }
        ]
      };
      const QUOTED_IDENTIFIER = {
        begin: /"/,
        end: /"/,
        contains: [{ match: /""/ }]
      };
      const LITERALS = [
        "true",
        "false",
        // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
        // "null",
        "unknown"
      ];
      const MULTI_WORD_TYPES = [
        "double precision",
        "large object",
        "with timezone",
        "without timezone"
      ];
      const TYPES = [
        "bigint",
        "binary",
        "blob",
        "boolean",
        "char",
        "character",
        "clob",
        "date",
        "dec",
        "decfloat",
        "decimal",
        "float",
        "int",
        "integer",
        "interval",
        "nchar",
        "nclob",
        "national",
        "numeric",
        "real",
        "row",
        "smallint",
        "time",
        "timestamp",
        "varchar",
        "varying",
        // modifier (character varying)
        "varbinary"
      ];
      const NON_RESERVED_WORDS = [
        "add",
        "asc",
        "collation",
        "desc",
        "final",
        "first",
        "last",
        "view"
      ];
      const RESERVED_WORDS = [
        "abs",
        "acos",
        "all",
        "allocate",
        "alter",
        "and",
        "any",
        "are",
        "array",
        "array_agg",
        "array_max_cardinality",
        "as",
        "asensitive",
        "asin",
        "asymmetric",
        "at",
        "atan",
        "atomic",
        "authorization",
        "avg",
        "begin",
        "begin_frame",
        "begin_partition",
        "between",
        "bigint",
        "binary",
        "blob",
        "boolean",
        "both",
        "by",
        "call",
        "called",
        "cardinality",
        "cascaded",
        "case",
        "cast",
        "ceil",
        "ceiling",
        "char",
        "char_length",
        "character",
        "character_length",
        "check",
        "classifier",
        "clob",
        "close",
        "coalesce",
        "collate",
        "collect",
        "column",
        "commit",
        "condition",
        "connect",
        "constraint",
        "contains",
        "convert",
        "copy",
        "corr",
        "corresponding",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "create",
        "cross",
        "cube",
        "cume_dist",
        "current",
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_row",
        "current_schema",
        "current_time",
        "current_timestamp",
        "current_path",
        "current_role",
        "current_transform_group_for_type",
        "current_user",
        "cursor",
        "cycle",
        "date",
        "day",
        "deallocate",
        "dec",
        "decimal",
        "decfloat",
        "declare",
        "default",
        "define",
        "delete",
        "dense_rank",
        "deref",
        "describe",
        "deterministic",
        "disconnect",
        "distinct",
        "double",
        "drop",
        "dynamic",
        "each",
        "element",
        "else",
        "empty",
        "end",
        "end_frame",
        "end_partition",
        "end-exec",
        "equals",
        "escape",
        "every",
        "except",
        "exec",
        "execute",
        "exists",
        "exp",
        "external",
        "extract",
        "false",
        "fetch",
        "filter",
        "first_value",
        "float",
        "floor",
        "for",
        "foreign",
        "frame_row",
        "free",
        "from",
        "full",
        "function",
        "fusion",
        "get",
        "global",
        "grant",
        "group",
        "grouping",
        "groups",
        "having",
        "hold",
        "hour",
        "identity",
        "in",
        "indicator",
        "initial",
        "inner",
        "inout",
        "insensitive",
        "insert",
        "int",
        "integer",
        "intersect",
        "intersection",
        "interval",
        "into",
        "is",
        "join",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "language",
        "large",
        "last_value",
        "lateral",
        "lead",
        "leading",
        "left",
        "like",
        "like_regex",
        "listagg",
        "ln",
        "local",
        "localtime",
        "localtimestamp",
        "log",
        "log10",
        "lower",
        "match",
        "match_number",
        "match_recognize",
        "matches",
        "max",
        "member",
        "merge",
        "method",
        "min",
        "minute",
        "mod",
        "modifies",
        "module",
        "month",
        "multiset",
        "national",
        "natural",
        "nchar",
        "nclob",
        "new",
        "no",
        "none",
        "normalize",
        "not",
        "nth_value",
        "ntile",
        "null",
        "nullif",
        "numeric",
        "octet_length",
        "occurrences_regex",
        "of",
        "offset",
        "old",
        "omit",
        "on",
        "one",
        "only",
        "open",
        "or",
        "order",
        "out",
        "outer",
        "over",
        "overlaps",
        "overlay",
        "parameter",
        "partition",
        "pattern",
        "per",
        "percent",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "period",
        "portion",
        "position",
        "position_regex",
        "power",
        "precedes",
        "precision",
        "prepare",
        "primary",
        "procedure",
        "ptf",
        "range",
        "rank",
        "reads",
        "real",
        "recursive",
        "ref",
        "references",
        "referencing",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "release",
        "result",
        "return",
        "returns",
        "revoke",
        "right",
        "rollback",
        "rollup",
        "row",
        "row_number",
        "rows",
        "running",
        "savepoint",
        "scope",
        "scroll",
        "search",
        "second",
        "seek",
        "select",
        "sensitive",
        "session_user",
        "set",
        "show",
        "similar",
        "sin",
        "sinh",
        "skip",
        "smallint",
        "some",
        "specific",
        "specifictype",
        "sql",
        "sqlexception",
        "sqlstate",
        "sqlwarning",
        "sqrt",
        "start",
        "static",
        "stddev_pop",
        "stddev_samp",
        "submultiset",
        "subset",
        "substring",
        "substring_regex",
        "succeeds",
        "sum",
        "symmetric",
        "system",
        "system_time",
        "system_user",
        "table",
        "tablesample",
        "tan",
        "tanh",
        "then",
        "time",
        "timestamp",
        "timezone_hour",
        "timezone_minute",
        "to",
        "trailing",
        "translate",
        "translate_regex",
        "translation",
        "treat",
        "trigger",
        "trim",
        "trim_array",
        "true",
        "truncate",
        "uescape",
        "union",
        "unique",
        "unknown",
        "unnest",
        "update",
        "upper",
        "user",
        "using",
        "value",
        "values",
        "value_of",
        "var_pop",
        "var_samp",
        "varbinary",
        "varchar",
        "varying",
        "versioning",
        "when",
        "whenever",
        "where",
        "width_bucket",
        "window",
        "with",
        "within",
        "without",
        "year"
      ];
      const RESERVED_FUNCTIONS = [
        "abs",
        "acos",
        "array_agg",
        "asin",
        "atan",
        "avg",
        "cast",
        "ceil",
        "ceiling",
        "coalesce",
        "corr",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "cume_dist",
        "dense_rank",
        "deref",
        "element",
        "exp",
        "extract",
        "first_value",
        "floor",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "last_value",
        "lead",
        "listagg",
        "ln",
        "log",
        "log10",
        "lower",
        "max",
        "min",
        "mod",
        "nth_value",
        "ntile",
        "nullif",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "position",
        "position_regex",
        "power",
        "rank",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "row_number",
        "sin",
        "sinh",
        "sqrt",
        "stddev_pop",
        "stddev_samp",
        "substring",
        "substring_regex",
        "sum",
        "tan",
        "tanh",
        "translate",
        "translate_regex",
        "treat",
        "trim",
        "trim_array",
        "unnest",
        "upper",
        "value_of",
        "var_pop",
        "var_samp",
        "width_bucket"
      ];
      const POSSIBLE_WITHOUT_PARENS = [
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_schema",
        "current_transform_group_for_type",
        "current_user",
        "session_user",
        "system_time",
        "system_user",
        "current_time",
        "localtime",
        "current_timestamp",
        "localtimestamp"
      ];
      const COMBOS = [
        "create table",
        "insert into",
        "primary key",
        "foreign key",
        "not null",
        "alter table",
        "add constraint",
        "grouping sets",
        "on overflow",
        "character set",
        "respect nulls",
        "ignore nulls",
        "nulls first",
        "nulls last",
        "depth first",
        "breadth first"
      ];
      const FUNCTIONS = RESERVED_FUNCTIONS;
      const KEYWORDS = [
        ...RESERVED_WORDS,
        ...NON_RESERVED_WORDS
      ].filter((keyword) => {
        return !RESERVED_FUNCTIONS.includes(keyword);
      });
      const VARIABLE = {
        scope: "variable",
        match: /@[a-z0-9][a-z0-9_]*/
      };
      const OPERATOR = {
        scope: "operator",
        match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
        relevance: 0
      };
      const FUNCTION_CALL = {
        match: regex.concat(/\b/, regex.either(...FUNCTIONS), /\s*\(/),
        relevance: 0,
        keywords: { built_in: FUNCTIONS }
      };
      function kws_to_regex(list) {
        return regex.concat(
          /\b/,
          regex.either(...list.map((kw) => {
            return kw.replace(/\s+/, "\\s+");
          })),
          /\b/
        );
      }
      const MULTI_WORD_KEYWORDS = {
        scope: "keyword",
        match: kws_to_regex(COMBOS),
        relevance: 0
      };
      function reduceRelevancy(list, {
        exceptions,
        when
      } = {}) {
        const qualifyFn = when;
        exceptions = exceptions || [];
        return list.map((item) => {
          if (item.match(/\|\d+$/) || exceptions.includes(item)) {
            return item;
          } else if (qualifyFn(item)) {
            return `${item}|0`;
          } else {
            return item;
          }
        });
      }
      return {
        name: "SQL",
        case_insensitive: true,
        // does not include {} or HTML tags `</`
        illegal: /[{}]|<\//,
        keywords: {
          $pattern: /\b[\w\.]+/,
          keyword: reduceRelevancy(KEYWORDS, { when: (x) => x.length < 3 }),
          literal: LITERALS,
          type: TYPES,
          built_in: POSSIBLE_WITHOUT_PARENS
        },
        contains: [
          {
            scope: "type",
            match: kws_to_regex(MULTI_WORD_TYPES)
          },
          MULTI_WORD_KEYWORDS,
          FUNCTION_CALL,
          VARIABLE,
          STRING,
          QUOTED_IDENTIFIER,
          hljs.C_NUMBER_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          COMMENT_MODE,
          OPERATOR
        ]
      };
    }
    module.exports = sql;
  }
});

// node_modules/highlight.js/lib/languages/swift.js
var require_swift = __commonJS({
  "node_modules/highlight.js/lib/languages/swift.js"(exports, module) {
    function source(re) {
      if (!re) return null;
      if (typeof re === "string") return re;
      return re.source;
    }
    function lookahead(re) {
      return concat("(?=", re, ")");
    }
    function concat(...args) {
      const joined = args.map((x) => source(x)).join("");
      return joined;
    }
    function stripOptionsFromArgs(args) {
      const opts = args[args.length - 1];
      if (typeof opts === "object" && opts.constructor === Object) {
        args.splice(args.length - 1, 1);
        return opts;
      } else {
        return {};
      }
    }
    function either(...args) {
      const opts = stripOptionsFromArgs(args);
      const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source(x)).join("|") + ")";
      return joined;
    }
    var keywordWrapper = (keyword) => concat(
      /\b/,
      keyword,
      /\w$/.test(keyword) ? /\b/ : /\B/
    );
    var dotKeywords = [
      "Protocol",
      // contextual
      "Type"
      // contextual
    ].map(keywordWrapper);
    var optionalDotKeywords = [
      "init",
      "self"
    ].map(keywordWrapper);
    var keywordTypes = [
      "Any",
      "Self"
    ];
    var keywords = [
      // strings below will be fed into the regular `keywords` engine while regex
      // will result in additional modes being created to scan for those keywords to
      // avoid conflicts with other rules
      "actor",
      "any",
      // contextual
      "associatedtype",
      "async",
      "await",
      /as\?/,
      // operator
      /as!/,
      // operator
      "as",
      // operator
      "borrowing",
      // contextual
      "break",
      "case",
      "catch",
      "class",
      "consume",
      // contextual
      "consuming",
      // contextual
      "continue",
      "convenience",
      // contextual
      "copy",
      // contextual
      "default",
      "defer",
      "deinit",
      "didSet",
      // contextual
      "distributed",
      "do",
      "dynamic",
      // contextual
      "each",
      "else",
      "enum",
      "extension",
      "fallthrough",
      /fileprivate\(set\)/,
      "fileprivate",
      "final",
      // contextual
      "for",
      "func",
      "get",
      // contextual
      "guard",
      "if",
      "import",
      "indirect",
      // contextual
      "infix",
      // contextual
      /init\?/,
      /init!/,
      "inout",
      /internal\(set\)/,
      "internal",
      "in",
      "is",
      // operator
      "isolated",
      // contextual
      "nonisolated",
      // contextual
      "lazy",
      // contextual
      "let",
      "macro",
      "mutating",
      // contextual
      "nonmutating",
      // contextual
      /open\(set\)/,
      // contextual
      "open",
      // contextual
      "operator",
      "optional",
      // contextual
      "override",
      // contextual
      "package",
      "postfix",
      // contextual
      "precedencegroup",
      "prefix",
      // contextual
      /private\(set\)/,
      "private",
      "protocol",
      /public\(set\)/,
      "public",
      "repeat",
      "required",
      // contextual
      "rethrows",
      "return",
      "set",
      // contextual
      "some",
      // contextual
      "static",
      "struct",
      "subscript",
      "super",
      "switch",
      "throws",
      "throw",
      /try\?/,
      // operator
      /try!/,
      // operator
      "try",
      // operator
      "typealias",
      /unowned\(safe\)/,
      // contextual
      /unowned\(unsafe\)/,
      // contextual
      "unowned",
      // contextual
      "var",
      "weak",
      // contextual
      "where",
      "while",
      "willSet"
      // contextual
    ];
    var literals = [
      "false",
      "nil",
      "true"
    ];
    var precedencegroupKeywords = [
      "assignment",
      "associativity",
      "higherThan",
      "left",
      "lowerThan",
      "none",
      "right"
    ];
    var numberSignKeywords = [
      "#colorLiteral",
      "#column",
      "#dsohandle",
      "#else",
      "#elseif",
      "#endif",
      "#error",
      "#file",
      "#fileID",
      "#fileLiteral",
      "#filePath",
      "#function",
      "#if",
      "#imageLiteral",
      "#keyPath",
      "#line",
      "#selector",
      "#sourceLocation",
      "#warning"
    ];
    var builtIns = [
      "abs",
      "all",
      "any",
      "assert",
      "assertionFailure",
      "debugPrint",
      "dump",
      "fatalError",
      "getVaList",
      "isKnownUniquelyReferenced",
      "max",
      "min",
      "numericCast",
      "pointwiseMax",
      "pointwiseMin",
      "precondition",
      "preconditionFailure",
      "print",
      "readLine",
      "repeatElement",
      "sequence",
      "stride",
      "swap",
      "swift_unboxFromSwiftValueWithType",
      "transcode",
      "type",
      "unsafeBitCast",
      "unsafeDowncast",
      "withExtendedLifetime",
      "withUnsafeMutablePointer",
      "withUnsafePointer",
      "withVaList",
      "withoutActuallyEscaping",
      "zip"
    ];
    var operatorHead = either(
      /[/=\-+!*%<>&|^~?]/,
      /[\u00A1-\u00A7]/,
      /[\u00A9\u00AB]/,
      /[\u00AC\u00AE]/,
      /[\u00B0\u00B1]/,
      /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
      /[\u2016-\u2017]/,
      /[\u2020-\u2027]/,
      /[\u2030-\u203E]/,
      /[\u2041-\u2053]/,
      /[\u2055-\u205E]/,
      /[\u2190-\u23FF]/,
      /[\u2500-\u2775]/,
      /[\u2794-\u2BFF]/,
      /[\u2E00-\u2E7F]/,
      /[\u3001-\u3003]/,
      /[\u3008-\u3020]/,
      /[\u3030]/
    );
    var operatorCharacter = either(
      operatorHead,
      /[\u0300-\u036F]/,
      /[\u1DC0-\u1DFF]/,
      /[\u20D0-\u20FF]/,
      /[\uFE00-\uFE0F]/,
      /[\uFE20-\uFE2F]/
      // TODO: The following characters are also allowed, but the regex isn't supported yet.
      // /[\u{E0100}-\u{E01EF}]/u
    );
    var operator = concat(operatorHead, operatorCharacter, "*");
    var identifierHead = either(
      /[a-zA-Z_]/,
      /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
      /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
      /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
      /[\u1E00-\u1FFF]/,
      /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
      /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
      /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
      /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
      /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
      /[\uFE47-\uFEFE\uFF00-\uFFFD]/
      // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
      // The following characters are also allowed, but the regexes aren't supported yet.
      // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
      // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
      // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
      // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
    );
    var identifierCharacter = either(
      identifierHead,
      /\d/,
      /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
    );
    var identifier = concat(identifierHead, identifierCharacter, "*");
    var typeIdentifier = concat(/[A-Z]/, identifierCharacter, "*");
    var keywordAttributes = [
      "attached",
      "autoclosure",
      concat(/convention\(/, either("swift", "block", "c"), /\)/),
      "discardableResult",
      "dynamicCallable",
      "dynamicMemberLookup",
      "escaping",
      "freestanding",
      "frozen",
      "GKInspectable",
      "IBAction",
      "IBDesignable",
      "IBInspectable",
      "IBOutlet",
      "IBSegueAction",
      "inlinable",
      "main",
      "nonobjc",
      "NSApplicationMain",
      "NSCopying",
      "NSManaged",
      concat(/objc\(/, identifier, /\)/),
      "objc",
      "objcMembers",
      "propertyWrapper",
      "requires_stored_property_inits",
      "resultBuilder",
      "Sendable",
      "testable",
      "UIApplicationMain",
      "unchecked",
      "unknown",
      "usableFromInline",
      "warn_unqualified_access"
    ];
    var availabilityKeywords = [
      "iOS",
      "iOSApplicationExtension",
      "macOS",
      "macOSApplicationExtension",
      "macCatalyst",
      "macCatalystApplicationExtension",
      "watchOS",
      "watchOSApplicationExtension",
      "tvOS",
      "tvOSApplicationExtension",
      "swift"
    ];
    function swift(hljs) {
      const WHITESPACE = {
        match: /\s+/,
        relevance: 0
      };
      const BLOCK_COMMENT = hljs.COMMENT(
        "/\\*",
        "\\*/",
        { contains: ["self"] }
      );
      const COMMENTS = [
        hljs.C_LINE_COMMENT_MODE,
        BLOCK_COMMENT
      ];
      const DOT_KEYWORD = {
        match: [
          /\./,
          either(...dotKeywords, ...optionalDotKeywords)
        ],
        className: { 2: "keyword" }
      };
      const KEYWORD_GUARD = {
        // Consume .keyword to prevent highlighting properties and methods as keywords.
        match: concat(/\./, either(...keywords)),
        relevance: 0
      };
      const PLAIN_KEYWORDS = keywords.filter((kw) => typeof kw === "string").concat(["_|0"]);
      const REGEX_KEYWORDS = keywords.filter((kw) => typeof kw !== "string").concat(keywordTypes).map(keywordWrapper);
      const KEYWORD = { variants: [
        {
          className: "keyword",
          match: either(...REGEX_KEYWORDS, ...optionalDotKeywords)
        }
      ] };
      const KEYWORDS = {
        $pattern: either(
          /\b\w+/,
          // regular keywords
          /#\w+/
          // number keywords
        ),
        keyword: PLAIN_KEYWORDS.concat(numberSignKeywords),
        literal: literals
      };
      const KEYWORD_MODES = [
        DOT_KEYWORD,
        KEYWORD_GUARD,
        KEYWORD
      ];
      const BUILT_IN_GUARD = {
        // Consume .built_in to prevent highlighting properties and methods.
        match: concat(/\./, either(...builtIns)),
        relevance: 0
      };
      const BUILT_IN = {
        className: "built_in",
        match: concat(/\b/, either(...builtIns), /(?=\()/)
      };
      const BUILT_INS = [
        BUILT_IN_GUARD,
        BUILT_IN
      ];
      const OPERATOR_GUARD = {
        // Prevent -> from being highlighting as an operator.
        match: /->/,
        relevance: 0
      };
      const OPERATOR = {
        className: "operator",
        relevance: 0,
        variants: [
          { match: operator },
          {
            // dot-operator: only operators that start with a dot are allowed to use dots as
            // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
            // characters that may also include dots.
            match: `\\.(\\.|${operatorCharacter})+`
          }
        ]
      };
      const OPERATORS = [
        OPERATOR_GUARD,
        OPERATOR
      ];
      const decimalDigits = "([0-9]_*)+";
      const hexDigits = "([0-9a-fA-F]_*)+";
      const NUMBER = {
        className: "number",
        relevance: 0,
        variants: [
          // decimal floating-point-literal (subsumes decimal-literal)
          { match: `\\b(${decimalDigits})(\\.(${decimalDigits}))?([eE][+-]?(${decimalDigits}))?\\b` },
          // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
          { match: `\\b0x(${hexDigits})(\\.(${hexDigits}))?([pP][+-]?(${decimalDigits}))?\\b` },
          // octal-literal
          { match: /\b0o([0-7]_*)+\b/ },
          // binary-literal
          { match: /\b0b([01]_*)+\b/ }
        ]
      };
      const ESCAPED_CHARACTER = (rawDelimiter = "") => ({
        className: "subst",
        variants: [
          { match: concat(/\\/, rawDelimiter, /[0\\tnr"']/) },
          { match: concat(/\\/, rawDelimiter, /u\{[0-9a-fA-F]{1,8}\}/) }
        ]
      });
      const ESCAPED_NEWLINE = (rawDelimiter = "") => ({
        className: "subst",
        match: concat(/\\/, rawDelimiter, /[\t ]*(?:[\r\n]|\r\n)/)
      });
      const INTERPOLATION = (rawDelimiter = "") => ({
        className: "subst",
        label: "interpol",
        begin: concat(/\\/, rawDelimiter, /\(/),
        end: /\)/
      });
      const MULTILINE_STRING = (rawDelimiter = "") => ({
        begin: concat(rawDelimiter, /"""/),
        end: concat(/"""/, rawDelimiter),
        contains: [
          ESCAPED_CHARACTER(rawDelimiter),
          ESCAPED_NEWLINE(rawDelimiter),
          INTERPOLATION(rawDelimiter)
        ]
      });
      const SINGLE_LINE_STRING = (rawDelimiter = "") => ({
        begin: concat(rawDelimiter, /"/),
        end: concat(/"/, rawDelimiter),
        contains: [
          ESCAPED_CHARACTER(rawDelimiter),
          INTERPOLATION(rawDelimiter)
        ]
      });
      const STRING = {
        className: "string",
        variants: [
          MULTILINE_STRING(),
          MULTILINE_STRING("#"),
          MULTILINE_STRING("##"),
          MULTILINE_STRING("###"),
          SINGLE_LINE_STRING(),
          SINGLE_LINE_STRING("#"),
          SINGLE_LINE_STRING("##"),
          SINGLE_LINE_STRING("###")
        ]
      };
      const REGEXP_CONTENTS = [
        hljs.BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [hljs.BACKSLASH_ESCAPE]
        }
      ];
      const BARE_REGEXP_LITERAL = {
        begin: /\/[^\s](?=[^/\n]*\/)/,
        end: /\//,
        contains: REGEXP_CONTENTS
      };
      const EXTENDED_REGEXP_LITERAL = (rawDelimiter) => {
        const begin = concat(rawDelimiter, /\//);
        const end = concat(/\//, rawDelimiter);
        return {
          begin,
          end,
          contains: [
            ...REGEXP_CONTENTS,
            {
              scope: "comment",
              begin: `#(?!.*${end})`,
              end: /$/
            }
          ]
        };
      };
      const REGEXP = {
        scope: "regexp",
        variants: [
          EXTENDED_REGEXP_LITERAL("###"),
          EXTENDED_REGEXP_LITERAL("##"),
          EXTENDED_REGEXP_LITERAL("#"),
          BARE_REGEXP_LITERAL
        ]
      };
      const QUOTED_IDENTIFIER = { match: concat(/`/, identifier, /`/) };
      const IMPLICIT_PARAMETER = {
        className: "variable",
        match: /\$\d+/
      };
      const PROPERTY_WRAPPER_PROJECTION = {
        className: "variable",
        match: `\\$${identifierCharacter}+`
      };
      const IDENTIFIERS = [
        QUOTED_IDENTIFIER,
        IMPLICIT_PARAMETER,
        PROPERTY_WRAPPER_PROJECTION
      ];
      const AVAILABLE_ATTRIBUTE = {
        match: /(@|#(un)?)available/,
        scope: "keyword",
        starts: { contains: [
          {
            begin: /\(/,
            end: /\)/,
            keywords: availabilityKeywords,
            contains: [
              ...OPERATORS,
              NUMBER,
              STRING
            ]
          }
        ] }
      };
      const KEYWORD_ATTRIBUTE = {
        scope: "keyword",
        match: concat(/@/, either(...keywordAttributes), lookahead(either(/\(/, /\s+/)))
      };
      const USER_DEFINED_ATTRIBUTE = {
        scope: "meta",
        match: concat(/@/, identifier)
      };
      const ATTRIBUTES = [
        AVAILABLE_ATTRIBUTE,
        KEYWORD_ATTRIBUTE,
        USER_DEFINED_ATTRIBUTE
      ];
      const TYPE = {
        match: lookahead(/\b[A-Z]/),
        relevance: 0,
        contains: [
          {
            // Common Apple frameworks, for relevance boost
            className: "type",
            match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, "+")
          },
          {
            // Type identifier
            className: "type",
            match: typeIdentifier,
            relevance: 0
          },
          {
            // Optional type
            match: /[?!]+/,
            relevance: 0
          },
          {
            // Variadic parameter
            match: /\.\.\./,
            relevance: 0
          },
          {
            // Protocol composition
            match: concat(/\s+&\s+/, lookahead(typeIdentifier)),
            relevance: 0
          }
        ]
      };
      const GENERIC_ARGUMENTS = {
        begin: /</,
        end: />/,
        keywords: KEYWORDS,
        contains: [
          ...COMMENTS,
          ...KEYWORD_MODES,
          ...ATTRIBUTES,
          OPERATOR_GUARD,
          TYPE
        ]
      };
      TYPE.contains.push(GENERIC_ARGUMENTS);
      const TUPLE_ELEMENT_NAME = {
        match: concat(identifier, /\s*:/),
        keywords: "_|0",
        relevance: 0
      };
      const TUPLE = {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        keywords: KEYWORDS,
        contains: [
          "self",
          TUPLE_ELEMENT_NAME,
          ...COMMENTS,
          REGEXP,
          ...KEYWORD_MODES,
          ...BUILT_INS,
          ...OPERATORS,
          NUMBER,
          STRING,
          ...IDENTIFIERS,
          ...ATTRIBUTES,
          TYPE
        ]
      };
      const GENERIC_PARAMETERS = {
        begin: /</,
        end: />/,
        keywords: "repeat each",
        contains: [
          ...COMMENTS,
          TYPE
        ]
      };
      const FUNCTION_PARAMETER_NAME = {
        begin: either(
          lookahead(concat(identifier, /\s*:/)),
          lookahead(concat(identifier, /\s+/, identifier, /\s*:/))
        ),
        end: /:/,
        relevance: 0,
        contains: [
          {
            className: "keyword",
            match: /\b_\b/
          },
          {
            className: "params",
            match: identifier
          }
        ]
      };
      const FUNCTION_PARAMETERS = {
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS,
        contains: [
          FUNCTION_PARAMETER_NAME,
          ...COMMENTS,
          ...KEYWORD_MODES,
          ...OPERATORS,
          NUMBER,
          STRING,
          ...ATTRIBUTES,
          TYPE,
          TUPLE
        ],
        endsParent: true,
        illegal: /["']/
      };
      const FUNCTION_OR_MACRO = {
        match: [
          /(func|macro)/,
          /\s+/,
          either(QUOTED_IDENTIFIER.match, identifier, operator)
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          GENERIC_PARAMETERS,
          FUNCTION_PARAMETERS,
          WHITESPACE
        ],
        illegal: [
          /\[/,
          /%/
        ]
      };
      const INIT_SUBSCRIPT = {
        match: [
          /\b(?:subscript|init[?!]?)/,
          /\s*(?=[<(])/
        ],
        className: { 1: "keyword" },
        contains: [
          GENERIC_PARAMETERS,
          FUNCTION_PARAMETERS,
          WHITESPACE
        ],
        illegal: /\[|%/
      };
      const OPERATOR_DECLARATION = {
        match: [
          /operator/,
          /\s+/,
          operator
        ],
        className: {
          1: "keyword",
          3: "title"
        }
      };
      const PRECEDENCEGROUP = {
        begin: [
          /precedencegroup/,
          /\s+/,
          typeIdentifier
        ],
        className: {
          1: "keyword",
          3: "title"
        },
        contains: [TYPE],
        keywords: [
          ...precedencegroupKeywords,
          ...literals
        ],
        end: /}/
      };
      const CLASS_FUNC_DECLARATION = {
        match: [
          /class\b/,
          /\s+/,
          /func\b/,
          /\s+/,
          /\b[A-Za-z_][A-Za-z0-9_]*\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword",
          5: "title.function"
        }
      };
      const CLASS_VAR_DECLARATION = {
        match: [
          /class\b/,
          /\s+/,
          /var\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword"
        }
      };
      const TYPE_DECLARATION = {
        begin: [
          /(struct|protocol|class|extension|enum|actor)/,
          /\s+/,
          identifier,
          /\s*/
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        },
        keywords: KEYWORDS,
        contains: [
          GENERIC_PARAMETERS,
          ...KEYWORD_MODES,
          {
            begin: /:/,
            end: /\{/,
            keywords: KEYWORDS,
            contains: [
              {
                scope: "title.class.inherited",
                match: typeIdentifier
              },
              ...KEYWORD_MODES
            ],
            relevance: 0
          }
        ]
      };
      for (const variant of STRING.variants) {
        const interpolation = variant.contains.find((mode) => mode.label === "interpol");
        interpolation.keywords = KEYWORDS;
        const submodes = [
          ...KEYWORD_MODES,
          ...BUILT_INS,
          ...OPERATORS,
          NUMBER,
          STRING,
          ...IDENTIFIERS
        ];
        interpolation.contains = [
          ...submodes,
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              "self",
              ...submodes
            ]
          }
        ];
      }
      return {
        name: "Swift",
        keywords: KEYWORDS,
        contains: [
          ...COMMENTS,
          FUNCTION_OR_MACRO,
          INIT_SUBSCRIPT,
          CLASS_FUNC_DECLARATION,
          CLASS_VAR_DECLARATION,
          TYPE_DECLARATION,
          OPERATOR_DECLARATION,
          PRECEDENCEGROUP,
          {
            beginKeywords: "import",
            end: /$/,
            contains: [...COMMENTS],
            relevance: 0
          },
          REGEXP,
          ...KEYWORD_MODES,
          ...BUILT_INS,
          ...OPERATORS,
          NUMBER,
          STRING,
          ...IDENTIFIERS,
          ...ATTRIBUTES,
          TYPE,
          TUPLE
        ]
      };
    }
    module.exports = swift;
  }
});

// node_modules/highlight.js/lib/languages/yaml.js
var require_yaml = __commonJS({
  "node_modules/highlight.js/lib/languages/yaml.js"(exports, module) {
    function yaml(hljs) {
      const LITERALS = "true false yes no null";
      const URI_CHARACTERS = "[\\w#;/?:@&=+$,.~*'()[\\]]+";
      const KEY = {
        className: "attr",
        variants: [
          // added brackets support and special char support
          { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
          {
            // double quoted keys - with brackets and special char support
            begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/
          },
          {
            // single quoted keys - with brackets and special char support
            begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/
          }
        ]
      };
      const TEMPLATE_VARIABLES = {
        className: "template-variable",
        variants: [
          {
            // jinja templates Ansible
            begin: /\{\{/,
            end: /\}\}/
          },
          {
            // Ruby i18n
            begin: /%\{/,
            end: /\}/
          }
        ]
      };
      const SINGLE_QUOTE_STRING = {
        className: "string",
        relevance: 0,
        begin: /'/,
        end: /'/,
        contains: [
          {
            match: /''/,
            scope: "char.escape",
            relevance: 0
          }
        ]
      };
      const STRING = {
        className: "string",
        relevance: 0,
        variants: [
          {
            begin: /"/,
            end: /"/
          },
          { begin: /\S+/ }
        ],
        contains: [
          hljs.BACKSLASH_ESCAPE,
          TEMPLATE_VARIABLES
        ]
      };
      const CONTAINER_STRING = hljs.inherit(STRING, { variants: [
        {
          begin: /'/,
          end: /'/,
          contains: [
            {
              begin: /''/,
              relevance: 0
            }
          ]
        },
        {
          begin: /"/,
          end: /"/
        },
        { begin: /[^\s,{}[\]]+/ }
      ] });
      const DATE_RE = "[0-9]{4}(-[0-9][0-9]){0,2}";
      const TIME_RE = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?";
      const FRACTION_RE = "(\\.[0-9]*)?";
      const ZONE_RE = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?";
      const TIMESTAMP = {
        className: "number",
        begin: "\\b" + DATE_RE + TIME_RE + FRACTION_RE + ZONE_RE + "\\b"
      };
      const VALUE_CONTAINER = {
        end: ",",
        endsWithParent: true,
        excludeEnd: true,
        keywords: LITERALS,
        relevance: 0
      };
      const OBJECT = {
        begin: /\{/,
        end: /\}/,
        contains: [VALUE_CONTAINER],
        illegal: "\\n",
        relevance: 0
      };
      const ARRAY = {
        begin: "\\[",
        end: "\\]",
        contains: [VALUE_CONTAINER],
        illegal: "\\n",
        relevance: 0
      };
      const MODES = [
        KEY,
        {
          className: "meta",
          begin: "^---\\s*$",
          relevance: 10
        },
        {
          // multi line string
          // Blocks start with a | or > followed by a newline
          //
          // Indentation of subsequent lines must be the same to
          // be considered part of the block
          className: "string",
          begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
        },
        {
          // Ruby/Rails erb
          begin: "<%[%=-]?",
          end: "[%-]?%>",
          subLanguage: "ruby",
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0
        },
        {
          // named tags
          className: "type",
          begin: "!\\w+!" + URI_CHARACTERS
        },
        // https://yaml.org/spec/1.2/spec.html#id2784064
        {
          // verbatim tags
          className: "type",
          begin: "!<" + URI_CHARACTERS + ">"
        },
        {
          // primary tags
          className: "type",
          begin: "!" + URI_CHARACTERS
        },
        {
          // secondary tags
          className: "type",
          begin: "!!" + URI_CHARACTERS
        },
        {
          // fragment id &ref
          className: "meta",
          begin: "&" + hljs.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // fragment reference *ref
          className: "meta",
          begin: "\\*" + hljs.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // array listing
          className: "bullet",
          // TODO: remove |$ hack when we have proper look-ahead support
          begin: "-(?=[ ]|$)",
          relevance: 0
        },
        hljs.HASH_COMMENT_MODE,
        {
          beginKeywords: LITERALS,
          keywords: { literal: LITERALS }
        },
        TIMESTAMP,
        // numbers are any valid C-style number that
        // sit isolated from other words
        {
          className: "number",
          begin: hljs.C_NUMBER_RE + "\\b",
          relevance: 0
        },
        OBJECT,
        ARRAY,
        SINGLE_QUOTE_STRING,
        STRING
      ];
      const VALUE_MODES = [...MODES];
      VALUE_MODES.pop();
      VALUE_MODES.push(CONTAINER_STRING);
      VALUE_CONTAINER.contains = VALUE_MODES;
      return {
        name: "YAML",
        case_insensitive: true,
        aliases: ["yml"],
        contains: MODES
      };
    }
    module.exports = yaml;
  }
});

// node_modules/highlight.js/lib/languages/typescript.js
var require_typescript = __commonJS({
  "node_modules/highlight.js/lib/languages/typescript.js"(exports, module) {
    var IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
    var KEYWORDS = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      // It's reached stage 3, which is "recommended for implementation":
      "using"
    ];
    var LITERALS = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ];
    var TYPES = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ];
    var ERROR_TYPES = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ];
    var BUILT_IN_GLOBALS = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ];
    var BUILT_IN_VARIABLES = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ];
    var BUILT_INS = [].concat(
      BUILT_IN_GLOBALS,
      TYPES,
      ERROR_TYPES
    );
    function javascript(hljs) {
      const regex = hljs.regex;
      const hasClosingTag = (match, { after }) => {
        const tag = "</" + match[0].slice(1);
        const pos = match.input.indexOf(tag, after);
        return pos !== -1;
      };
      const IDENT_RE$1 = IDENT_RE;
      const FRAGMENT = {
        begin: "<>",
        end: "</>"
      };
      const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
      const XML_TAG = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (match, response) => {
          const afterMatchIndex = match[0].length + match.index;
          const nextChar = match.input[afterMatchIndex];
          if (
            // HTML should not include another raw `<` inside a tag
            // nested type?
            // `<Array<Array<number>>`, etc.
            nextChar === "<" || // the , gives away that this is not HTML
            // `<T, A extends keyof T, V>`
            nextChar === ","
          ) {
            response.ignoreMatch();
            return;
          }
          if (nextChar === ">") {
            if (!hasClosingTag(match, { after: afterMatchIndex })) {
              response.ignoreMatch();
            }
          }
          let m;
          const afterMatch = match.input.substring(afterMatchIndex);
          if (m = afterMatch.match(/^\s*=/)) {
            response.ignoreMatch();
            return;
          }
          if (m = afterMatch.match(/^\s+extends\s+/)) {
            if (m.index === 0) {
              response.ignoreMatch();
              return;
            }
          }
        }
      };
      const KEYWORDS$1 = {
        $pattern: IDENT_RE,
        keyword: KEYWORDS,
        literal: LITERALS,
        built_in: BUILT_INS,
        "variable.language": BUILT_IN_VARIABLES
      };
      const decimalDigits = "[0-9](_?[0-9])*";
      const frac = `\\.(${decimalDigits})`;
      const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
      const NUMBER = {
        className: "number",
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
          { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
          // DecimalBigIntegerLiteral
          { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      };
      const SUBST = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: KEYWORDS$1,
        contains: []
        // defined later
      };
      const HTML_TEMPLATE = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "xml"
        }
      };
      const CSS_TEMPLATE = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "css"
        }
      };
      const GRAPHQL_TEMPLATE = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "graphql"
        }
      };
      const TEMPLATE_STRING = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ]
      };
      const JSDOC_COMMENT = hljs.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: true,
                  excludeBegin: true,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
                  endsParent: true,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      );
      const COMMENT = {
        className: "comment",
        variants: [
          JSDOC_COMMENT,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.C_LINE_COMMENT_MODE
        ]
      };
      const SUBST_INTERNALS = [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        GRAPHQL_TEMPLATE,
        TEMPLATE_STRING,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        NUMBER
        // This is intentional:
        // See https://github.com/highlightjs/highlight.js/issues/3288
        // hljs.REGEXP_MODE
      ];
      SUBST.contains = SUBST_INTERNALS.concat({
        // we need to pair up {} inside our subst to prevent
        // it from ending too early by matching another }
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS$1,
        contains: [
          "self"
        ].concat(SUBST_INTERNALS)
      });
      const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
      const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
        // eat recursive parens in sub expressions
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: KEYWORDS$1,
          contains: ["self"].concat(SUBST_AND_COMMENTS)
        }
      ]);
      const PARAMS = {
        className: "params",
        // convert this to negative lookbehind in v12
        begin: /(\s*)\(/,
        // to match the parms with
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS$1,
        contains: PARAMS_CONTAINS
      };
      const CLASS_OR_EXTENDS = {
        variants: [
          // class Car extends vehicle
          {
            match: [
              /class/,
              /\s+/,
              IDENT_RE$1,
              /\s+/,
              /extends/,
              /\s+/,
              regex.concat(IDENT_RE$1, "(", regex.concat(/\./, IDENT_RE$1), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          // class Car
          {
            match: [
              /class/,
              /\s+/,
              IDENT_RE$1
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      };
      const CLASS_REFERENCE = {
        relevance: 0,
        match: regex.either(
          // Hard coded exceptions
          /\bJSON/,
          // Float32Array, OutT
          /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
          // CSSFactory, CSSFactoryT
          /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
          // FPs, FPsT
          /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
          // P
          // single letters are not highlighted
          // BLAH
          // this will be flagged as a UPPER_CASE_CONSTANT instead
        ),
        className: "title.class",
        keywords: {
          _: [
            // se we still get relevance credit for JS library classes
            ...TYPES,
            ...ERROR_TYPES
          ]
        }
      };
      const USE_STRICT = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      };
      const FUNCTION_DEFINITION = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              IDENT_RE$1,
              /(?=\s*\()/
            ]
          },
          // anonymous function
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [PARAMS],
        illegal: /%/
      };
      const UPPER_CASE_CONSTANT = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function noneOf(list) {
        return regex.concat("(?!", list.join("|"), ")");
      }
      const FUNCTION_CALL = {
        match: regex.concat(
          /\b/,
          noneOf([
            ...BUILT_IN_GLOBALS,
            "super",
            "import"
          ].map((x) => `${x}\\s*\\(`)),
          IDENT_RE$1,
          regex.lookahead(/\s*\(/)
        ),
        className: "title.function",
        relevance: 0
      };
      const PROPERTY_ACCESS = {
        begin: regex.concat(/\./, regex.lookahead(
          regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)
        )),
        end: IDENT_RE$1,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      };
      const GETTER_OR_SETTER = {
        match: [
          /get|set/,
          /\s+/,
          IDENT_RE$1,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            // eat to avoid empty params
            begin: /\(\)/
          },
          PARAMS
        ]
      };
      const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
      const FUNCTION_VARIABLE = {
        match: [
          /const|var|let/,
          /\s+/,
          IDENT_RE$1,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          // async is optional
          regex.lookahead(FUNC_LEAD_IN_RE)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          PARAMS
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: KEYWORDS$1,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
        illegal: /#(?![$_A-z])/,
        contains: [
          hljs.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          USE_STRICT,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          HTML_TEMPLATE,
          CSS_TEMPLATE,
          GRAPHQL_TEMPLATE,
          TEMPLATE_STRING,
          COMMENT,
          // Skip numbers when they are part of a variable name
          { match: /\$\d+/ },
          NUMBER,
          CLASS_REFERENCE,
          {
            scope: "attr",
            match: IDENT_RE$1 + regex.lookahead(":"),
            relevance: 0
          },
          FUNCTION_VARIABLE,
          {
            // "value" container
            begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              COMMENT,
              hljs.REGEXP_MODE,
              {
                className: "function",
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: FUNC_LEAD_IN_RE,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: hljs.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: KEYWORDS$1,
                        contains: PARAMS_CONTAINS
                      }
                    ]
                  }
                ]
              },
              {
                // could be a comma delimited list of params to a function call
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                // JSX
                variants: [
                  { begin: FRAGMENT.begin, end: FRAGMENT.end },
                  { match: XML_SELF_CLOSING },
                  {
                    begin: XML_TAG.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    "on:begin": XML_TAG.isTrulyOpeningTag,
                    end: XML_TAG.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: XML_TAG.begin,
                    end: XML_TAG.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          FUNCTION_DEFINITION,
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            // end parens
            returnBegin: true,
            label: "func.def",
            contains: [
              PARAMS,
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })
            ]
          },
          // catch ... so it won't trigger the property rule below
          {
            match: /\.\.\./,
            relevance: 0
          },
          PROPERTY_ACCESS,
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            match: "\\$" + IDENT_RE$1,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [PARAMS]
          },
          FUNCTION_CALL,
          UPPER_CASE_CONSTANT,
          CLASS_OR_EXTENDS,
          GETTER_OR_SETTER,
          {
            match: /\$[(.]/
            // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }
    function typescript(hljs) {
      const regex = hljs.regex;
      const tsLanguage = javascript(hljs);
      const IDENT_RE$1 = IDENT_RE;
      const TYPES2 = [
        "any",
        "void",
        "number",
        "boolean",
        "string",
        "object",
        "never",
        "symbol",
        "bigint",
        "unknown"
      ];
      const NAMESPACE = {
        begin: [
          /namespace/,
          /\s+/,
          hljs.IDENT_RE
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        }
      };
      const INTERFACE = {
        beginKeywords: "interface",
        end: /\{/,
        excludeEnd: true,
        keywords: {
          keyword: "interface extends",
          built_in: TYPES2
        },
        contains: [tsLanguage.exports.CLASS_REFERENCE]
      };
      const USE_STRICT = {
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use strict['"]/
      };
      const TS_SPECIFIC_KEYWORDS = [
        "type",
        // "namespace",
        "interface",
        "public",
        "private",
        "protected",
        "implements",
        "declare",
        "abstract",
        "readonly",
        "enum",
        "override",
        "satisfies"
      ];
      const KEYWORDS$1 = {
        $pattern: IDENT_RE,
        keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS),
        literal: LITERALS,
        built_in: BUILT_INS.concat(TYPES2),
        "variable.language": BUILT_IN_VARIABLES
      };
      const DECORATOR = {
        className: "meta",
        begin: "@" + IDENT_RE$1
      };
      const swapMode = (mode, label, replacement) => {
        const indx = mode.contains.findIndex((m) => m.label === label);
        if (indx === -1) {
          throw new Error("can not find mode to replace");
        }
        mode.contains.splice(indx, 1, replacement);
      };
      Object.assign(tsLanguage.keywords, KEYWORDS$1);
      tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
      const ATTRIBUTE_HIGHLIGHT = tsLanguage.contains.find((c) => c.scope === "attr");
      const OPTIONAL_KEY_OR_ARGUMENT = Object.assign(
        {},
        ATTRIBUTE_HIGHLIGHT,
        { match: regex.concat(IDENT_RE$1, regex.lookahead(/\s*\?:/)) }
      );
      tsLanguage.exports.PARAMS_CONTAINS.push([
        tsLanguage.exports.CLASS_REFERENCE,
        // class reference for highlighting the params types
        ATTRIBUTE_HIGHLIGHT,
        // highlight the params key
        OPTIONAL_KEY_OR_ARGUMENT
        // Added for optional property assignment highlighting
      ]);
      tsLanguage.contains = tsLanguage.contains.concat([
        DECORATOR,
        NAMESPACE,
        INTERFACE,
        OPTIONAL_KEY_OR_ARGUMENT
        // Added for optional property assignment highlighting
      ]);
      swapMode(tsLanguage, "shebang", hljs.SHEBANG());
      swapMode(tsLanguage, "use_strict", USE_STRICT);
      const functionDeclaration = tsLanguage.contains.find((m) => m.label === "func.def");
      functionDeclaration.relevance = 0;
      Object.assign(tsLanguage, {
        name: "TypeScript",
        aliases: [
          "ts",
          "tsx",
          "mts",
          "cts"
        ]
      });
      return tsLanguage;
    }
    module.exports = typescript;
  }
});

// node_modules/highlight.js/lib/languages/vbnet.js
var require_vbnet = __commonJS({
  "node_modules/highlight.js/lib/languages/vbnet.js"(exports, module) {
    function vbnet(hljs) {
      const regex = hljs.regex;
      const CHARACTER = {
        className: "string",
        begin: /"(""|[^/n])"C\b/
      };
      const STRING = {
        className: "string",
        begin: /"/,
        end: /"/,
        illegal: /\n/,
        contains: [
          {
            // double quote escape
            begin: /""/
          }
        ]
      };
      const MM_DD_YYYY = /\d{1,2}\/\d{1,2}\/\d{4}/;
      const YYYY_MM_DD = /\d{4}-\d{1,2}-\d{1,2}/;
      const TIME_12H = /(\d|1[012])(:\d+){0,2} *(AM|PM)/;
      const TIME_24H = /\d{1,2}(:\d{1,2}){1,2}/;
      const DATE = {
        className: "literal",
        variants: [
          {
            // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
            begin: regex.concat(/# */, regex.either(YYYY_MM_DD, MM_DD_YYYY), / *#/)
          },
          {
            // #H:mm[:ss]# (24h Time)
            begin: regex.concat(/# */, TIME_24H, / *#/)
          },
          {
            // #h[:mm[:ss]] A# (12h Time)
            begin: regex.concat(/# */, TIME_12H, / *#/)
          },
          {
            // date plus time
            begin: regex.concat(
              /# */,
              regex.either(YYYY_MM_DD, MM_DD_YYYY),
              / +/,
              regex.either(TIME_12H, TIME_24H),
              / *#/
            )
          }
        ]
      };
      const NUMBER = {
        className: "number",
        relevance: 0,
        variants: [
          {
            // Float
            begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
          },
          {
            // Integer (base 10)
            begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 16)
            begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 8)
            begin: /&O[0-7_]+((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 2)
            begin: /&B[01_]+((U?[SIL])|[%&])?/
          }
        ]
      };
      const LABEL = {
        className: "label",
        begin: /^\w+:/
      };
      const DOC_COMMENT = hljs.COMMENT(/'''/, /$/, { contains: [
        {
          className: "doctag",
          begin: /<\/?/,
          end: />/
        }
      ] });
      const COMMENT = hljs.COMMENT(null, /$/, { variants: [
        { begin: /'/ },
        {
          // TODO: Use multi-class for leading spaces
          begin: /([\t ]|^)REM(?=\s)/
        }
      ] });
      const DIRECTIVES = {
        className: "meta",
        // TODO: Use multi-class for indentation once available
        begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
        end: /$/,
        keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
        contains: [COMMENT]
      };
      return {
        name: "Visual Basic .NET",
        aliases: ["vb"],
        case_insensitive: true,
        classNameAliases: { label: "symbol" },
        keywords: {
          keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
          built_in: (
            // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
            "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
          ),
          type: (
            // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
            "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
          ),
          literal: "true false nothing"
        },
        illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
        contains: [
          CHARACTER,
          STRING,
          DATE,
          NUMBER,
          LABEL,
          DOC_COMMENT,
          COMMENT,
          DIRECTIVES
        ]
      };
    }
    module.exports = vbnet;
  }
});

// node_modules/highlight.js/lib/languages/wasm.js
var require_wasm = __commonJS({
  "node_modules/highlight.js/lib/languages/wasm.js"(exports, module) {
    function wasm(hljs) {
      hljs.regex;
      const BLOCK_COMMENT = hljs.COMMENT(/\(;/, /;\)/);
      BLOCK_COMMENT.contains.push("self");
      const LINE_COMMENT = hljs.COMMENT(/;;/, /$/);
      const KWS = [
        "anyfunc",
        "block",
        "br",
        "br_if",
        "br_table",
        "call",
        "call_indirect",
        "data",
        "drop",
        "elem",
        "else",
        "end",
        "export",
        "func",
        "global.get",
        "global.set",
        "local.get",
        "local.set",
        "local.tee",
        "get_global",
        "get_local",
        "global",
        "if",
        "import",
        "local",
        "loop",
        "memory",
        "memory.grow",
        "memory.size",
        "module",
        "mut",
        "nop",
        "offset",
        "param",
        "result",
        "return",
        "select",
        "set_global",
        "set_local",
        "start",
        "table",
        "tee_local",
        "then",
        "type",
        "unreachable"
      ];
      const FUNCTION_REFERENCE = {
        begin: [
          /(?:func|call|call_indirect)/,
          /\s+/,
          /\$[^\s)]+/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      };
      const ARGUMENT = {
        className: "variable",
        begin: /\$[\w_]+/
      };
      const PARENS = {
        match: /(\((?!;)|\))+/,
        className: "punctuation",
        relevance: 0
      };
      const NUMBER = {
        className: "number",
        relevance: 0,
        // borrowed from Prism, TODO: split out into variants
        match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
      };
      const TYPE = {
        // look-ahead prevents us from gobbling up opcodes
        match: /(i32|i64|f32|f64)(?!\.)/,
        className: "type"
      };
      const MATH_OPERATIONS = {
        className: "keyword",
        // borrowed from Prism, TODO: split out into variants
        match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
      };
      const OFFSET_ALIGN = {
        match: [
          /(?:offset|align)/,
          /\s*/,
          /=/
        ],
        className: {
          1: "keyword",
          3: "operator"
        }
      };
      return {
        name: "WebAssembly",
        keywords: {
          $pattern: /[\w.]+/,
          keyword: KWS
        },
        contains: [
          LINE_COMMENT,
          BLOCK_COMMENT,
          OFFSET_ALIGN,
          ARGUMENT,
          PARENS,
          FUNCTION_REFERENCE,
          hljs.QUOTE_STRING_MODE,
          TYPE,
          MATH_OPERATIONS,
          NUMBER
        ]
      };
    }
    module.exports = wasm;
  }
});

// node_modules/highlight.js/lib/common.js
var require_common = __commonJS({
  "node_modules/highlight.js/lib/common.js"(exports, module) {
    var hljs = require_core();
    hljs.registerLanguage("xml", require_xml());
    hljs.registerLanguage("bash", require_bash());
    hljs.registerLanguage("c", require_c());
    hljs.registerLanguage("cpp", require_cpp());
    hljs.registerLanguage("csharp", require_csharp());
    hljs.registerLanguage("css", require_css());
    hljs.registerLanguage("markdown", require_markdown());
    hljs.registerLanguage("diff", require_diff());
    hljs.registerLanguage("ruby", require_ruby());
    hljs.registerLanguage("go", require_go());
    hljs.registerLanguage("graphql", require_graphql());
    hljs.registerLanguage("ini", require_ini());
    hljs.registerLanguage("java", require_java());
    hljs.registerLanguage("javascript", require_javascript());
    hljs.registerLanguage("json", require_json());
    hljs.registerLanguage("kotlin", require_kotlin());
    hljs.registerLanguage("less", require_less());
    hljs.registerLanguage("lua", require_lua());
    hljs.registerLanguage("makefile", require_makefile());
    hljs.registerLanguage("perl", require_perl());
    hljs.registerLanguage("objectivec", require_objectivec());
    hljs.registerLanguage("php", require_php());
    hljs.registerLanguage("php-template", require_php_template());
    hljs.registerLanguage("plaintext", require_plaintext());
    hljs.registerLanguage("python", require_python());
    hljs.registerLanguage("python-repl", require_python_repl());
    hljs.registerLanguage("r", require_r());
    hljs.registerLanguage("rust", require_rust());
    hljs.registerLanguage("scss", require_scss());
    hljs.registerLanguage("shell", require_shell());
    hljs.registerLanguage("sql", require_sql());
    hljs.registerLanguage("swift", require_swift());
    hljs.registerLanguage("yaml", require_yaml());
    hljs.registerLanguage("typescript", require_typescript());
    hljs.registerLanguage("vbnet", require_vbnet());
    hljs.registerLanguage("wasm", require_wasm());
    hljs.HighlightJS = hljs;
    hljs.default = hljs;
    module.exports = hljs;
  }
});

// node_modules/formsmd/src/main.js
var require_main = __commonJS({
  "node_modules/formsmd/src/main.js"(exports) {
    "use strict";
    var { parseDataBlocks } = require_data_blocks_parse();
    var { isNumeric } = require_helpers();
    var { renderer } = require_marked_renderer();
    var { getDefaultSettings, parseSettings } = require_settings_parse();
    var { parseSpreadsheetData } = require_spreadsheet_data_parse();
    var {
      createStyles,
      madeInLoaderTemplate,
      createBodyTemplate,
      createContentTemplate
    } = require_templates_create();
    var { getTranslation } = require_translations();
    var createDOMPurify = require_purify_cjs();
    var hljs = require_common();
    var { marked } = require_marked();
    var nunjucks = require_nunjucks();
    var Formsmd = class {
      /**
       * Google reCAPTCHA attributes.
       *
       * @typedef {Object} RecaptchaType
       * @property {string} [siteKey] Google reCAPTCHA site key.
       * @property {string} [action] The action name. Default is `"submit"`.
       * @property {"bottomleft"|"bottomright"|"inline"} [badgePosition] The position of the reCAPTCHA badge. Default is `"bottomleft"`.
       * @property {boolean} [hideBadge] Whether to hide the reCAPTCHA badge. Default is `false`.
       */
      /**
       * Theme for the page or form.
       *
       * @typedef {Object} ThemeType
       * @property {string} [accent] The primary color (must be HTML name, hex code, or RGB) used on buttons, form fields, etc.
       * @property {string} [accentForeground] The text color (must be HTML name, hex code, or RGB) used on `accent` background, for example, the text on buttons.
       * @property {string} [backgroundColor] The `background-color` of the page (must be HTML name, hex code, or RGB).
       * @property {string} [color] The `color` of the text on the page (must be HTML name, hex code, or RGB).
       */
      /**
       * Options for the page or form.
       *
       * @typedef {Object} OptionsType
       * @property {"light"|"dark"} [colorScheme] The default or initial color scheme of the page. Default is `"light"`.
       * @property {string} [errorFieldKey] The key used to identify the field in error objects. Default is `"field"`.
       * @property {string} [errorMessageKey] The key used to identify the error message in error objects. Default is `"message"`.
       * @property {"hide"|"show"} [footer] Controls visibility of the footer.
       * @property {"hide"|"show"} [formsmdBranding] Controls visibility of the Forms.md branding.
       * @property {Object} [getHeaders] Headers for GET requests.
       * @property {boolean} [isFullPage] Whether to render in full page mode. Default is `false`.
       * @property {number} [paddingInlineBottom] Padding bottom for inline pages or forms. Default is `20`.
       * @property {number} [paddingInlineHorizontal] Horizontal padding for inline pages or forms. Default is `0`.
       * @property {number} [paddingInlineTop] Padding top for inline pages or forms. Default is `20`.
       * @property {"hide"|"show"|"decorative"} [pageProgress] Controls visibility and function of the page progress.
       * @property {Object} [postData] Extra data sent with POST requests.
       * @property {Object} [postHeaders] Headers for POST requests.
       * @property {boolean} [prioritizeURLFormData] Whether to prioritize URL form data. Default is `false`.
       * @property {RecaptchaType} [recaptcha] The Google reCAPTCHA attributes.
       * @property {boolean} [sanitize] Whether to sanitize template. Default is `true`.
       * @property {boolean} [saveState] Whether to save form data in local storage. Default is `true`.
       * @property {boolean} [sendFilesAsBase64] Whether to send files as base64. Default is `false`.
       * @property {boolean} [setColorSchemeAttrsAgain] Whether to set color scheme attributes again.
       * @property {"hide"|"show"} [slideControls] Controls visibility of next and previous buttons.
       * @property {number} [startSlide] The index of the first slide to make active. Default is `0`.
       * @property {ThemeType} [themeDark] Dark theme.
       * @property {ThemeType} [themeLight] Light theme.
       */
      /**
       * Create an instance of the class.
       *
       * @param {string} template
       * @param {Document|HTMLElement|Element} container
       * @param {OptionsType} options
       */
      constructor(template, container, options) {
        __publicField(this, "options", {
          colorScheme: "light",
          errorFieldKey: "field",
          errorMessageKey: "message",
          footer: "",
          formsmdBranding: "",
          getHeaders: {},
          isFullPage: false,
          paddingInlineBottom: 20,
          paddingInlineHorizontal: 0,
          paddingInlineTop: 20,
          pageProgress: "",
          postData: {},
          postHeaders: {},
          prioritizeURLFormData: false,
          recaptcha: {
            siteKey: "",
            action: "submit",
            badgePosition: "bottomleft",
            hideBadge: false
          },
          sanitize: true,
          saveState: true,
          sendFilesAsBase64: false,
          setColorSchemeAttrsAgain: true,
          slideControls: "",
          startSlide: 0,
          themeDark: {
            accent: "rgb(138, 180, 248)",
            accentForeground: "rgb(0, 0, 0)",
            backgroundColor: "rgb(20, 20, 20)",
            color: "rgb(240, 240, 240)"
          },
          themeLight: {
            accent: "rgb(30, 55, 153)",
            accentForeground: "rgb(255, 255, 255)",
            backgroundColor: "rgb(255, 255, 255)",
            color: "rgb(0, 0, 0)"
          }
        });
        /**
         * Set the state to defaults.
         */
        __publicField(this, "setStateToDefaults", () => {
          const instance = this;
          instance.state = {
            bindDivTemplates: {},
            data: {},
            fieldTypes: {},
            formData: {},
            settings: getDefaultSettings(),
            slideData: {
              currentIndex: 0
            }
          };
        });
        /**
         * Add a single attribute value to an HTML element.
         *
         * @param {HTMLElement} elem
         * @param {string} name
         * @param {string} value
         */
        __publicField(this, "setSingleAttribute", (elem, name, value) => {
          const attrs = elem.getAttribute(name) || "";
          const attrsArr = attrs.replace(/\s\s+/g, " ").split(" ").filter(function(v) {
            return v !== "";
          });
          attrsArr.push(value);
          elem.setAttribute(name, attrsArr.join(" "));
        });
        /**
         * Remove a single attribute value from an HTML element.
         *
         * @param {HTMLElement} elem
         * @param {string} name
         * @param {string} value
         */
        __publicField(this, "removeSingleAttribute", (elem, name, value) => {
          const attrs = elem.getAttribute(name) || "";
          const attrsArr = attrs.replace(/\s\s+/g, " ").split(" ").filter(function(v) {
            return v !== "";
          });
          const index = attrsArr.indexOf(value);
          if (index > -1) {
            attrsArr.splice(index, 1);
          }
          if (attrsArr.length > 0) {
            elem.setAttribute(name, attrsArr.join(" "));
          } else {
            elem.removeAttribute(name);
          }
        });
        /**
         * Get the prefix for the page/form id.
         *
         * @returns {string}
         */
        __publicField(this, "getIdPrefix", () => {
          const instance = this;
          return instance.state.settings.id !== "" ? `${instance.state.settings.id}:` : "";
        });
        /**
         * Set the preferred color scheme (if one is found in the local storage).
         * Depending on the preference from settings, either the domain-wide or the
         * page-specific value is used.
         */
        __publicField(this, "setPreferredColorScheme", () => {
          const instance = this;
          const rootElem = instance.container.querySelector(".fmd-root");
          const localStorageKey = rootElem.getAttribute("data-fmd-color-scheme-scope") === "isolate" ? `formsmd:${instance.getIdPrefix()}${window.location.hostname}${window.location.pathname}color-scheme` : "formsmd:color-scheme";
          const preferredColorScheme = localStorage.getItem(localStorageKey);
          if (preferredColorScheme) {
            rootElem.setAttribute("data-fmd-color-scheme", preferredColorScheme);
          }
        });
        /**
         * Toggle color scheme. If the preferred color scheme (from settings) is set
         * to "isolate", the preference is saved (and used) only for that page.
         * Otherwise, it is saved (and used) domain-wide.
         *
         * @param {MouseEvent} e
         */
        __publicField(this, "toggleColorScheme", (e) => {
          const instance = this;
          e.preventDefault();
          const rootElem = instance.container.querySelector(".fmd-root");
          const localStorageKey = instance.state.settings["color-scheme-scope"] === "isolate" ? `formsmd:${instance.getIdPrefix()}${window.location.hostname}${window.location.pathname}color-scheme` : "formsmd:color-scheme";
          const currentColorScheme = rootElem.getAttribute("data-fmd-color-scheme");
          if (currentColorScheme === "light") {
            rootElem.setAttribute("data-fmd-color-scheme", "dark");
            localStorage.setItem(localStorageKey, "dark");
          } else if (currentColorScheme === "dark") {
            rootElem.setAttribute("data-fmd-color-scheme", "light");
            localStorage.setItem(localStorageKey, "light");
          }
        });
        /**
         * Create a random 32 characters id separated by dashes.
         *
         * @returns {string}
         */
        __publicField(this, "createRandomId", () => {
          const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
          let id = "";
          for (let i = 0; i < 32; i++) {
            id += characters.charAt(Math.floor(Math.random() * characters.length));
          }
          return `${id.slice(0, 8)}-${id.slice(8, 12)}-${id.slice(12, 16)}-${id.slice(16, 20)}-${id.slice(20)}`;
        });
        /**
         * Get or create response id. This uniquely identifies one single form
         * response. The id is created on initialization (unless one already
         * exists), and it is removed when the user reaches the end slide.
         *
         * @returns {string}
         */
        __publicField(this, "getOrCreateResponseId", () => {
          const instance = this;
          const localStorageKey = `formsmd:${instance.getIdPrefix()}${window.location.hostname}${window.location.pathname}response-id`;
          let responseId = localStorage.getItem(localStorageKey);
          if (!responseId) {
            responseId = instance.createRandomId();
            localStorage.setItem(localStorageKey, responseId);
          }
          return responseId;
        });
        /**
         * Remove response id. This is called when the user reaches the end slide.
         */
        __publicField(this, "removeResponseId", () => {
          const instance = this;
          const localStorageKey = `formsmd:${instance.getIdPrefix()}${window.location.hostname}${window.location.pathname}response-id`;
          localStorage.removeItem(localStorageKey);
        });
        /**
         * Save form field value in local storage.
         *
         * @param {string} name
         * @param {*} value
         */
        __publicField(this, "saveFieldValue", (name, value) => {
          const instance = this;
          const localStorageKey = `formsmd:${instance.getIdPrefix()}${window.location.hostname}${window.location.pathname}form-data`;
          let savedFormData = localStorage.getItem(localStorageKey) || "{}";
          savedFormData = JSON.parse(savedFormData);
          savedFormData[name] = value;
          localStorage.setItem(localStorageKey, JSON.stringify(savedFormData));
        });
        /**
         * Remove form data from local storage. This is called when the user reaches
         * the end slide.
         */
        __publicField(this, "removeSavedFormData", () => {
          const instance = this;
          const localStorageKey = `formsmd:${instance.getIdPrefix()}${window.location.hostname}${window.location.pathname}form-data`;
          localStorage.removeItem(localStorageKey);
        });
        /**
         * Re-render the bind <div> and <span> elements.
         *
         * @param {string} name
         */
        __publicField(this, "reRenderBindElems", (name) => {
          const instance = this;
          instance.container.querySelectorAll(`div[data-fmd-bind-${name}]`).forEach((div) => {
            const template = instance.state.bindDivTemplates[div.getAttribute("data-fmd-bind-template-ref")];
            marked.use({
              renderer,
              markedSettings: {
                "css-prefix": instance.state.settings["css-prefix"],
                "form-delimiter": instance.state.settings["form-delimiter"],
                "id": instance.state.settings.id,
                "localization": instance.state.settings.localization
              }
            });
            let parsedTemplate = marked.parse(
              nunjucks.renderString(template, {
                ...instance.state.data,
                ...instance.state.formData
              })
            );
            if (instance.options.sanitize) {
              const DOMPurify = createDOMPurify(window);
              parsedTemplate = DOMPurify.sanitize(parsedTemplate);
            }
            div.innerHTML = parsedTemplate;
            div.querySelectorAll("pre code").forEach((codeBlock) => {
              hljs.highlightElement(codeBlock);
            });
            instance.addEventListeners(div, false);
          });
          instance.container.querySelectorAll(`span[data-fmd-bind-${name}]`).forEach((span) => {
            span.innerText = instance.state.formData[name];
          });
        });
        /**
         * Get value of a set of radio buttons or checkboxes.
         *
         * @param {string} name
         * @param {string} inputClass
         * @param {"radio"|"checkbox"} type
         * @returns {string|Array.<string>}
         */
        __publicField(this, "getRadioCheckboxValue", (name, inputClass, type) => {
          const instance = this;
          if (type === "radio") {
            let value = "";
            const input = instance.container.querySelector(
              `.${inputClass}[type="radio"][name="${name}"]:checked`
            );
            if (input) {
              value = input.value;
            }
            return value;
          } else if (type === "checkbox") {
            const value = [];
            instance.container.querySelectorAll(
              `.${inputClass}[type="checkbox"][name="${name}"]:checked`
            ).forEach((input) => {
              value.push(input.value);
            });
            return value;
          }
        });
        /**
         * Set value of a set of radio buttons or checkboxes.
         *
         * @param {string} name
         * @param {string} inputClass
         * @param {"radio"|"checkbox"} type
         * @param {string|Array.<string>} value
         */
        __publicField(this, "setRadioCheckboxValue", (name, inputClass, type, value) => {
          const instance = this;
          if (type === "radio") {
            if (typeof value === "string") {
              value = value.trim();
            }
            const input = instance.container.querySelector(
              `.${inputClass}[type="radio"][name="${name}"][value="${value}"]`
            );
            if (input) {
              input.checked = true;
            }
          } else if (type === "checkbox") {
            const values = {};
            for (const item of value) {
              values[item.trim()] = true;
            }
            instance.container.querySelectorAll(`.${inputClass}[type="checkbox"][name="${name}"]`).forEach((input) => {
              input.checked = false;
              if (values[input.value]) {
                input.checked = true;
              }
            });
          }
        });
        /**
         * Given a country calling code <select>, update placeholder of the
         * corresponding telephone input using the selected <option>.
         *
         * @param {HTMLSelectElement} countryCodeSelect
         */
        __publicField(this, "setTelInputPlaceholder", (countryCodeSelect) => {
          const telInput = countryCodeSelect.closest(".fmd-form-field").querySelector('.fmd-form-str-input[type="tel"]');
          const selected = countryCodeSelect.selectedOptions[0];
          if (telInput && selected) {
            telInput.setAttribute(
              "placeholder",
              selected.getAttribute("data-fmd-placeholder")
            );
          }
        });
        /**
         * Set form data to state (value and type). Also re-render the bind <div>
         * and <span> elements.
         */
        __publicField(this, "setFormDataToState", () => {
          const instance = this;
          instance.container.querySelectorAll(
            'input.fmd-form-str-input[type="text"], input.fmd-form-str-input[type="email"], input.fmd-form-str-input[type="url"], input.fmd-form-str-input[type="tel"], textarea.fmd-form-str-input'
          ).forEach((elem) => {
            let name = elem.getAttribute("name");
            const value = elem.value;
            const type = elem.getAttribute("type") || "text";
            instance.state.formData[name] = value;
            instance.state.fieldTypes[name] = type;
            instance.reRenderBindElems(name);
          });
          instance.container.querySelectorAll('input.fmd-form-num-input[type="number"]').forEach((elem) => {
            const name = elem.getAttribute("name");
            const value = isNumeric(elem.value) ? Number(elem.value) : null;
            instance.state.formData[name] = value;
            instance.state.fieldTypes[name] = "number";
            instance.reRenderBindElems(name);
          });
          instance.container.querySelectorAll("select.fmd-form-str-select").forEach((elem) => {
            const name = elem.getAttribute("name");
            const value = elem.value;
            instance.state.formData[name] = value;
            instance.state.fieldTypes[name] = "select";
            instance.reRenderBindElems(name);
          });
          instance.container.querySelectorAll(
            ".fmd-form-check:first-child input.fmd-form-str-check-input"
          ).forEach((elem) => {
            const name = elem.getAttribute("name");
            const type = elem.getAttribute("type");
            const value = instance.getRadioCheckboxValue(
              name,
              "fmd-form-str-check-input",
              type
            );
            instance.state.formData[name] = value;
            instance.state.fieldTypes[name] = "choice";
            instance.reRenderBindElems(name);
          });
          instance.container.querySelectorAll("input.fmd-form-num-check-input:first-child").forEach((elem) => {
            const name = elem.getAttribute("name");
            let value = instance.getRadioCheckboxValue(
              name,
              "fmd-form-num-check-input",
              "radio"
            );
            value = value ? parseInt(value) : null;
            instance.state.formData[name] = value;
            instance.state.fieldTypes[name] = "num-choice";
            instance.reRenderBindElems(name);
          });
          instance.container.querySelectorAll(
            'input.fmd-form-datetime-input[type="datetime-local"], input.fmd-form-datetime-input[type="date"], input.fmd-form-datetime-input[type="time"]'
          ).forEach((elem) => {
            let name = elem.getAttribute("name");
            const value = elem.value;
            const type = elem.getAttribute("type");
            instance.state.formData[name] = value;
            instance.state.fieldTypes[name] = type;
            instance.reRenderBindElems(name);
          });
        });
        /**
         * Set form data from URL parameters: set value in the DOM, update state,
         * conditionally update local storage, and re-render the bind <div> and
         * <span> elements. The local storage is updated if this function is called
         * AFTER setting the saved form data (in local storage).
         *
         * @param {boolean} updateLocalStorage
         */
        __publicField(this, "setFormDataFromURL", (updateLocalStorage) => {
          const instance = this;
          const urlParams = new URLSearchParams(window.location.search);
          for (const urlParam of urlParams) {
            let name = urlParam[0];
            let value = urlParam[1];
            if (instance.state.settings.id !== "") {
              if (name.startsWith(`${instance.state.settings.id}:`)) {
                name = name.replace(`${instance.state.settings.id}:`, "");
              } else {
                continue;
              }
            }
            if (instance.state.fieldTypes[name] === "text" || instance.state.fieldTypes[name] === "email" || instance.state.fieldTypes[name] === "url" || instance.state.fieldTypes[name] === "tel") {
              const input = instance.container.querySelector(
                `.fmd-form-str-input[name="${name}"]`
              );
              if (input) {
                input.value = value;
                instance.state.formData[name] = value;
                if (updateLocalStorage && instance.options.saveState) {
                  instance.saveFieldValue(name, value);
                }
                instance.reRenderBindElems(name);
              }
            }
            if (instance.state.fieldTypes[name] === "number") {
              const input = instance.container.querySelector(
                `.fmd-form-num-input[name="${name}"]`
              );
              if (input && isNumeric(value)) {
                value = Number(value);
                input.value = value;
                instance.state.formData[name] = value;
                if (updateLocalStorage && instance.options.saveState) {
                  instance.saveFieldValue(name, value);
                }
                instance.reRenderBindElems(name);
              }
            }
            if (instance.state.fieldTypes[name] === "select") {
              const select = instance.container.querySelector(
                `.fmd-form-str-select[name="${name}"]`
              );
              if (select) {
                const options = select.querySelectorAll("option");
                for (const option of options) {
                  if (option.getAttribute("value") === value) {
                    select.value = value;
                    instance.state.formData[name] = value;
                    if (updateLocalStorage && instance.options.saveState) {
                      instance.saveFieldValue(name, value);
                    }
                    instance.reRenderBindElems(name);
                    break;
                  }
                }
                if (select.classList.contains("fmd-form-countrycode-select")) {
                  instance.setTelInputPlaceholder(select);
                }
              }
            }
            if (instance.state.fieldTypes[name] === "choice") {
              const input = instance.container.querySelector(
                `.fmd-form-str-check-input[name="${name}"]`
              );
              if (input) {
                const type = input.getAttribute("type");
                if (type === "checkbox") {
                  value = value.split(",");
                }
                instance.setRadioCheckboxValue(
                  name,
                  "fmd-form-str-check-input",
                  type,
                  value
                );
                value = instance.getRadioCheckboxValue(
                  name,
                  "fmd-form-str-check-input",
                  type
                );
                instance.state.formData[name] = value;
                if (updateLocalStorage && instance.options.saveState) {
                  instance.saveFieldValue(name, value);
                }
                instance.reRenderBindElems(name);
              }
            }
            if (instance.state.fieldTypes[name] === "num-choice") {
              const input = instance.container.querySelector(
                `.fmd-form-num-check-input[name="${name}"]`
              );
              if (input) {
                instance.setRadioCheckboxValue(
                  name,
                  "fmd-form-num-check-input",
                  "radio",
                  value
                );
                value = instance.getRadioCheckboxValue(
                  name,
                  "fmd-form-num-check-input",
                  "radio"
                );
                value = value ? parseInt(value) : null;
                instance.state.formData[name] = value;
                if (updateLocalStorage && instance.options.saveState) {
                  instance.saveFieldValue(name, value);
                }
                instance.reRenderBindElems(name);
              }
            }
            if (instance.state.fieldTypes[name] === "datetime-local" || instance.state.fieldTypes[name] === "date" || instance.state.fieldTypes[name] === "time") {
              const input = instance.container.querySelector(
                `.fmd-form-datetime-input[name="${name}"]`
              );
              if (input) {
                input.value = value;
                instance.state.formData[name] = value;
                if (updateLocalStorage && instance.options.saveState) {
                  instance.saveFieldValue(name, value);
                }
                instance.reRenderBindElems(name);
              }
            }
          }
        });
        /**
         * Set form data saved in local storage: set value in the DOM, update state,
         * and re-render the bind <div> and <span> elements.
         */
        __publicField(this, "setSavedFormData", () => {
          const instance = this;
          const localStorageKey = `formsmd:${instance.getIdPrefix()}${window.location.hostname}${window.location.pathname}form-data`;
          const savedFormData = localStorage.getItem(localStorageKey);
          if (!savedFormData) {
            return;
          }
          for (const [name, value] of Object.entries(JSON.parse(savedFormData))) {
            if (instance.state.fieldTypes[name] === "text" || instance.state.fieldTypes[name] === "email" || instance.state.fieldTypes[name] === "url" || instance.state.fieldTypes[name] === "tel") {
              const input = instance.container.querySelector(
                `.fmd-form-str-input[name="${name}"]`
              );
              if (input) {
                input.value = value;
                instance.state.formData[name] = value;
                instance.reRenderBindElems(name);
              }
            }
            if (instance.state.fieldTypes[name] === "number") {
              const input = instance.container.querySelector(
                `.fmd-form-num-input[name="${name}"]`
              );
              if (input) {
                input.value = value;
                instance.state.formData[name] = value;
                instance.reRenderBindElems(name);
              }
            }
            if (instance.state.fieldTypes[name] === "select") {
              const select = instance.container.querySelector(
                `.fmd-form-str-select[name="${name}"]`
              );
              if (select) {
                const options = select.querySelectorAll("option");
                for (const option of options) {
                  if (option.getAttribute("value") === value) {
                    select.value = value;
                    instance.state.formData[name] = value;
                    instance.reRenderBindElems(name);
                    break;
                  }
                }
                if (select.classList.contains("fmd-form-countrycode-select")) {
                  instance.setTelInputPlaceholder(select);
                }
              }
            }
            if (instance.state.fieldTypes[name] === "choice") {
              const input = instance.container.querySelector(
                `.fmd-form-str-check-input[name="${name}"]`
              );
              if (input) {
                const type = input.getAttribute("type");
                instance.setRadioCheckboxValue(
                  name,
                  "fmd-form-str-check-input",
                  type,
                  value
                );
                instance.state.formData[name] = instance.getRadioCheckboxValue(
                  name,
                  "fmd-form-str-check-input",
                  type
                );
                instance.reRenderBindElems(name);
              }
            }
            if (instance.state.fieldTypes[name] === "num-choice") {
              const input = instance.container.querySelector(
                `.fmd-form-num-check-input[name="${name}"]`
              );
              if (input) {
                instance.setRadioCheckboxValue(
                  name,
                  "fmd-form-num-check-input",
                  "radio",
                  String(value)
                );
                instance.state.formData[name] = instance.getRadioCheckboxValue(
                  name,
                  "fmd-form-num-check-input",
                  "radio"
                );
                instance.reRenderBindElems(name);
              }
            }
            if (instance.state.fieldTypes[name] === "datetime-local" || instance.state.fieldTypes[name] === "date" || instance.state.fieldTypes[name] === "time") {
              const input = instance.container.querySelector(
                `.fmd-form-datetime-input[name="${name}"]`
              );
              if (input) {
                input.value = value;
                instance.state.formData[name] = value;
                instance.reRenderBindElems(name);
              }
            }
          }
        });
        /**
         * Given a form field element, remove all errors (and everything related).
         *
         * @param {HTMLElement} formField
         */
        __publicField(this, "removeFieldErrors", (formField) => {
          const instance = this;
          formField.querySelectorAll(".fmd-error").forEach((error) => {
            error.remove();
          });
          const type = formField.getAttribute("data-fmd-type");
          if (type === "radio" || type === "checkbox") {
            formField.querySelectorAll(".fmd-form-str-check-input").forEach((input) => {
              input.removeAttribute("aria-invalid");
              input.removeAttribute("aria-describedby");
            });
          } else if (type === "num-radio") {
            formField.querySelectorAll(".fmd-form-num-check-input").forEach((input) => {
              input.removeAttribute("aria-invalid");
              const name = input.getAttribute("name");
              instance.removeSingleAttribute(
                input,
                "aria-describedby",
                `${instance.getIdPrefix()}id_${name}-error`
              );
            });
          } else if (type === "datetime-local" || type === "date" || type === "time") {
            formField.querySelectorAll(".fmd-form-datetime-input").forEach((input) => {
              input.removeAttribute("aria-invalid");
              input.removeAttribute("aria-describedby");
            });
          } else if (type === "file") {
            formField.querySelectorAll(".fmd-form-file-input").forEach((input) => {
              input.removeAttribute("aria-invalid");
              input.removeAttribute("aria-describedby");
            });
          }
        });
        /**
         * Handle the inputs of text form fields: update value in the state, save
         * value in local storage, remove errors and re-render the bind <div> and
         * <span> elements.
         *
         * @param {InputEvent} e
         */
        __publicField(this, "textFieldOnInput", (e) => {
          const instance = this;
          const name = e.target.getAttribute("name");
          const value = e.target.value;
          instance.state.formData[name] = value;
          if (instance.options.saveState) {
            instance.saveFieldValue(name, value);
          }
          instance.removeFieldErrors(e.target.closest(".fmd-form-field"));
          instance.reRenderBindElems(name);
        });
        /**
         * Handle the inputs of number form fields: update value in the state, save
         * value in local storage, remove errors and re-render the bind <div> and
         * <span> elements.
         *
         * @param {InputEvent} e
         */
        __publicField(this, "numberFieldOnInput", (e) => {
          const instance = this;
          const name = e.target.getAttribute("name");
          const value = isNumeric(e.target.value) ? Number(e.target.value) : null;
          instance.state.formData[name] = value;
          if (instance.options.saveState) {
            instance.saveFieldValue(name, value);
          }
          instance.removeFieldErrors(e.target.closest(".fmd-form-field"));
          instance.reRenderBindElems(name);
        });
        /**
         * Handle the inputs of select form fields: update value in the state, save
         * value in local storage, remove errors and re-render the bind <div> and
         * <span> elements. If the select box is a country calling code select, then
         * also update the placeholder of the corresponding telephone input.
         *
         * @param {InputEvent} e
         */
        __publicField(this, "selectFieldOnInput", (e) => {
          const instance = this;
          const name = e.target.getAttribute("name");
          const value = e.target.value;
          instance.state.formData[name] = value;
          if (instance.options.saveState) {
            instance.saveFieldValue(name, value);
          }
          instance.removeFieldErrors(e.target.closest(".fmd-form-field"));
          instance.reRenderBindElems(name);
          if (e.target.classList.contains("fmd-form-countrycode-select")) {
            instance.setTelInputPlaceholder(e.target);
          }
        });
        /**
         * Handle the inputs of choice form fields: update value in the state, save
         * value in local storage, remove errors and re-render the bind <div> and
         * <span> elements.
         *
         * @param {InputEvent} e
         */
        __publicField(this, "choiceFieldOnInput", (e) => {
          const instance = this;
          const name = e.target.getAttribute("name");
          const type = e.target.getAttribute("type");
          const value = instance.getRadioCheckboxValue(
            name,
            "fmd-form-str-check-input",
            type
          );
          instance.state.formData[name] = value;
          if (instance.options.saveState) {
            instance.saveFieldValue(name, value);
          }
          instance.removeFieldErrors(e.target.closest(".fmd-form-field"));
          instance.reRenderBindElems(name);
        });
        /**
         * Handle the inputs of number choice form fields: update value in the
         * state, save value in local storage, remove errors and re-render the bind
         * <div> and <span> elements.
         *
         * @param {InputEvent} e
         */
        __publicField(this, "numChoiceFieldOnInput", (e) => {
          const instance = this;
          const name = e.target.getAttribute("name");
          const value = parseInt(
            instance.getRadioCheckboxValue(name, "fmd-form-num-check-input", "radio")
          );
          instance.state.formData[name] = value;
          if (instance.options.saveState) {
            instance.saveFieldValue(name, value);
          }
          instance.removeFieldErrors(e.target.closest(".fmd-form-field"));
          instance.reRenderBindElems(name);
        });
        /**
         * Handle the inputs of datetime form fields: update value in the state,
         * save value in local storage, remove errors and re-render the bind <div>
         * and <span> elements.
         *
         * @param {InputEvent} e
         */
        __publicField(this, "datetimeFieldOnInput", (e) => {
          const instance = this;
          const name = e.target.getAttribute("name");
          const value = e.target.value;
          instance.state.formData[name] = value;
          if (instance.options.saveState) {
            instance.saveFieldValue(name, value);
          }
          instance.removeFieldErrors(e.target.closest(".fmd-form-field"));
          instance.reRenderBindElems(name);
        });
        /**
         * Handle the inputs of file form fields: reset and update the wrapping
         * <label> depending on the file chosen.
         *
         * @param {InputEvent} e
         */
        __publicField(this, "fileFieldOnInput", (e) => {
          const instance = this;
          const label = e.target.closest(".fmd-form-file-label");
          const fileExistsSection = label.querySelector(".fmd-file-exists-section");
          instance.removeFieldErrors(e.target.closest(".fmd-form-field"));
          label.classList.remove("fmd-file-exists");
          fileExistsSection.innerHTML = "";
          const imageFileTypes = [
            "image/apng",
            "image/bmp",
            "image/gif",
            "image/jpeg",
            "image/pjpeg",
            "image/png",
            "image/svg+xml",
            "image/tiff",
            "image/webp",
            "image/x-icon"
          ];
          const file = e.target.files[0];
          if (file) {
            let fileValid = true;
            if (e.target.getAttribute("accept") === "image/*" && !imageFileTypes.includes(file.type)) {
              e.target.value = "";
              fileValid = false;
            }
            if (fileValid) {
              if (imageFileTypes.includes(file.type)) {
                fileExistsSection.innerHTML = [
                  `<span class="fmd-form-file-img-container">`,
                  `	<img src="${URL.createObjectURL(file)}" alt="${file.name}">`,
                  `</span>`,
                  `<span class="fmd-d-block fmd-mt-3">`,
                  `	<strong class="fmd-text-accent">${file.name}</strong>`,
                  `</span>
`
                ].join("\n");
              } else {
                fileExistsSection.innerHTML = [
                  `<span class="fmd-form-file-img-container">`,
                  `	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" class="fmd-icon" aria-hidden="true" focusable="false"><path d="M352 448l0-256-112 0c-26.5 0-48-21.5-48-48l0-112L64 32C46.3 32 32 46.3 32 64l0 384c0 17.7 14.3 32 32 32l256 0c17.7 0 32-14.3 32-32zm-.5-288c-.7-2.8-2.1-5.4-4.2-7.4L231.4 36.7c-2.1-2.1-4.6-3.5-7.4-4.2L224 144c0 8.8 7.2 16 16 16l111.5 0zM0 64C0 28.7 28.7 0 64 0L220.1 0c12.7 0 24.9 5.1 33.9 14.1L369.9 129.9c9 9 14.1 21.2 14.1 33.9L384 448c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 64z"/></svg>`,
                  `</span>`,
                  `<span class="fmd-d-block fmd-mt-3">`,
                  `	<strong class="fmd-text-accent">${file.name}</strong>`,
                  `</span>
`
                ].join("\n");
              }
              label.classList.add("fmd-file-exists");
            }
          }
        });
        /**
         * Set the height of a <textarea> element.
         *
         * @param {HTMLTextAreaElement} textarea
         */
        __publicField(this, "setTextareaHeight", (textarea) => {
          textarea.style.height = "";
          const computedStyle = window.getComputedStyle(textarea);
          const newHeight = parseFloat(textarea.scrollHeight) + parseFloat(computedStyle.borderTopWidth) + parseFloat(computedStyle.borderBottomWidth);
          textarea.style.height = String(newHeight) + "px";
        });
        /**
         * Set the height of a <textarea> element on input.
         *
         * @param {InputEvent} e
         */
        __publicField(this, "setTextareaHeightOnInput", (e) => {
          const instance = this;
          instance.setTextareaHeight(e.target);
        });
        /**
         * Reset file input when the corresponding reset button is clicked.
         *
         * @param {MouseEvent} e
         */
        __publicField(this, "fileInputResetBtnOnClick", (e) => {
          const instance = this;
          const fileInput = e.target.closest(".fmd-form-field").querySelector('.fmd-form-file-input[type="file"]');
          const label = e.target.closest(".fmd-form-field").querySelector(".fmd-form-file-label");
          const fileExistsSection = label.querySelector(".fmd-file-exists-section");
          if (fileInput && label && fileExistsSection) {
            fileInput.value = "";
            instance.removeFieldErrors(e.target.closest(".fmd-form-field"));
            label.classList.remove("fmd-file-exists");
            fileExistsSection.innerHTML = "";
          }
        });
        /**
         * Given a <button> element, set it to the processing state.
         *
         * @param {HTMLButtonElement} btn
         */
        __publicField(this, "setBtnProcessing", (btn) => {
          const instance = this;
          btn.classList.add("fmd-btn-processing");
          const localization = instance.state.settings.localization;
          btn.setAttribute("aria-label", getTranslation(localization, "loading"));
        });
        /**
         * Given a <button> element, remove its processing state.
         *
         * @param {HTMLButtonElement} btn
         */
        __publicField(this, "removeBtnProcessing", (btn) => {
          const instance = this;
          btn.classList.remove("fmd-btn-processing");
          btn.removeAttribute("aria-label");
          const localization = instance.state.settings.localization;
          const footerPreviousBtn = instance.container.querySelector(
            ".fmd-footer .fmd-previous-btn"
          );
          const footerNextBtn = instance.container.querySelector(
            ".fmd-footer .fmd-next-btn"
          );
          if (btn === footerPreviousBtn) {
            btn.setAttribute(
              "aria-label",
              getTranslation(localization, "previous-btn")
            );
          } else if (btn === footerNextBtn) {
            btn.setAttribute("aria-label", getTranslation(localization, "next-btn"));
          }
        });
        /**
         * Given a slide element, remove all errors (and everything related).
         *
         * @param {HTMLElement} slide
         */
        __publicField(this, "removeSlideErrors", (slide) => {
          const instance = this;
          slide.querySelectorAll(".fmd-form-field").forEach((formField) => {
            instance.removeFieldErrors(formField);
          });
          slide.querySelectorAll(".fmd-error").forEach((error) => {
            error.remove();
          });
          const ctaBtn = slide.querySelector(".fmd-submit-btn") || slide.querySelector(".fmd-next-btn");
          ctaBtn.removeAttribute("aria-describedby");
        });
        /**
         * Add an error inside the given form field element.
         *
         * @param {HTMLElement} formField
         * @param {string} errorId
         * @param {string} message
         */
        __publicField(this, "addFieldError", (formField, errorId, message) => {
          const error = document.createElement("div");
          error.setAttribute("id", errorId);
          error.innerHTML = [
            `<div class="fmd-error">`,
            `	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="fmd-icon fmd-error-icon" aria-hidden="true" focusable="false"><path d="M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"/></svg>`,
            `	${message}`,
            `</div>`
          ].join("\n");
          formField.insertAdjacentElement("beforeend", error);
        });
        /**
         * Given a <form> element, validate and add errors if necessary. By default,
         * most form fields rely entirely on built-in client-side validation that is
         * found in browsers.
         *
         * @param {HTMLFormElement} form
         * @returns {boolean} form is valid or not
         */
        __publicField(this, "formValid", (form) => {
          const instance = this;
          const localization = instance.state.settings.localization;
          instance.removeSlideErrors(form);
          let isFormValid = true;
          const formFieldsWithError = [];
          form.querySelectorAll(
            '.fmd-form-field[data-fmd-type="radio"][data-fmd-required], .fmd-form-field[data-fmd-type="checkbox"][data-fmd-required], .fmd-form-field[data-fmd-type="num-radio"][data-fmd-required], .fmd-form-field[data-fmd-type="datetime-local"], .fmd-form-field[data-fmd-type="date"], .fmd-form-field[data-fmd-type="time"], .fmd-form-field[data-fmd-type="file"]'
          ).forEach((formField) => {
            const name = formField.getAttribute("data-fmd-name");
            const type = formField.getAttribute("data-fmd-type");
            if (type === "radio" || type === "checkbox") {
              const value = instance.getRadioCheckboxValue(
                name,
                "fmd-form-str-check-input",
                type
              );
              if (value.length === 0) {
                isFormValid = false;
                formFieldsWithError.push(formField);
                const errorId = `${instance.getIdPrefix()}id_${name}-error`;
                instance.addFieldError(
                  formField,
                  errorId,
                  getTranslation(localization, "choice-field-required")
                );
                formField.querySelectorAll(".fmd-form-str-check-input").forEach((input) => {
                  input.setAttribute("aria-invalid", "true");
                  input.setAttribute("aria-describedby", errorId);
                });
              }
            } else if (type === "num-radio") {
              const value = instance.getRadioCheckboxValue(
                name,
                "fmd-form-num-check-input",
                "radio"
              );
              if (value.length === 0) {
                isFormValid = false;
                formFieldsWithError.push(formField);
                const errorId = `${instance.getIdPrefix()}id_${name}-error`;
                instance.addFieldError(
                  formField,
                  errorId,
                  getTranslation(localization, "number-choice-field-required")
                );
                formField.querySelectorAll(".fmd-form-num-check-input").forEach((input) => {
                  input.setAttribute("aria-invalid", "true");
                  instance.setSingleAttribute(input, "aria-describedby", errorId);
                });
              }
            } else if (type === "datetime-local" || type === "date" || type === "time") {
              const value = formField.querySelector(
                `.fmd-form-datetime-input[name="${name}"]`
              ).value;
              let pattern = /.*/;
              let errorTranslationKey = "";
              if (type === "datetime-local") {
                pattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/;
                errorTranslationKey = "datetime-input-error";
              } else if (type === "date") {
                pattern = /^\d{4}-\d{2}-\d{2}$/;
                errorTranslationKey = "date-input-error";
              } else if (type === "time") {
                pattern = /^\d{2}:\d{2}$/;
                errorTranslationKey = "time-input-error";
              }
              if (value !== "" && !value.match(pattern)) {
                isFormValid = false;
                formFieldsWithError.push(formField);
                const errorId = `${instance.getIdPrefix()}id_${name}-error`;
                instance.addFieldError(
                  formField,
                  errorId,
                  getTranslation(localization, errorTranslationKey)
                );
                formField.querySelectorAll(".fmd-form-datetime-input").forEach((input) => {
                  input.setAttribute("aria-invalid", "true");
                  input.setAttribute("aria-describedby", errorId);
                });
              }
            } else if (type === "file") {
              const sizeLimit = Number(
                formField.getAttribute("data-fmd-size-limit")
              );
              const file = formField.querySelector(".fmd-form-file-input").files[0];
              if (file) {
                const fileSize = (file.size / 1024 / 1024).toFixed(4);
                if (fileSize > sizeLimit) {
                  isFormValid = false;
                  formFieldsWithError.push(formField);
                  const errorId = `${instance.getIdPrefix()}id_${name}-error`;
                  instance.addFieldError(
                    formField,
                    errorId,
                    getTranslation(localization, "file-input-size-error")
                  );
                  formField.querySelectorAll(".fmd-form-file-input").forEach((input) => {
                    input.setAttribute("aria-invalid", "true");
                    input.setAttribute("aria-describedby", errorId);
                  });
                }
              }
            }
          });
          if (formFieldsWithError.length > 0) {
            const inputToFocus = formFieldsWithError[0].querySelector(
              ".fmd-form-str-check-input, .fmd-form-num-check-input, .fmd-form-datetime-input, .fmd-form-file-input"
            );
            if (inputToFocus) {
              inputToFocus.focus();
            }
          }
          return isFormValid;
        });
        /**
         * When an error occurs during form submission or slide transition, add an
         * error inside the slide element that contains the messages (if any).
         *
         * @param {HTMLElement} slide
         * @param {HTMLButtonElement} ctaBtn
         * @param {Array.<string>} messages
         */
        __publicField(this, "addSlideError", (slide, ctaBtn, messages) => {
          const instance = this;
          const localization = instance.state.settings.localization;
          const error = document.createElement("div");
          const errorId = `${instance.getIdPrefix()}id_slide-${instance.state.slideData.currentIndex}-error`;
          error.setAttribute("id", errorId);
          const messageList = [];
          if (messages.length > 0) {
            messageList.push('<ul class="fmd-error-list">');
            for (const message of messages) {
              messageList.push(`<li>${message}</li>`);
            }
            messageList.push("</ul>");
          }
          error.innerHTML = [
            `<div class="fmd-error">`,
            `	<div class="fmd-error-inner">`,
            `		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="fmd-icon fmd-error-icon" aria-hidden="true" focusable="false"><path d="M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"/></svg>`,
            `		${getTranslation(localization, "slide-error")}`,
            `	</div>`,
            `	${messageList.join("\n")}`,
            `</div>`
          ].join("\n");
          ctaBtn.setAttribute("aria-describedby", errorId);
          slide.insertAdjacentElement("beforeend", error);
        });
        /**
         * GET data from remote source. A remote source here is anything outside of
         * the actual template.
         *
         * @returns {Promise<string>}
         */
        __publicField(this, "getRemoteData", () => {
          const instance = this;
          if (window.location.protocol === "file:") {
            console.warn("Remote data not loaded: HTML page is a file (CORS issue).");
            return Promise.resolve("").then((result) => {
              return result;
            });
          }
          if (instance.state.settings["get-url"] === void 0) {
            return Promise.resolve("").then((result) => {
              return result;
            });
          }
          return fetch(instance.state.settings["get-url"], {
            method: "GET",
            headers: instance.options.getHeaders
          }).then((response) => {
            if (response.ok) {
              return response.text();
            } else {
              console.error("Network response not ok.");
              return "";
            }
          }).catch((error) => {
            console.error(error);
            return "";
          });
        });
        /**
         * Convert timezone offset (in minutes) to the +HH:mm or -HH:mm format.
         *
         * @param {number} minutes
         * @returns {String}
         */
        __publicField(this, "convertTimezoneOffset", (minutes) => {
          const sign = minutes > 0 ? "-" : "+";
          const absoluteMinutes = Math.abs(minutes);
          const hours = Math.floor(absoluteMinutes / 60);
          const mins = absoluteMinutes % 60;
          const HH = String(hours).padStart(2, "0");
          const mm = String(mins).padStart(2, "0");
          return `${sign}${HH}:${mm}`;
        });
        /**
         * Execute Google reCAPTCHA v3 validation.
         *
         * @returns {Promise<string>} The Google reCAPTCHA token
         */
        __publicField(this, "executeRecaptcha", () => {
          const instance = this;
          return new Promise((resolve) => {
            if (!instance.options.recaptcha.siteKey) {
              resolve("");
              return;
            }
            if (!window.grecaptcha) {
              console.error("CAPTCHA not loaded. Please try again.");
              resolve("");
              return;
            }
            window.grecaptcha.ready(() => {
              window.grecaptcha.execute(instance.options.recaptcha.siteKey, {
                action: instance.options.recaptcha.action
              }).then((token) => resolve(token)).catch((error) => {
                console.error("CAPTCHA execution error:", error);
                resolve("");
              });
            });
          });
        });
        /**
         * Convert a file to base64
         *
         * @param {File} file
         * @returns {Promise<string>}
         */
        __publicField(this, "fileToBase64", (file) => {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result.split(",")[1]);
            reader.onerror = (error) => reject(error);
          });
        });
        /**
         * POST form data.
         *
         * @param {boolean} postCondition
         * @param {boolean} end
         * @returns {Promise<{ok: boolean, json: Object}>}
         */
        __publicField(this, "postFormData", (postCondition, end) => {
          const instance = this;
          if (!postCondition) {
            return Promise.resolve({ ok: true, json: {} }).then((result) => {
              return result;
            });
          }
          if (window.location.protocol === "file:") {
            console.warn("Form data not sent: HTML page is a file (CORS issue).");
            return Promise.resolve({ ok: true, json: {} }).then((result) => {
              return result;
            });
          }
          if (instance.state.settings["post-url"] === void 0) {
            console.warn('Form data not sent: "post-url" setting not found.');
            return Promise.resolve({ ok: true, json: {} }).then((result) => {
              return result;
            });
          }
          const formData = new FormData();
          for (const [key, value] of Object.entries(instance.options.postData)) {
            formData.append(key, value);
          }
          let timezoneOffset = "";
          try {
            timezoneOffset = instance.convertTimezoneOffset(
              (/* @__PURE__ */ new Date()).getTimezoneOffset()
            );
          } catch (error) {
            console.error(error);
          }
          for (const [key, value] of Object.entries(instance.state.formData)) {
            if (instance.state.fieldTypes[key] === "datetime-local") {
              formData.append(key, `${value}${timezoneOffset}`);
            } else {
              formData.append(key, value);
            }
          }
          instance.container.querySelectorAll('.fmd-form-password-input[type="password"]').forEach((input) => {
            formData.append(input.getAttribute("name"), input.value);
          });
          const processFiles = async () => {
            const _fileFields = [];
            const fileInputs = instance.container.querySelectorAll(
              '.fmd-form-file-input[type="file"]'
            );
            for (const input of fileInputs) {
              const name = input.getAttribute("name");
              const file = input.files[0];
              if (file) {
                if (instance.options.sendFilesAsBase64) {
                  try {
                    const base64String = await instance.fileToBase64(file);
                    formData.append(name, base64String);
                    formData.append(`${name}Filename`, file.name);
                    formData.append(`${name}Type`, file.type);
                  } catch (error) {
                    console.error(`Error converting file to base64: ${error}`);
                    formData.append(name, file);
                  }
                } else {
                  formData.append(name, file);
                }
                _fileFields.push(name);
              }
            }
            if (_fileFields.length > 0) {
              formData.append("_fileFields", _fileFields.toString());
            }
          };
          instance.container.querySelectorAll('.fmd-form-file-clear-check-input[type="checkbox"]').forEach((input) => {
            const name = input.getAttribute("name");
            formData.append(name, input.checked);
          });
          formData.append("_end", end ? end : "");
          formData.append("_rid", instance.getOrCreateResponseId());
          formData.append(
            "_sheetName",
            instance.state.settings["post-sheet-name"] || ""
          );
          formData.append("_submitted", (/* @__PURE__ */ new Date()).toUTCString());
          return processFiles().then(() => {
            if (instance.options.recaptcha.siteKey) {
              return instance.executeRecaptcha().then((token) => {
                formData.append("_captcha", token);
                return fetch(instance.state.settings["post-url"], {
                  method: "POST",
                  headers: instance.options.postHeaders,
                  body: formData
                }).then(
                  (response) => response.json().then((json) => {
                    return { ok: response.ok, json };
                  }).catch((error) => {
                    console.error(error);
                    return { ok: response.ok, json: {} };
                  })
                ).catch((error) => {
                  console.error(error);
                  return { ok: false, json: {} };
                });
              });
            }
            return fetch(instance.state.settings["post-url"], {
              method: "POST",
              headers: instance.options.postHeaders,
              body: formData
            }).then(
              (response) => response.json().then((json) => {
                return { ok: response.ok, json };
              }).catch((error) => {
                console.error(error);
                return { ok: response.ok, json: {} };
              })
            ).catch((error) => {
              console.error(error);
              return { ok: false, json: {} };
            });
          });
        });
        /**
         * Go through each slide (before the current one) to get the previous one to
         * make active (depending on the jump condition).
         *
         * @returns {{slide: HTMLElement, index: number}} the previous slide and its
         * index
         */
        __publicField(this, "getPrevSlide", () => {
          const instance = this;
          const currentIndex = instance.state.slideData.currentIndex;
          const slides = instance.container.querySelectorAll(".fmd-slide");
          let prevSlide = slides[currentIndex];
          let prevSlideIndex = currentIndex;
          for (let i = currentIndex - 1; i >= 0; i--) {
            const slide = slides[i];
            if (!slide.hasAttribute("data-fmd-jump")) {
              prevSlide = slide;
              prevSlideIndex = i;
              break;
            }
            nunjucks.configure({ autoescape: false });
            const jumpCondition = nunjucks.renderString(
              `{% if ${slide.getAttribute("data-fmd-jump")} %}true{% endif %}`,
              {
                ...instance.state.data,
                ...instance.state.formData
              }
            );
            if (jumpCondition === "true") {
              prevSlide = slide;
              prevSlideIndex = i;
              break;
            }
          }
          return {
            slide: prevSlide,
            index: prevSlideIndex
          };
        });
        /**
         * Go through each slide (after the current one) to get the next one to make
         * active (depending on the jump condition).
         *
         * @returns {{slide: HTMLElement, index: number}} the next slide and its
         * index
         */
        __publicField(this, "getNextSlide", () => {
          const instance = this;
          const currentIndex = instance.state.slideData.currentIndex;
          const slides = instance.container.querySelectorAll(".fmd-slide");
          let nextSlide = slides[currentIndex];
          let nextSlideIndex = currentIndex;
          for (let i = currentIndex + 1; i < slides.length; i++) {
            const slide = slides[i];
            if (!slide.hasAttribute("data-fmd-jump")) {
              nextSlide = slide;
              nextSlideIndex = i;
              break;
            }
            nunjucks.configure({ autoescape: false });
            const jumpCondition = nunjucks.renderString(
              `{% if ${slide.getAttribute("data-fmd-jump")} %}true{% endif %}`,
              {
                ...instance.state.data,
                ...instance.state.formData
              }
            );
            if (jumpCondition === "true") {
              nextSlide = slide;
              nextSlideIndex = i;
              break;
            }
          }
          return {
            slide: nextSlide,
            index: nextSlideIndex
          };
        });
        /**
         * Get the CSS slide transition duration (in milliseconds).
         *
         * @returns {number}
         */
        __publicField(this, "getSlideTransitionDuration", () => {
          const instance = this;
          const rootElem = instance.container.querySelector(".fmd-root");
          if (rootElem.hasAttribute("data-fmd-slide-transition-duration")) {
            return Number(
              rootElem.getAttribute("data-fmd-slide-transition-duration")
            );
          } else {
            let duration = window.getComputedStyle(rootElem).getPropertyValue("--fmd-slide-transition-duration") || "200ms";
            duration = Number(duration.slice(0, -2));
            rootElem.setAttribute("data-fmd-slide-transition-duration", duration);
            return duration;
          }
        });
        /**
         * When a new slide becomes active, do the following: update state, handle
         * page progress (if applicable), handle the display and state of the footer
         * slide control buttons, scroll to top and autofocus (if applicable).
         *
         * @param {HTMLElement} slide
         * @param {number} index
         * @param {boolean} fromInit
         */
        __publicField(this, "hasNewActiveSlide", (slide, index, fromInit) => {
          const instance = this;
          instance.state.slideData.currentIndex = index;
          const pageProgress = instance.container.querySelector(".fmd-page-progress");
          let slidePageProgress;
          if (slide.hasAttribute("data-fmd-page-progress")) {
            slidePageProgress = slide.getAttribute("data-fmd-page-progress");
          } else if (slide.classList.contains("fmd-first-slide")) {
            slidePageProgress = "0%";
          } else if (slide.classList.contains("fmd-end-slide")) {
            slidePageProgress = "100%";
          }
          if (pageProgress && slidePageProgress !== void 0 && instance.state.settings["page-progress"] !== "decorative") {
            const localization = instance.state.settings.localization;
            pageProgress.setAttribute("role", "progressbar");
            pageProgress.setAttribute(
              "aria-label",
              getTranslation(localization, "page-progress")
            );
            pageProgress.setAttribute("aria-valuemin", "0");
            pageProgress.setAttribute("aria-valuemax", "100");
            pageProgress.setAttribute(
              "aria-valuenow",
              slidePageProgress.replace("%", "")
            );
            pageProgress.querySelector(".fmd-progress-bar").setAttribute("style", `width: ${slidePageProgress}`);
          }
          setTimeout(function() {
            if (instance.options.isFullPage) {
              window.scroll({ top: 0 });
            } else {
              instance.container.scroll({ top: 0 });
              const rect = instance.container.getBoundingClientRect();
              if (!fromInit && !(rect.top < window.innerHeight && rect.bottom > 0)) {
                instance.container.scrollIntoView();
              }
            }
            const footerBtnGroup = instance.container.querySelector(
              ".fmd-footer .fmd-btn-group"
            );
            if (footerBtnGroup) {
              const footerPreviousBtn = footerBtnGroup.querySelector(".fmd-previous-btn");
              const footerNextBtn = footerBtnGroup.querySelector(".fmd-next-btn");
              footerBtnGroup.classList.remove("fmd-d-none");
              footerPreviousBtn.disabled = false;
              footerNextBtn.disabled = false;
              if (slide.classList.contains("fmd-first-slide")) {
                footerPreviousBtn.disabled = true;
              } else if (slide.classList.contains("fmd-end-slide")) {
                footerBtnGroup.classList.add("fmd-d-none");
              }
              if (slide.hasAttribute("data-fmd-disable-prev-btn")) {
                footerPreviousBtn.disabled = true;
              }
            }
            if (!fromInit || fromInit && instance.options.isFullPage) {
              if (instance.state.settings.autofocus === "all-slides") {
                const elemToAutofocus = slide.querySelector(
                  "input.fmd-form-str-input, textarea.fmd-form-str-input, input.fmd-form-num-input, select.fmd-form-str-select, input.fmd-form-str-check-input, input.fmd-form-num-check-input, input.fmd-form-datetime-input, input.fmd-form-file-input"
                );
                if (elemToAutofocus) {
                  elemToAutofocus.focus();
                }
              } else {
                const elemToAutofocus = slide.querySelector("[data-fmd-autofocus]");
                if (elemToAutofocus) {
                  elemToAutofocus.focus();
                }
              }
            }
            slide.querySelectorAll("textarea.fmd-form-str-input").forEach((textarea) => {
              instance.setTextareaHeight(textarea);
            });
          }, instance.getSlideTransitionDuration() * 2);
        });
        /**
         * Fade out active slide and fade in next slide. The timeouts make sure that
         * the animations work properly.
         *
         * @param {HTMLElement} activeSlide
         * @param {HTMLElement} nextSlide
         */
        __publicField(this, "fadeInNextSlide", (activeSlide, nextSlide) => {
          const instance = this;
          const rootElem = instance.container.querySelector(".fmd-root");
          rootElem.classList.add("fmd-during-slide-transition");
          activeSlide.classList.add("fmd-fade-out-to-top");
          setTimeout(function() {
            activeSlide.classList.remove("fmd-slide-active");
            nextSlide.classList.add("fmd-fade-in-from-bottom");
            nextSlide.classList.add("fmd-slide-active");
            setTimeout(function() {
              nextSlide.classList.remove("fmd-fade-in-from-bottom");
              activeSlide.classList.remove("fmd-fade-out-to-top");
              setTimeout(function() {
                rootElem.classList.remove("fmd-during-slide-transition");
              }, instance.getSlideTransitionDuration());
            }, instance.getSlideTransitionDuration());
          }, instance.getSlideTransitionDuration());
        });
        /**
         * Fade out active slide and fade in previous slide. The timeouts make sure
         * that the animations work properly.
         *
         * @param {HTMLElement} activeSlide
         * @param {HTMLElement} prevSlide
         */
        __publicField(this, "fadeInPrevSlide", (activeSlide, prevSlide) => {
          const instance = this;
          const rootElem = instance.container.querySelector(".fmd-root");
          rootElem.classList.add("fmd-during-slide-transition");
          activeSlide.classList.add("fmd-fade-out-to-bottom");
          setTimeout(function() {
            activeSlide.classList.remove("fmd-slide-active");
            prevSlide.classList.add("fmd-fade-in-from-top");
            prevSlide.classList.add("fmd-slide-active");
            setTimeout(function() {
              prevSlide.classList.remove("fmd-fade-in-from-top");
              activeSlide.classList.remove("fmd-fade-out-to-bottom");
              setTimeout(function() {
                rootElem.classList.remove("fmd-during-slide-transition");
              }, instance.getSlideTransitionDuration());
            }, instance.getSlideTransitionDuration());
          }, instance.getSlideTransitionDuration());
        });
        /**
         * Disable all clicks. This is added when the slide transition starts, and
         * removed after the slide transition has ended (or if there is an error).
         *
         * @param {MouseEvent} e
         */
        __publicField(this, "disableAllClicks", (e) => {
          e.stopPropagation();
          e.preventDefault();
          return false;
        });
        /**
         * Get error messages from the JSON response received during form submission.
         * By default, it is assumed that the errors in the response will use the
         * OpenAPI format. However, this function can be overridden to make sure
         * other formats are supported.
         *
         * @param {Object} json
         * @returns {Array.<string>}
         */
        __publicField(this, "getSubmissionErrors", (json) => {
          const instance = this;
          const messages = [];
          if (json.errors && Array.isArray(json.errors)) {
            for (const error of json.errors) {
              if (error[instance.options.errorFieldKey] && error[instance.options.errorMessageKey]) {
                messages.push(
                  `${error[instance.options.errorFieldKey]}: ${error[instance.options.errorMessageKey]}`
                );
              } else if (error[instance.options.errorMessageKey]) {
                messages.push(error[instance.options.errorMessageKey]);
              }
            }
          }
          return messages;
        });
        /**
         * Called when the user reaches the end slide. This function can be
         * overridden to do something when the user reaches completion.
         *
         * @param {Object} json
         */
        __publicField(this, "onCompletion", (json) => {
        });
        /**
         * Go to the next slide.
         *
         * @param {HTMLElement} activeSlide
         */
        __publicField(this, "nextSlide", (activeSlide) => {
          const instance = this;
          const rootElem = instance.container.querySelector(".fmd-root");
          rootElem.addEventListener("click", instance.disableAllClicks, true);
          const ctaBtn = activeSlide.querySelector(".fmd-submit-btn") || activeSlide.querySelector(".fmd-next-btn");
          instance.setBtnProcessing(ctaBtn);
          const footerPreviousBtn = instance.container.querySelector(
            ".fmd-footer .fmd-previous-btn"
          );
          if (footerPreviousBtn) {
            instance.setBtnProcessing(footerPreviousBtn);
          }
          const footerNextBtn = instance.container.querySelector(
            ".fmd-footer .fmd-next-btn"
          );
          if (footerNextBtn) {
            instance.setBtnProcessing(footerNextBtn);
          }
          if (activeSlide.tagName === "FORM") {
            if (!instance.formValid(activeSlide)) {
              instance.container.querySelectorAll(".fmd-btn-processing").forEach((btn) => {
                instance.removeBtnProcessing(btn);
              });
              rootElem.removeEventListener("click", instance.disableAllClicks, true);
              return;
            }
          } else {
            instance.removeSlideErrors(activeSlide);
          }
          const nextSlideAndIndex = instance.getNextSlide();
          if (activeSlide === nextSlideAndIndex.slide) {
            instance.addSlideError(activeSlide, ctaBtn, []);
            instance.container.querySelectorAll(".fmd-btn-processing").forEach((btn) => {
              instance.removeBtnProcessing(btn);
            });
            rootElem.removeEventListener("click", instance.disableAllClicks, true);
            return;
          }
          const postCondition = instance.state.settings.page === "form-slides" && (activeSlide.hasAttribute("data-fmd-post") || nextSlideAndIndex.slide.classList.contains("fmd-end-slide")) ? true : false;
          instance.postFormData(
            postCondition,
            nextSlideAndIndex.slide.classList.contains("fmd-end-slide")
          ).then((promiseResult) => {
            if (promiseResult.ok) {
              if (nextSlideAndIndex.slide.classList.contains("fmd-end-slide")) {
                instance.removeResponseId();
                instance.removeSavedFormData();
                const redirect = nextSlideAndIndex.slide.getAttribute("data-fmd-redirect");
                if (redirect) {
                  window.location.href = redirect;
                  return;
                }
              }
              instance.fadeInNextSlide(activeSlide, nextSlideAndIndex.slide);
              instance.hasNewActiveSlide(
                nextSlideAndIndex.slide,
                nextSlideAndIndex.index,
                false
              );
            } else {
              let errorMessages = [];
              try {
                errorMessages = instance.getSubmissionErrors(promiseResult.json);
              } catch (error) {
                console.error(error);
              }
              instance.addSlideError(activeSlide, ctaBtn, errorMessages);
            }
            instance.container.querySelectorAll(".fmd-btn-processing").forEach((btn) => {
              instance.removeBtnProcessing(btn);
            });
            setTimeout(function() {
              rootElem.removeEventListener(
                "click",
                instance.disableAllClicks,
                true
              );
              if (nextSlideAndIndex.slide.classList.contains("fmd-end-slide")) {
                instance.onCompletion(promiseResult.json);
              }
            }, instance.getSlideTransitionDuration() * 3);
          });
        });
        /**
         * Go to the previous slide.
         *
         * @param {HTMLElement} activeSlide
         */
        __publicField(this, "prevSlide", (activeSlide) => {
          const instance = this;
          const rootElem = instance.container.querySelector(".fmd-root");
          rootElem.addEventListener("click", instance.disableAllClicks, true);
          const ctaBtn = activeSlide.querySelector(".fmd-submit-btn") || activeSlide.querySelector(".fmd-next-btn");
          instance.setBtnProcessing(ctaBtn);
          const footerPreviousBtn = instance.container.querySelector(
            ".fmd-footer .fmd-previous-btn"
          );
          if (footerPreviousBtn) {
            instance.setBtnProcessing(footerPreviousBtn);
          }
          const footerNextBtn = instance.container.querySelector(
            ".fmd-footer .fmd-next-btn"
          );
          if (footerNextBtn) {
            instance.setBtnProcessing(footerNextBtn);
          }
          const prevSlideAndIndex = instance.getPrevSlide();
          if (activeSlide === prevSlideAndIndex.slide) {
            console.error("Something went wrong. Please try again.");
            instance.container.querySelectorAll(".fmd-btn-processing").forEach((btn) => {
              instance.removeBtnProcessing(btn);
            });
            rootElem.removeEventListener("click", instance.disableAllClicks, true);
            return;
          }
          instance.fadeInPrevSlide(activeSlide, prevSlideAndIndex.slide);
          instance.hasNewActiveSlide(
            prevSlideAndIndex.slide,
            prevSlideAndIndex.index,
            false
          );
          instance.container.querySelectorAll(".fmd-btn-processing").forEach((btn) => {
            instance.removeBtnProcessing(btn);
          });
          setTimeout(function() {
            rootElem.removeEventListener("click", instance.disableAllClicks, true);
          }, instance.getSlideTransitionDuration() * 3);
        });
        /**
         * Copy code to clipboard. The code block (<pre> element) closest to the
         * copy button is the target.
         *
         * @param {MouseEvent} e
         */
        __publicField(this, "copyCode", (e) => {
          const instance = this;
          e.preventDefault();
          const copyBtn = e.target;
          const codeBlock = copyBtn.closest(".fmd-code-wrapper").querySelector("pre");
          const range = document.createRange();
          range.selectNode(codeBlock);
          window.getSelection().removeAllRanges();
          window.getSelection().addRange(range);
          document.execCommand("copy");
          window.getSelection().removeAllRanges();
          copyBtn.innerHTML = getTranslation(
            instance.state.settings.localization,
            "copy-btn-success"
          );
          setTimeout(function() {
            copyBtn.innerHTML = getTranslation(
              instance.state.settings.localization,
              "copy-btn"
            );
          }, 2e3);
        });
        /**
         * Add all the event listeners.
         *
         * @param {HTMLElement} container
         * @param {boolean} fromInit
         */
        __publicField(this, "addEventListeners", (container, fromInit) => {
          const instance = this;
          if (fromInit) {
            const header = instance.container.querySelector(".fmd-header");
            if (header && instance.options.isFullPage) {
              const pageProgress = instance.container.querySelector(".fmd-page-progress");
              const pageProgressHeight = pageProgress ? pageProgress.offsetHeight : 0;
              const heightToBlur = (pageProgressHeight + header.offsetHeight) / 3;
              window.addEventListener(
                "scroll",
                function() {
                  if (window.scrollY > heightToBlur) {
                    header.classList.add("fmd-header-bg-blur");
                  } else {
                    header.classList.remove("fmd-header-bg-blur");
                  }
                },
                false
              );
            }
            instance.container.querySelectorAll(".fmd-toggle-color-scheme-btn").forEach((btn) => {
              btn.addEventListener("click", instance.toggleColorScheme);
            });
            instance.container.querySelectorAll("form.fmd-slide").forEach((form) => {
              form.addEventListener("submit", function(e) {
                instance.nextSlide(e.target);
              });
            });
            instance.container.querySelectorAll(".fmd-slide .fmd-next-btn").forEach((btn) => {
              btn.addEventListener("click", function(e) {
                if (!btn.classList.contains("fmd-btn-processing")) {
                  const parentSlide = btn.closest(".fmd-slide");
                  instance.nextSlide(parentSlide);
                }
              });
            });
            instance.container.querySelectorAll(".fmd-footer .fmd-previous-btn").forEach((btn) => {
              btn.addEventListener("click", function(e) {
                if (!btn.classList.contains("fmd-btn-processing")) {
                  const activeSlide = instance.container.querySelector(".fmd-slide-active");
                  instance.prevSlide(activeSlide);
                }
              });
            });
            instance.container.querySelectorAll(".fmd-footer .fmd-next-btn").forEach((btn) => {
              btn.addEventListener("click", function(e) {
                if (!btn.classList.contains("fmd-btn-processing")) {
                  const activeSlide = instance.container.querySelector(".fmd-slide-active");
                  if (activeSlide.tagName === "FORM") {
                    activeSlide.querySelector(".fmd-submit-btn").click();
                  } else {
                    instance.nextSlide(activeSlide);
                  }
                }
              });
            });
            instance.container.querySelectorAll(".fmd-restart-btn").forEach((btn) => {
              btn.addEventListener("click", function(e) {
                if (instance.options.isFullPage) {
                  window.location.reload();
                } else {
                  instance._init(false);
                }
              });
            });
          }
          container.querySelectorAll(".fmd-copy-btn").forEach((btn) => {
            btn.addEventListener("click", instance.copyCode);
          });
          container.querySelectorAll(
            "input.fmd-form-str-input, input.fmd-form-num-input, input.fmd-form-str-check-input, input.fmd-form-num-check-input, input.fmd-form-datetime-input, input.fmd-form-file-input"
          ).forEach((input) => {
            if (input.getAttribute("type") === "text" || input.getAttribute("type") === "email" || input.getAttribute("type") === "url" || input.getAttribute("type") === "tel") {
              input.addEventListener("input", instance.textFieldOnInput);
            } else if (input.getAttribute("type") === "number") {
              input.addEventListener("input", instance.numberFieldOnInput);
            } else if (input.getAttribute("type") === "radio" || input.getAttribute("type") === "checkbox") {
              if (input.classList.contains("fmd-form-str-check-input")) {
                input.addEventListener("input", instance.choiceFieldOnInput);
              } else if (input.classList.contains("fmd-form-num-check-input")) {
                input.addEventListener("input", instance.numChoiceFieldOnInput);
              }
            } else if (input.getAttribute("type") === "datetime-local" || input.getAttribute("type") === "date" || input.getAttribute("type") === "time") {
              input.addEventListener("input", instance.datetimeFieldOnInput);
            } else if (input.getAttribute("type") === "file") {
              input.addEventListener("change", instance.fileFieldOnInput);
            }
          });
          container.querySelectorAll("textarea.fmd-form-str-input").forEach((textarea) => {
            textarea.addEventListener("input", instance.textFieldOnInput);
            textarea.addEventListener("input", instance.setTextareaHeightOnInput);
          });
          container.querySelectorAll("select.fmd-form-str-select").forEach((select) => {
            select.addEventListener("input", instance.selectFieldOnInput);
          });
          container.querySelectorAll(".fmd-form-file-reset-btn").forEach((btn) => {
            btn.addEventListener("click", instance.fileInputResetBtnOnClick);
          });
        });
        /**
         * Load the Google reCAPTCHA v3 script asynchronously.
         */
        __publicField(this, "loadRecaptchaScript", () => {
          const instance = this;
          if (!instance.options.recaptcha.siteKey || window.grecaptcha) {
            return;
          }
          const scriptId = `captcha-${instance.options.recaptcha.siteKey}`;
          if (document.getElementById(scriptId)) {
            return;
          }
          const script = document.createElement("script");
          script.setAttribute("id", scriptId);
          script.src = `https://www.google.com/recaptcha/api.js?render=${instance.options.recaptcha.siteKey}&badge=${instance.options.recaptcha.badgePosition}`;
          document.head.appendChild(script);
          if (instance.options.recaptcha.hideBadge) {
            const styleSheet = document.createElement("style");
            styleSheet.textContent = ".grecaptcha-badge { visibility: hidden; }";
            document.head.appendChild(styleSheet);
          }
        });
        /**
         * Initialize settings, set data defined in the template, fetch and set data
         * from remote source, and create the templates.
         *
         * @param {boolean} isFirstInit
         */
        __publicField(this, "_init", (isFirstInit) => {
          const instance = this;
          if (isFirstInit && instance.options.recaptcha.siteKey) {
            instance.loadRecaptchaScript();
          }
          instance.setStateToDefaults();
          const parsedTemplateAndSettings = parseSettings(instance._template);
          instance.template = parsedTemplateAndSettings.template;
          instance.state.settings = {
            ...instance.state.settings,
            ...parsedTemplateAndSettings.settings
          };
          if (!instance.options.isFullPage) {
            let rootElemClass = "fmd-root fmd-root-inline";
            let rootElemStyle = "";
            rootElemClass += " fmd-pb-custom";
            rootElemStyle += ` --fmd-content-padding-bottom-custom: ${instance.options.paddingInlineBottom}px;`;
            if (instance.options.paddingInlineBottom === 0) {
              rootElemClass += " fmd-pb-0";
            }
            rootElemClass += " fmd-px-custom";
            rootElemStyle += ` --fmd-content-padding-x-custom: ${instance.options.paddingInlineHorizontal}px;`;
            if (instance.options.paddingInlineHorizontal === 0) {
              rootElemClass += " fmd-px-0";
            }
            rootElemClass += " fmd-pt-custom";
            rootElemStyle += ` --fmd-content-padding-top-custom: ${instance.options.paddingInlineTop}px;`;
            if (instance.options.paddingInlineTop === 0) {
              rootElemClass += " fmd-pt-0";
            }
            instance.container.innerHTML = [
              "<div",
              '	spellcheck="false"',
              `	class="${rootElemClass}"`,
              `	style="${rootElemStyle}"`,
              `	data-fmd-color-scheme="${instance.state.settings["color-scheme"]}"`,
              `	data-fmd-id="${instance.state.settings.id}"`,
              ">",
              '	<div class="fmd-body">',
              "		<noscript>Please turn on JavaScript to see this page.</noscript>",
              '		<div class="fmd-main">',
              '			<div class="fmd-loader-container">',
              '				<div class="fmd-loader-spinner" role="status" aria-label="Loading"></div>',
              "			</div>",
              "		</div>",
              "	</div>",
              "</div>\n"
            ].join("\n");
          }
          if (instance.state.settings.page === "form-slides") {
            instance.getOrCreateResponseId();
          }
          if (instance.options.isFullPage) {
            if (instance.state.settings.title !== void 0) {
              document.title = instance.state.settings.title;
            }
            if (instance.state.settings.favicon !== void 0) {
              let faviconLink = document.querySelector('link[rel~="icon"]');
              if (!faviconLink) {
                faviconLink = document.createElement("link");
                faviconLink.rel = "icon";
                document.head.appendChild(faviconLink);
              }
              faviconLink.href = instance.state.settings.favicon;
            }
            const mainStylesheetLink = document.querySelector(
              'link[href$="formsmd.min.css"]'
            );
            if (instance.state.settings.dir === "rtl" && mainStylesheetLink) {
              mainStylesheetLink.setAttribute(
                "href",
                mainStylesheetLink.getAttribute("href").replace("formsmd.min.css", "formsmd.rtl.min.css")
              );
            }
          }
          if (isFirstInit) {
            const stylesheet = document.createElement("style");
            stylesheet.setAttribute("type", "text/css");
            stylesheet.innerText = createStyles(instance.state.settings);
            document.head.appendChild(stylesheet);
          }
          try {
            if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
              instance.state.settings.browser = "safari";
            }
          } catch (error) {
            console.error(error);
          }
          const rootElem = instance.container.querySelector(".fmd-root");
          const rootSettingsAttributesMap = {
            "browser": "data-fmd-browser",
            "button-alignment": "data-fmd-button-alignment",
            "dir": "dir",
            "field-size": "data-fmd-field-size",
            "font-size": "data-fmd-font-size",
            "form-style": "data-fmd-form-style",
            "header": "data-fmd-header",
            "headings": "data-fmd-headings",
            "id": "data-fmd-id",
            "label-style": "data-fmd-label-style",
            "localization": "lang",
            "placeholders": "data-fmd-placeholders",
            "rounded": "data-fmd-rounded",
            "vertical-alignment": "data-fmd-vertical-alignment"
          };
          if (instance.options.setColorSchemeAttrsAgain) {
            rootSettingsAttributesMap["color-scheme"] = "data-fmd-color-scheme";
            rootSettingsAttributesMap["color-scheme-scope"] = "data-fmd-color-scheme-scope";
            rootSettingsAttributesMap["color-scheme-toggle"] = "data-fmd-color-scheme-toggle";
          }
          for (const [key, value] of Object.entries(instance.state.settings)) {
            if (rootSettingsAttributesMap[key] !== void 0) {
              const attribute = rootSettingsAttributesMap[key];
              rootElem.setAttribute(attribute, value);
            }
          }
          if (instance.options.setColorSchemeAttrsAgain && instance.state.settings["color-scheme-toggle"] === "show") {
            instance.setPreferredColorScheme();
          }
          const localization = instance.state.settings.localization;
          nunjucks.configure({ autoescape: false });
          instance.container.querySelector(".fmd-body").innerHTML = nunjucks.renderString(madeInLoaderTemplate, {
            settings: instance.state.settings,
            translations: {
              loading: getTranslation(localization, "loading"),
              madeInLoader: getTranslation(localization, "made-in-loader")
            }
          });
          const parsedTemplateAndData = parseDataBlocks(instance.template);
          instance.template = parsedTemplateAndData.template;
          instance.state.data = {
            ...instance.state.data,
            ...parsedTemplateAndData.data
          };
          instance.getRemoteData().then((promiseResult) => {
            if (promiseResult !== "") {
              const getFormat = instance.state.settings["get-format"];
              const getObjectsName = instance.state.settings["get-objects-name"];
              if (getFormat === "json") {
                const promiseResultJSON = JSON.parse(promiseResult);
                if (Array.isArray(promiseResultJSON)) {
                  instance.state.data[getObjectsName] = promiseResultJSON;
                } else {
                  instance.state.data = {
                    ...instance.state.data,
                    ...promiseResultJSON
                  };
                }
              } else {
                let delimeter = ",";
                if (getFormat === "tsv") {
                  delimeter = "	";
                }
                const parsedSpreadsheetData = parseSpreadsheetData(
                  promiseResult,
                  delimeter
                );
                instance.state.data = {
                  ...instance.state.data,
                  ...parsedSpreadsheetData.dataSpreadsheet
                };
                instance.state.data[getObjectsName] = parsedSpreadsheetData.dataNormalized;
              }
            }
            const bodyTemplateAndSettings = createBodyTemplate(
              instance.state.settings
            );
            const bodyTemplate = bodyTemplateAndSettings.template;
            instance.state.settings = bodyTemplateAndSettings.settings;
            instance.container.querySelector(".fmd-body").innerHTML = bodyTemplate;
            if (instance.state.settings["page-progress"] === "hide") {
              rootElem.setAttribute("data-fmd-page-progress", "hide");
            }
            if (!instance.state.settings["header-render"]) {
              rootElem.setAttribute("data-fmd-header", "hide");
            }
            if (!instance.state.settings["footer-render"]) {
              rootElem.setAttribute("data-fmd-footer", "hide");
            }
            const contentTemplateAndBindDivs = createContentTemplate(
              instance.template,
              instance.state.settings,
              {
                ...instance.state.data,
                ...instance.state.formData
              },
              instance.options.sanitize
            );
            instance.template = contentTemplateAndBindDivs.template;
            instance.state.bindDivTemplates = contentTemplateAndBindDivs.bindDivTemplates;
            instance.container.querySelector(".fmd-main-container").insertAdjacentHTML("beforeend", instance.template);
            instance.container.querySelectorAll("pre code").forEach((codeBlock) => {
              hljs.highlightElement(codeBlock);
            });
            instance.addEventListeners(instance.container, true);
            instance.setFormDataToState();
            if (!instance.options.prioritizeURLFormData) {
              try {
                instance.setFormDataFromURL(false);
              } catch (error) {
                console.error(error);
              }
            }
            if (instance.options.saveState) {
              try {
                instance.setSavedFormData();
              } catch (error) {
                console.error(error);
              }
            }
            if (instance.options.prioritizeURLFormData) {
              try {
                instance.setFormDataFromURL(true);
              } catch (error) {
                console.error(error);
              }
            }
            instance.container.querySelector(".fmd-loader-container").classList.add("fmd-d-none");
            if (instance.state.settings.page !== "single") {
              const firstSlide = instance.container.querySelectorAll(".fmd-slide")[instance.options.startSlide];
              firstSlide.classList.add("fmd-slide-active");
              instance.hasNewActiveSlide(
                firstSlide,
                instance.options.startSlide,
                true
              );
            } else {
              instance.container.querySelector(".fmd-single").classList.add("fmd-single-active");
              instance.container.querySelectorAll("textarea.fmd-form-str-input").forEach((textarea) => {
                instance.setTextareaHeight(textarea);
              });
            }
          });
        });
        /**
         * Initialize for the first time.
         */
        __publicField(this, "init", () => {
          const instance = this;
          instance._init(true);
        });
        this.container = container;
        if (options) {
          if (options.colorScheme === "light" || options.colorScheme === "dark") {
            this.options.colorScheme = options.colorScheme;
          }
          if (options.errorFieldKey !== void 0 && typeof options.errorFieldKey === "string") {
            this.options.errorFieldKey = options.errorFieldKey;
          }
          if (options.errorMessageKey !== void 0 && typeof options.errorMessageKey === "string") {
            this.options.errorMessageKey = options.errorMessageKey;
          }
          if (options.footer === "hide" || options.footer === "show") {
            this.options.footer = options.footer;
          }
          if (options.formsmdBranding === "hide" || options.formsmdBranding === "show") {
            this.options.formsmdBranding = options.formsmdBranding;
          }
          if (options.getHeaders !== void 0 && typeof options.getHeaders === "object") {
            this.options.getHeaders = {
              ...this.options.getHeaders,
              ...options.getHeaders
            };
          }
          if (options.isFullPage !== void 0 && typeof options.isFullPage === "boolean") {
            this.options.isFullPage = options.isFullPage;
          }
          if (options.paddingInlineBottom !== void 0 && typeof options.paddingInlineBottom === "number") {
            this.options.paddingInlineBottom = options.paddingInlineBottom;
          }
          if (options.paddingInlineHorizontal !== void 0 && typeof options.paddingInlineHorizontal === "number") {
            this.options.paddingInlineHorizontal = options.paddingInlineHorizontal;
          }
          if (options.paddingInlineTop !== void 0 && typeof options.paddingInlineTop === "number") {
            this.options.paddingInlineTop = options.paddingInlineTop;
          }
          if (options.pageProgress === "hide" || options.pageProgress === "show" || options.pageProgress === "decorative") {
            this.options.pageProgress = options.pageProgress;
          }
          if (options.postData !== void 0 && typeof options.postData === "object") {
            this.options.postData = {
              ...this.options.postData,
              ...options.postData
            };
          }
          if (options.postHeaders !== void 0 && typeof options.postHeaders === "object") {
            this.options.postHeaders = {
              ...this.options.postHeaders,
              ...options.postHeaders
            };
          }
          if (options.prioritizeURLFormData !== void 0 && typeof options.prioritizeURLFormData === "boolean") {
            this.options.prioritizeURLFormData = options.prioritizeURLFormData;
          }
          if (options.recaptcha !== void 0 && typeof options.recaptcha === "object") {
            if (options.recaptcha.siteKey !== void 0 && typeof options.recaptcha.siteKey === "string") {
              this.options.recaptcha.siteKey = options.recaptcha.siteKey;
            }
            if (options.recaptcha.action !== void 0 && typeof options.recaptcha.action === "string") {
              this.options.recaptcha.action = options.recaptcha.action;
            }
            if (options.recaptcha.badgePosition !== void 0 && typeof options.recaptcha.badgePosition === "string") {
              this.options.recaptcha.badgePosition = options.recaptcha.badgePosition;
            }
            if (options.recaptcha.hideBadge !== void 0 && typeof options.recaptcha.hideBadge === "boolean") {
              this.options.recaptcha.hideBadge = options.recaptcha.hideBadge;
            }
          }
          if (options.sanitize !== void 0 && typeof options.sanitize === "boolean") {
            this.options.sanitize = options.sanitize;
          }
          if (options.saveState !== void 0 && typeof options.saveState === "boolean") {
            this.options.saveState = options.saveState;
          }
          if (options.sendFilesAsBase64 !== void 0 && typeof options.sendFilesAsBase64 === "boolean") {
            this.options.sendFilesAsBase64 = options.sendFilesAsBase64;
          }
          if (options.setColorSchemeAttrsAgain !== void 0 && typeof options.setColorSchemeAttrsAgain === "boolean") {
            this.options.setColorSchemeAttrsAgain = options.setColorSchemeAttrsAgain;
          } else if (!this.options.isFullPage) {
            this.options.setColorSchemeAttrsAgain = false;
          }
          if (options.slideControls === "hide" || options.slideControls === "show") {
            this.options.slideControls = options.slideControls;
          }
          if (options.startSlide !== void 0 && typeof options.startSlide === "number") {
            this.options.startSlide = options.startSlide;
          }
          if (options.themeDark !== void 0 && typeof options.themeDark === "object") {
            if (options.themeDark.accent !== void 0 && typeof options.themeDark.accent === "string") {
              this.options.themeDark.accent = options.themeDark.accent;
            }
            if (options.themeDark.accentForeground !== void 0 && typeof options.themeDark.accentForeground === "string") {
              this.options.themeDark.accentForeground = options.themeDark.accentForeground;
            }
            if (options.themeDark.backgroundColor !== void 0 && typeof options.themeDark.backgroundColor === "string") {
              this.options.themeDark.backgroundColor = options.themeDark.backgroundColor;
            }
            if (options.themeDark.color !== void 0 && typeof options.themeDark.color === "string") {
              this.options.themeDark.color = options.themeDark.color;
            }
          }
          if (options.themeLight !== void 0 && typeof options.themeLight === "object") {
            if (options.themeLight.accent !== void 0 && typeof options.themeLight.accent === "string") {
              this.options.themeLight.accent = options.themeLight.accent;
            }
            if (options.themeLight.accentForeground !== void 0 && typeof options.themeLight.accentForeground === "string") {
              this.options.themeLight.accentForeground = options.themeLight.accentForeground;
            }
            if (options.themeLight.backgroundColor !== void 0 && typeof options.themeLight.backgroundColor === "string") {
              this.options.themeLight.backgroundColor = options.themeLight.backgroundColor;
            }
            if (options.themeLight.color !== void 0 && typeof options.themeLight.color === "string") {
              this.options.themeLight.color = options.themeLight.color;
            }
          }
        }
        const templateSettingsFromOptions = [];
        let colorScheme = this.options.colorScheme;
        const templateContainsColorScheme = template.match(
          /#!\s*color-scheme\s*=\s*(light|dark)/
        );
        if (templateContainsColorScheme) {
          colorScheme = templateContainsColorScheme[1];
        } else {
          templateSettingsFromOptions.push(`#! color-scheme = ${colorScheme}`);
        }
        let theme = this.options.themeLight;
        let themeAltScheme = this.options.themeDark;
        if (colorScheme === "dark") {
          theme = this.options.themeDark;
          themeAltScheme = this.options.themeLight;
        }
        templateSettingsFromOptions.push(
          `#! accent = ${theme.accent} || ${themeAltScheme.accent}`
        );
        templateSettingsFromOptions.push(
          `#! accent-foreground = ${theme.accentForeground} || ${themeAltScheme.accentForeground}`
        );
        templateSettingsFromOptions.push(
          `#! background-color = ${theme.backgroundColor} || ${themeAltScheme.backgroundColor}`
        );
        templateSettingsFromOptions.push(
          `#! color = ${theme.color} || ${themeAltScheme.color}`
        );
        if (this.options.formsmdBranding !== void 0) {
          templateSettingsFromOptions.push(
            `#! formsmd-branding = ${this.options.formsmdBranding}`
          );
        }
        if (this.options.footer !== void 0) {
          templateSettingsFromOptions.push(`#! footer = ${this.options.footer}`);
        }
        if (this.options.pageProgress !== void 0) {
          templateSettingsFromOptions.push(
            `#! page-progress = ${this.options.pageProgress}`
          );
        }
        if (this.options.slideControls !== void 0) {
          templateSettingsFromOptions.push(
            `#! slide-controls = ${this.options.slideControls}`
          );
        }
        this._template = `${templateSettingsFromOptions.join("\n")}

${template}`;
      }
    };
    exports.Formsmd = Formsmd;
  }
});

// node_modules/formsmd/src/index.js
var require_src = __commonJS({
  "node_modules/formsmd/src/index.js"(exports) {
    var { translate, Composer } = require_composer();
    var { Formsmd } = require_main();
    exports.translate = translate;
    exports.Composer = Composer;
    exports.Formsmd = Formsmd;
  }
});
export default require_src();
/*! Bundled license information:

nunjucks/browser/nunjucks.js:
  (*! Browser bundle of nunjucks 3.2.4  *)

dompurify/dist/purify.cjs.js:
  (*! @license DOMPurify 3.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.1/LICENSE *)

formsmd/src/main.js:
  (*!
   * Forms.md
   * @author Tahmid Khan Nafee <tahmid.hm.dev@gmail.com>
   * @license BUSL-1.1
   * Copyright (c) 2024 Tahmid Khan Nafee
   *)

formsmd/src/index.js:
  (*!
   * Forms.md
   * @author Tahmid Khan Nafee <tahmid.hm.dev@gmail.com>
   * @license BUSL-1.1
   * Copyright (c) 2024 Tahmid Khan Nafee
   *)
*/
//# sourceMappingURL=formsmd.js.map
